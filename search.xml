<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[腾讯云服务器部署 Node 应用]]></title>
    <url>%2F%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2node%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言就在前天，微信群里有人说腾讯云服务器搞活动 1核2G 一个月10块钱，一起拼团的话还有优惠，我就心动了，一下续了二年的，正好结合我所掌握的技术点，走通上线部署的流程，不仅可以巩固我所掌握的知识点，也是让自己学的东西有个输出。 云服务器我的云服务器主机的基本配置 服务器登录Mac 下可以使用自带的终端或者 iTerm2 通过命令方式进行登录 ssh root@&lt;公网IP&gt; 安装 Node 运行环境用 nvm 来管理 node 版本： curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.0/install.sh | bash 安装 node： nvm install v8.9.5node -v Hello worldconst http = require('http');const server = http.createServer((req, res) =&gt; &#123; res.statusCode = 200; res.setHeader('Content-Type', 'text/plain'); res.end('Hello World\n');&#125;);server.listen(3000, () =&gt; &#123; console.log(`Server is running at port 3000`);&#125;); 在服务端执行： 在浏览器中打开: 域名解析虽然可以通过 IP 地址访问, 但是记忆起来比较困难, 可以通过配置域名来访问 node 应用。 我原本就有一个 baixiaojian.com 的域名,所以我再次基础上配一个二级域名指向自己的主机,如 ok.baixiaojian.com, 访问主机时 通过 nginx 反向代理到服务器指定端口应用,这样的一个好处就是可以使80端口共用, 域名解析默认是 80 端口, 如果不是 80 端口,就需要指定端口号, 就像这样 ok.baixiaojian.com:4000 这样的体验是非常差的,所以nginx使80端口可以共用是非常必要的。 安装nginx配置nginx TransmitTransmit 是 Mac下一款实用的FTP客户端软件，它使用起来非常的稳定，速度也比较理想。 使用教程 pm2 进程管理pm2入门指南]]></content>
      <categories>
        <category>快捷操作</category>
      </categories>
      <tags>
        <tag>腾讯云</tag>
        <tag>Node</tag>
        <tag>部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx 笔记]]></title>
    <url>%2Fnginx%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[图源来自知乎 反向代理的优点 保护真实 web 服务器，其对外不可见； 节约了有限的 ip 地址资源； 减少 web 服务器压力，提高响应速度； 请求的统一控制，包括设置权限、过滤规则等； 区分动态和静态可缓存内容； 实现负载均衡，内部可以采用多台服务器来组成服务器集群，外部还是可以采用一个地址访问； 解决 Ajax 跨域问题； 作为真实服务器的缓冲，解决瞬间负载量大的问题； 配置文件main # 全局设置events &#123; # Nginx工作模式 ....&#125;http &#123; # http设置 .... upstream myproject &#123; # 负载均衡服务器设置 ..... &#125; server &#123; # 主机设置 .... location &#123; # URL匹配 .... &#125; &#125; server &#123; .... location &#123; .... &#125; &#125; ....&#125; 功能实现基于域名的虚拟主机第一步: 假设我们在本地开发有3个项目，需要分别在 hosts 里映射到本地的127.0.0.1上： 127.0.0.1 www.aaa.com127.0.0.1 www.bbb.com127.0.0.1 www.ccc.com 第二步: 分别对应于web根目录下的3个文件夹，用域名对应文件夹名字，为了好记： /Users/baixiaojian/www/www.aaa.com//Users/baixiaojian/www/www.bbb.com//Users/baixiaojian/www/www.ccc.com/ 每个目录都有一个 index.html 文件, 都是简单的输出自己的域名. 第三步: 我们要新建3个server来搭建对应个域名的虚拟主机。 这3个 server 配置信息都写成一个 .conf 的配置文件,然后在 http 模块统一导入,这样比较便于维护和管理 mainevents &#123; ....&#125;http &#123; .... include servers/www.aaa.conf; include servers/www.bbb.conf; include servers/www.ccc.conf; # 或者用 *.conf 包含 # include servers/*.conf&#125; 既然每一个conf都是一个server，下面就开始： ### www.aaa.com server &#123; charset utf-8; listen 80; server_name www.aaa.com; location / &#123; root /Users/baixiaojian/www/www.aaa.com/; index index.html index.htm; &#125; &#125; ### www.bbb.com server &#123; charset utf-8; listen 80; server_name www.bbb.com; location / &#123; root /Users/baixiaojian/www/www.bbb.com/; index index.html index.htm; &#125; &#125; ### www.ccc.com server &#123; charset utf-8; listen 80; server_name www.ccc.com; location / &#123; root /Users/baixiaojian/www/www.ccc.com/; index index.html index.htm; &#125; &#125; 这样3个很精简的虚拟域名就搭建好了。重启下nginx，然后打开浏览器访问一下这3个域名，就能看到对应的域名内容了。 反向代理Nginx 使用反向代理，主要是使用location模块下的 proxy_pass 选项。 来个最简单的。当我访问 mac 上的nginx 的 centos.com 的内容时候,就反向代理到虚拟机centos上的 10.211.55.5 的index.html页面。 第一步: 在 hosts 里新加域名: #vi /etc/hosts 127.0.0.1 centos.com 第二步: 在 servers 目录中新建一个 .conf 的配置文件： #centos.confserver &#123; listen 80; server_name centos.com; location / &#123; proxy_pass http://10.211.55.5; &#125;&#125; 执行 sudo nginx -s reload 重启后访问 centos.com 负载均衡啥是负载均衡 ?比如我们有一个小网站，刚开始就一台nginx服务器，后来，随着业务量增大，用户增多，一台服务器已经不够用了，我们就又多加了几台服务器。那么这几台服务器 如何调度 ？如何均匀提供访问 ？这就是负载均衡。 负载均衡的好处是可以集群多台机器一起工作，并且对外的IP和域名是一样的，外界看起来就好像一台机器一样。 基于 weight 权重的负载upstream webservers&#123; server 192.168.33.11 weight=10; server 192.168.33.12 weight=10; server 192.168.33.13 weight=10;&#125;server &#123; listen 80; server_name upstream.com; location / &#123; proxy_pass http://webservers; proxy_set_header X-Real-IP $remote_addr; &#125;&#125; 基于 ip_hash 的负载每个请求按访问IP的hash结果分配，这样来自同一个IP的访客固定访问一个后端服务器，有效解决了动态网页存在的session共享问题。 upstream webservers&#123; ip_hash; server 192.168.33.11 weight=1 max_fails=2 fail_timeout=30s; server 192.168.33.12 weight=1 max_fails=2 fail_timeout=30s; server 192.168.33.13 down;&#125; 注: ip_hash 模式下，不要设置 weight 和 backup 页面缓存只需要简单配置下，就能将指定的一个页面缓存起来.原理就是匹配当前访问的url, hash加密后，去指定的缓存目录查找, 有的话就说明匹配到缓存. 先来看一下一个简单的页面缓存的配置： http &#123; proxy_cache_path /data/nginx/cache levels=1:2 keys_zone=cache_zone:10m inactive=1d max_size=100m; # proxy_cache_path path [levels=number] keys_zone=zone_name:zone_size [inactive=time] [max_size=size]; # path =&gt; 缓存路径 # levels =&gt; 文件夹级数 # keys_zone =&gt; 指的是共享池的名称 # inactive =&gt; 表示指定的时间内缓存的数据没有被请求则被删除 # max_size =&gt; 缓存区域的总大小 # clean_time =&gt; 表示每间隔自动清除的时间 upstream myproject &#123; ..... &#125; server &#123; .... location ~ *\.php$ &#123; proxy_cache cache_zone; # keys_zone的名字 proxy_cache_key $host$uri$is_args$args; # 缓存规则 proxy_cache_valid any 1d; # 为不同的http响应状态码设置不同的缓存时间。 proxy_pass http://127.0.0.1:8080; &#125; &#125; ....&#125; 开始进行实战 第一步: Parallels Desktop 上启动一台 linux 虚拟机(10.211.55.5) 第二部: Mac hosts配置 cache.com 域名, 然后按照上面的配置在 servers 下新建一个 cache.conf 文件: proxy_cache_path /usr/local/var/cache levels=1:2 keys_zone=cache_zone:10m inactive=1d max_size=100m;server &#123; listen 80; server_name cache.com; add_header X-Via $server_addr; add_header X-Cache $upstream_cache_status; location / &#123; proxy_set_header X-Real-IP $remote_addr; proxy_cache cache_zone; proxy_cache_key $host$uri$is_args$args; proxy_cache_valid 200 304 1m; proxy_pass http://10.211.55.5; &#125;&#125; 访问 cache.com 查看 network 网络请求选项，我们可以看到，Response Headers，在这里我们可以看到： X-Cache: MISSX-Via: 127.0.0.1 X-cache 为 MISS 表示未命中，请求被传送到后端。因为是第一次访问，没有缓存，所以肯定是未命中。我们再刷新下，就发现其变成了HIT, 表示命中。 X-cache 的其他几种状态： 状态 说明 MISS 未命中，请求被传送到后端 HIT 缓存命中 EXPIRED 缓存已经过期请求被传送到后端 UPDATING 正在更新缓存，将使用旧的应答 STALE 后端将得到过期的应答 BYPASS 缓存被绕过了 我们再去看看缓存文件夹 /usr/local/var/cache里面是否有了文件： cache git:(master) cd a/13➜ 13 git:(master) ls5bd1af99bcb0db45c8bd601d9ee9e13a➜ 13 git:(master) pwd/usr/local/var/cache/a/13 已经生成了缓存文件。 我们在url 后面随便加一个什么参数，看会不会新生成一个缓存文件夹及文件：http://cache.com/?w=ww55 。因为我们使用的生成规则是全部url转换(proxy_cache_key $host$uri$is_args$args;) 查看 X-cache 为 MISS，再刷新 ，变成HIT。缓存文件夹 /usr/local/var/cache 又会多出对应缓存文件. Location 正则模块location / 表示匹配访问根目录。location ~ 表示开启正则匹配。还可以用这个来匹配静态资源，缓存它们，设置过期时间： location ~ .*\.(gif|jpg|jpeg|bmp|png|ico|txt|mp3|mp4|swf)&#123; expires 15d;&#125;location ~ .*\.(css|js)&#123; expires 12d;&#125; 配置说明# 运行用户user www-data; # 启动进程,通常设置成和cpu的数量相等worker_processes 1;# 全局错误日志及PID文件error_log /var/log/nginx/error.log;pid /var/run/nginx.pid;# 工作模式及连接数上限events &#123; use epoll; #epoll是多路复用IO(I/O Multiplexing)中的一种方式,但是仅用于linux2.6以上内核,可以大大提高nginx的性能 worker_connections 1024; #单个后台worker process进程的最大并发链接数 # multi_accept on; &#125;#设定http服务器，利用它的反向代理功能提供负载均衡支持http &#123; #设定mime类型,类型由mime.type文件定义 include /etc/nginx/mime.types; default_type application/octet-stream; #设定日志格式 access_log /var/log/nginx/access.log; #sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，对于普通应用， #必须设为 on,如果用来进行下载等应用磁盘IO重负载应用，可设置为 off，以平衡磁盘与网络I/O处理速度，降低系统的uptime. sendfile on; #将tcp_nopush和tcp_nodelay两个指令设置为on用于防止网络阻塞 tcp_nopush on; tcp_nodelay on; #连接超时时间 keepalive_timeout 65; #开启gzip压缩 gzip on; gzip_disable &quot;MSIE [1-6]\.(?!.*SV1)&quot;; #设定请求缓冲 client_header_buffer_size 1k; large_client_header_buffers 4 4k; include /etc/nginx/conf.d/*.conf; include /etc/nginx/sites-enabled/*; #设定负载均衡的服务器列表 upstream mysvr &#123; #weigth参数表示权值，权值越高被分配到的几率越大 #本机上的Squid开启3128端口 server 192.168.8.1:3128 weight=5; server 192.168.8.2:80 weight=1; server 192.168.8.3:80 weight=6; &#125; server &#123; #侦听80端口 listen 80; #定义使用www.xx.com访问 server_name www.xx.com; #设定本虚拟主机的访问日志 access_log logs/www.xx.com.access.log main; #默认请求 location / &#123; root /root; #定义服务器的默认网站根目录位置 index index.php index.html index.htm; #定义首页索引文件的名称 fastcgi_pass www.xx.com; fastcgi_param SCRIPT_FILENAME $document_root/$fastcgi_script_name; include /etc/nginx/fastcgi_params; &#125; # 定义错误提示页面 error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root /root; &#125; #静态文件，nginx自己处理 location ~ ^/(images|javascript|js|css|flash|media|static)/ &#123; root /var/www/virtual/htdocs; #过期30天，静态文件不怎么更新，过期可以设大一点，如果频繁更新，则可以设置得小一点。 expires 30d; &#125; #PHP 脚本请求全部转发到 FastCGI处理. 使用FastCGI默认配置. location ~ \.php$ &#123; root /root; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /home/www/www$fastcgi_script_name; include fastcgi_params; &#125; #设定查看Nginx状态的地址 location /NginxStatus &#123; stub_status on; access_log on; auth_basic &quot;NginxStatus&quot;; auth_basic_user_file conf/htpasswd; &#125; #禁止访问 .htxxx 文件 location ~ /\.ht &#123; deny all; &#125; &#125; #第一个虚拟服务器 server &#123; #侦听192.168.8.x的80端口 listen 80; server_name 192.168.8.x; #对aspx后缀的进行负载均衡请求 location ~ .*\.aspx$ &#123; root /root;#定义服务器的默认网站根目录位置 index index.php index.html index.htm;#定义首页索引文件的名称 proxy_pass http://mysvr;#请求转向mysvr 定义的服务器列表 #以下是一些反向代理的配置可删除. proxy_redirect off; #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; client_max_body_size 10m; #允许客户端请求的最大单文件字节数 client_body_buffer_size 128k; #缓冲区代理缓冲用户端请求的最大字节数， proxy_connect_timeout 90; #nginx跟后端服务器连接超时时间(代理连接超时) proxy_send_timeout 90; #后端服务器数据回传时间(代理发送超时) proxy_read_timeout 90; #连接成功后，后端服务器响应时间(代理接收超时) proxy_buffer_size 4k; #设置代理服务器（nginx）保存用户头信息的缓冲区大小 proxy_buffers 4 32k; #proxy_buffers缓冲区，网页平均在32k以下的话，这样设置 proxy_busy_buffers_size 64k; #高负荷下缓冲大小（proxy_buffers*2） proxy_temp_file_write_size 64k; #设定缓存文件夹大小，大于这个值，将从upstream服务器传 &#125; &#125;&#125; 参考资料]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>mac</tag>
        <tag>nginx</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx 安装与基本操作]]></title>
    <url>%2Fnginx%2F</url>
    <content type="text"><![CDATA[Mac 安装brew search nginxbrew install nginx 安装完成后, 终端输出会显示相关 路径配置 ： /usr/local/etc/nginx/nginx.conf -&gt; 配置文件路径`/usr/local/var/www -&gt; 服务器默认路径/usr/local/Cellar/nginx/1.8.0 -&gt; 安装路径 命令 作用 启动 sudo nginx 快速停止命令 sudo nginx -s stop 平稳退出命令 sudo nginx -s quit 查询nginx主进程号 ps -ef “I” grep nginx 正常停止 sudo kill -QUIT 主进程号 快速停止 sudo kill -TERM 主进程号 重启 sudo nginx -s reload CentOS 安装 1.添加Nginx到YUM源 sudo rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm 2.安装Nginx sudo yum install -y nginx 3.首次启动 sudo systemctl start nginx.service 4.验证是否成功 通过本机域名或者IP来访问web页面注意: 要关闭防火墙否则其他主机无法访问到 说明 命令 启动 service nginx start 停止 service nginx stop 重启 service nginx restart 开机自启 sudo systemctl enable nginx.service 查看 nginx 安装路径 rpm -ql nginx Nginx配置信息 作用 路径 网站文件存放默认目录 /usr/share/nginx/html 网站默认站点配置 /etc/nginx/conf.d/default.conf 自定义Nginx站点配置文件存放目录 /etc/nginx/conf.d/ Nginx全局配置 /etc/nginx/nginx.conf 防火墙操作 说明 命令 查看防火墙状态 firewall-cmd –state 关闭防火墙 systemctl stop firewalld 开启防火墙 systemctl start firewalld 参考资料1参考资料2]]></content>
      <categories>
        <category>配置相关</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>nginx</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac 环境变量相关及开发相关文件解读]]></title>
    <url>%2Fmac%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[环境变量配置OS系统的配置文件加载顺序： /etc/profile /etc/paths ~/.bash_profile /etc/profile、/etc/bashrc 是针对系统所有用户的 全局变量, 如修改需权限,~/.bash_profile 是当前 用户级 的环境变量, 所以通常去修改它来设置环境变量. 操作步骤: 1. 终端输入 vi ~/.bash_profile2. 设置 PATH：export PATH=/usr/local/mysql/bin:$PATH3. 输入 :wq4. 立即生效 source ~/.bash_profile5. 查看变量值 echo $PATH 注: 删除环境变量需重启shell才能立即生效 开发相关文件 应用程序(Applications) 系统(System) 用户(User) 资料库(Library) 隐藏文件夹 文件夹 作用 usr unix 使用者专用文件夹 bin unix 储存基本指令 sbin unix 储存系统指令 etc 系统设定 储存位置 var 频繁改动 置放于此, 如监控、日志等 tmp 系统暂存档 usr/local 本地文件系统配置相关文件 usr/local/etc 相关配置文件 其他 文件夹 作用 / 磁盘根目录 也就是 Macintosh HD 目录下 ~ 或者 /User/ 当前用户目录的顶级目录 /user/Shared 目录可以被本地的所有用户访问 Sites 用户个人站点网页文件。需设置 “系统预置-&gt;共享-&gt;Web共享” 中打开共享 Public 可以把需要与其它用户共享的文件放在这个目录中]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>环境变量</tag>
        <tag>设置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode]]></title>
    <url>%2Fvscode%2F</url>
    <content type="text"><![CDATA[快捷键基础 按键 作用 Commend + X 剪切 Commend + C 复制 Commend + V 粘贴 Alt + up/down 移动行上下 Shift + Alt up/down 在当前行上下复制当前行 Commend + Enter 在当前行下插入新的一行 Commend + Shift + Enter 在当前行上插入新的一行 Commend + Alt + [/] 折叠/展开区域代码 Ctrl + K/O 前缩进/后缩进 Commend + / 添加关闭行注释 Shift + Alt +A 块区域注释 导航 按键 作用 Ctrl + G 跳转行 Commend + P 跳转文件 Commend + R 查找方法或标签 Commend + Shift + M 打开问题展示面板 F8 跳转到下一个错误或者警告 Shift + F8 跳转到上一个错误或者警告 查询与替换 按键 作用 Commend + F 查询 Alt + Enter 选中所有查询结果 F3 / Shift + F3 查询下一个/上一个 Commend + D 选中下一个相同 Control + Commend + G / Commend + F2 选中所有相同 多行光标操作于选择 快捷键 作用 Commend + Click 多选光标 Commend + F2 选中所有相同 Commend + Alt + up/down 上下插入光标 Commend + Shift + Click 集选光标 丰富的语言操作 快捷键 作用 Shift + Alt + F 格式化代码 Ctrl + R 打开 Git Project 文件夹 Commend + K + Commend + F 格式化选中部分的代码 F12 跳转到定义处 Alt + F12 代码片段显示定义 Ctrl + K F12 在其他窗口打开定义处 Shift + F12 显示所有引用 F2 重命名符号 编辑器管理 快捷键 作用 Commend + W 关闭编辑器 Commend + \ 切割编辑窗口 Commend + Alt &lt;-/-&gt; 切割窗口位置调换 文件管理 快捷键 作用 Commend + N 新建文件 Commend + O 打开文件 Commend + S 保存文件 Commend + Alt + S 保存所有文件 Commend + K Commend + W 关闭所有编辑窗口 Commend + W 关闭当前编辑窗口 Commend + Shift + T 撤销最近关闭的一个文件编辑窗口 Commend + Shift + S 另存为 Commend + K S 键盘快捷方式指南 Commend + K P 复制当前打开文件的存放路径 Commend + K R 打开vscode官方快捷键指南 显示 快捷键 作用 Ctrl + Commend + F 切换全屏模式 Commend + =/- 放大 / 缩小 Commend + B 侧边栏显示隐藏 Commend + Shift + E 资源视图和编辑视图的焦点切换 Commend + Shift + F 打开全局搜索 Ctrl + Shift + G 打开Git可视管理 Ctrl + Shift + D 打开DeBug面板 Ctrl + Shift + X 打开插件市场面板 Ctrl + Shift + H 在当前文件替换查询替换 Ctrl + Shift + J 开启详细查询 Ctrl + Shift + V 预览Markdown文件【编译后】 Ctrl + K v 在边栏打开渲染后的视图【新建】 调试 快捷键 作用 F9 添加解除断点 F5 启动调试、继续 F11 / Shift + F11 单步进入/单步跳出 F10 单步跳过 集成终端 快捷键 作用 Commend + ` 打开集成终端 Commend + Shift + ` 创建一个新的终端 Commend + Shift + C 复制所选 Commend + Shift + V 复制到当前激活的终端 插件 插件 功能 Guides 括号高亮 Beautiful 格式化 One Monokai Theme 主题不错 Bookmarks 书签工具 Path Autocomplete 路径智能补全 Path Intellisense 路径智能提示 Code Spell Checker 检查单词拼写 markdownlint markdown 语法检测 expand-region 逐渐选中光标所在内容 ESLint 可以配置自动格式代码规范 Output Colorizer 可以终端日志输出着色，实用 Markdown All in One 自动补全/格式化table/… Debugger for Chrome 在vscode调试代码, 屌的一比 Code Runner 代码编译运行看结果支持多语言 colorize 会给当前颜色代码该颜色的背景 Git Project Manager 可以很方便的打开自己的 git 项目 background 自己敲代码时有一个妹子看的感觉不赖 Version Lens 可以及时看到package.json内部版本的变动 Git Lens 可以很方便的查看 git 的各种提交记录及成员间的更改 Git History 有 Git Lens 没有的功能, 比如查看某一个成员的历史提交 参考资料VS Code折腾记-快捷键VS Code折腾记-必备插件]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>快捷键</tag>
        <tag>vscode</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Structured Query Language]]></title>
    <url>%2Fspl%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[“web” 表 +----+--------------+---------------------------+-------+---------+| id | name | url | alexa | country |+----+--------------+---------------------------+-------+---------+| 1 | Google | https://www.google.cm/ | 1 | USA || 2 | 淘宝 | https://www.taobao.com/ | 13 | CN || 3 | 菜鸟教程 | http://www.runoob.com/ | 4689 | CN || 4 | 微博 | http://weibo.com/ | 20 | CN || 5 | Facebook | https://www.facebook.com/ | 3 | USA |+----+--------------+---------------------------+-------+---------+ “access_log” 表 +-----+---------+-------+------------+| aid | site_id | count | date |+-----+---------+-------+------------+| 1 | 1 | 45 | 2016-05-10 || 2 | 3 | 100 | 2016-05-13 || 3 | 1 | 230 | 2016-05-14 || 4 | 2 | 10 | 2016-05-14 || 5 | 5 | 205 | 2016-05-14 || 6 | 4 | 13 | 2016-05-15 || 7 | 3 | 220 | 2016-05-15 || 8 | 5 | 545 | 2016-05-16 || 9 | 3 | 201 | 2016-05-17 |+-----+---------+-------+------------+ 增删改查例子有限,要结合基础知识举一反三 SELECT基本操作 指令 含义 SELECT * FROM web; 查找 web 内每条数据的所有字段 SELECT name,country FROM web; 查找 web 内每条数据的 name、country 字段 SELECT DISTINCT country FROM web; 查找 web 中 去重后 的 country 值 SELECT * FROM web WHERE country=’CN’; 从 web 中找出 country为CN 的所有字段 SELECT * FROM web WHERE id=1; 从 web 中找出 id为1 数据 SELECT * FROM web WHERE country=&#39;CN&#39; and alexa &lt; 50; 从 web 中找出 国家为中国并且排名小于50 的 名称字段 SELECT * FROM web WHERE country=&#39;CN&#39; or alexa &lt; 50; 从 web 中找出 国家为中国或者排名小于50 的 名称字段 SELECT * FROM web WHERE alexa &gt; 15 AND (country=&#39;CN&#39; OR country=&#39;USA&#39;); 从 web 中找出 中国或美国并且排名要大于15 的 所有字段 SELECT * FROM web ORDER BY alexa; 取出 web 中 所有字段,并按照 alexa 排序 SELECT * FROM web ORDER BY country,alexa; 取出 web 中 所有字段,并按照 country 与 alexa 排序 SELECT * FROM web LIMIT 2; 取出 web 中 前俩条数据 SELECT * FROM web WHERE name LIKE &#39;G%&#39;; 取出 web 中 name 以 G 开始的数据 SELECT * FROM web WHERE name LIKE &#39;%oo%&#39;; 包含 “oo” 的数据 SELECT * FROM web WHERE name NOT LIKE &#39;%oo%&#39;; 不包含 “oo” 的数据 SELECT * FROM web WHERE name LIKE &#39;_oogle&#39;; 下划线表任意字符 _oogle SELECT * FROM web WHERE name LIKE &#39;G_o_le&#39;; 任意字符拼接的 G_o_le SELECT * FROM web WHERE name REGEXP &#39;^[GFs]&#39;; 结合正则匹配 name 以 G/F/s 开头的数据 SELECT * FROM web WHERE name in (&#39;google&#39;,&#39;淘宝&#39;); 找出 name 为 google/淘宝 的数据 SELECT * FROM web WHERE alexa BETWEEN 1 AND 20; 找出 排名在 1-20 之间的数据 SELECT name AS n, country AS c FROM web; 指定 name 与 country 的字段别名 SELECT name, CONCAT(url, ‘, ‘, alexa, ‘, ‘, country) AS site_info FROM web; 连接 url/alexa/country 在一起并创建新命名 SELECT w.name FROM Websites AS w WHERE w.name=”菜鸟教程”; 连接表的别名 注意的点 先将country值这一列排序，同为CN的排前面，同属USA的排后面； 然后在同属CN的这些多行数据中，再根据alexa值的大小排列。 ORDER BY 排列时，不写明 ASC、DESC 的时候，默认是ASC。 JOIN 列出可以使用的不同的 SQL JOIN 类型： INNER JOIN：如果表中有至少一个匹配，则返回行 LEFT JOIN：即使右表中没有匹配，也从左表返回所有的行 RIGHT JOIN：即使左表中没有匹配，也从右表返回所有的行 FULL JOIN：只要其中一个表中存在匹配，则返回行 深度阅读 INSERT 指令 含义 INSERT INTO web (name, url, alexa, country) VALUES (‘百度’,’https:xxx’,’4’,’CN’); 往 web 内插入数据 注：一次性插入多条数据，中间使用逗号隔开 DELETE 删除数据，注：使用delete一定要记得使用 WHERE条件限制 指令 含义 DELETE FROM web WHERE name=’百度’ AND country=’CN’; 从 web 中删除 name 为 百度 且国家为 CN 的网站 。 UPDATE 更新数组，注：也一定要记得使用 WHERE条件限制 指令 含义 UPDATE web SET alexa=’5000’, country=’USA’ WHERE name=’菜鸟教程’; 更新 web 内 name 为 菜鸟教程 的 alexa 排名为 5000，country 改为 USA。 基础知识SQL 关键字使用 类型 说明 from 表 select 选择的字段 where 查询的条件 limit 起始记录位置，取记录的条数 group by 分组属性 having 分组过滤的条件 order by 起始记录位置，取记录的条数 where后可约束的条件 符号 含义 &gt; 大于 &lt; 小于 &gt;= 大于等于 &lt;= 小于等于 != 或者 &lt;&gt; 不等于 = 等于 or 或者 and 并且 between 在某个比区间 in 在该范围内 not in 不在该范围内 _驴 匹配什么驴 %x 匹配结尾是驴的 LIKE 搜索某种模式]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>spl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongodb 安装与基本配置]]></title>
    <url>%2Fmongodb%2F</url>
    <content type="text"><![CDATA[查看brew listbrew search mongodb 安装brew install mongodb 启动首次执行 mongod 尝试启动 MongoDB , 但会失败 exiting: ➜ ~ mongod2018-01-26T15:11:13.278+0800 I CONTROL [initandlisten] MongoDB starting : pid=8954 port=27017 dbpath=/data/db 64-bit host=baixiaojiandeMacBook-Pro.local2018-01-26T15:11:13.278+0800 I CONTROL [initandlisten] db version v3.6.22018-01-26T15:11:13.278+0800 I CONTROL [initandlisten] git version: 489d177dbd0f0420a8ca04d39fd78d0a2c5394202018-01-26T15:11:13.278+0800 I CONTROL [initandlisten] OpenSSL version: OpenSSL 1.0.2n 7 Dec 20172018-01-26T15:11:13.278+0800 I CONTROL [initandlisten] allocator: system2018-01-26T15:11:13.278+0800 I CONTROL [initandlisten] modules: none2018-01-26T15:11:13.278+0800 I CONTROL [initandlisten] build environment:2018-01-26T15:11:13.278+0800 I CONTROL [initandlisten] distarch: x86_642018-01-26T15:11:13.278+0800 I CONTROL [initandlisten] target_arch: x86_642018-01-26T15:11:13.278+0800 I CONTROL [initandlisten] options: &#123;&#125;2018-01-26T15:11:13.279+0800 I STORAGE [initandlisten] exception in initAndListen: NonExistentPath: Data directory /data/db not found., terminating2018-01-26T15:11:13.279+0800 I CONTROL [initandlisten] now exiting2018-01-26T15:11:13.279+0800 I CONTROL [initandlisten] shutting down with code:100 启动 MongoDB 之前, 要先新建一个 MongoDB 默认的数据写入目录 // sudo 并输入密码，重新新建目录$ sudo mkdir -p /data/dbPassword: 给刚才新建的数据库目录赋予权限: $ sudo chown -R baixiaojian /data 此时,执行 mongod 启动 MongoDB 服务: ➜ ~ mongod2018-01-26T15:17:54.988+0800 I CONTROL [initandlisten] MongoDB starting : pid=9551 port=27017 dbpath=/data/db 64-bit host=baixiaojiandeMacBook-Pro.local2018-01-26T15:17:54.989+0800 I CONTROL [initandlisten] db version v3.6.22018-01-26T15:17:54.989+0800 I CONTROL [initandlisten] git version: 489d177dbd0f0420a8ca04d39fd78d0a2c5394202018-01-26T15:17:54.989+0800 I CONTROL [initandlisten] OpenSSL version: OpenSSL 1.0.2n 7 Dec 20172018-01-26T15:17:54.989+0800 I CONTROL [initandlisten] allocator: system2018-01-26T15:17:54.989+0800 I CONTROL [initandlisten] modules: none2018-01-26T15:17:54.989+0800 I CONTROL [initandlisten] build environment:2018-01-26T15:17:54.989+0800 I CONTROL [initandlisten] distarch: x86_642018-01-26T15:17:54.989+0800 I CONTROL [initandlisten] target_arch: x86_642018-01-26T15:17:54.989+0800 I CONTROL [initandlisten] options: &#123;&#125;2018-01-26T15:17:54.990+0800 I STORAGE [initandlisten] wiredtiger_open config: create,cache_size=7680M,session_max=20000,eviction=(threads_min=4,threads_max=4),config_base=false,statistics=(fast),log=(enabled=true,archive=true,path=journal,compressor=snappy),file_manager=(close_idle_time=100000),statistics_log=(wait=0),verbose=(recovery_progress),2018-01-26T15:17:55.353+0800 I CONTROL [initandlisten]2018-01-26T15:17:55.353+0800 I CONTROL [initandlisten] ** WARNING: Access control is not enabled for the database.2018-01-26T15:17:55.353+0800 I CONTROL [initandlisten] ** Read and write access to data and configuration is unrestricted.2018-01-26T15:17:55.353+0800 I CONTROL [initandlisten]2018-01-26T15:17:55.353+0800 I CONTROL [initandlisten] ** WARNING: This server is bound to localhost.2018-01-26T15:17:55.353+0800 I CONTROL [initandlisten] ** Remote systems will be unable to connect to this server.2018-01-26T15:17:55.353+0800 I CONTROL [initandlisten] ** Start the server with --bind_ip &lt;address&gt; to specify which IP2018-01-26T15:17:55.353+0800 I CONTROL [initandlisten] ** addresses it should serve responses from, or with --bind_ip_all to2018-01-26T15:17:55.353+0800 I CONTROL [initandlisten] ** bind to all interfaces. If this behavior is desired, start the2018-01-26T15:17:55.353+0800 I CONTROL [initandlisten] ** server with --bind_ip 127.0.0.1 to disable this warning.2018-01-26T15:17:55.353+0800 I CONTROL [initandlisten]2018-01-26T15:17:55.360+0800 I STORAGE [initandlisten] createCollection: admin.system.version with provided UUID: acffed24-1106-4136-bf4d-d2894c0cb3e32018-01-26T15:17:55.443+0800 I COMMAND [initandlisten] setting featureCompatibilityVersion to 3.62018-01-26T15:17:55.447+0800 I STORAGE [initandlisten] createCollection: local.startup_log with generated UUID: 5414b600-b049-49b5-aad7-c20beb480c412018-01-26T15:17:55.551+0800 I FTDC [initandlisten] Initializing full-time diagnostic data capture with directory &apos;/data/db/diagnostic.data&apos;2018-01-26T15:17:55.551+0800 I NETWORK [initandlisten] waiting for connections on port 27017 MongoDB 启动成功,等待被连接中… 连接新建命令行窗口, 执行 mongo 进入 MongoDB 命令行模式: ➜ ~ mongoMongoDB shell version v3.6.2connecting to: mongodb://127.0.0.1:27017MongoDB server version: 3.6.2Server has startup warnings:2018-01-26T15:17:55.353+0800 I CONTROL [initandlisten]2018-01-26T15:17:55.353+0800 I CONTROL [initandlisten] ** WARNING: Access control is not enabled for the database.2018-01-26T15:17:55.353+0800 I CONTROL [initandlisten] ** Read and write access to data and configuration is unrestricted.2018-01-26T15:17:55.353+0800 I CONTROL [initandlisten]2018-01-26T15:17:55.353+0800 I CONTROL [initandlisten] ** WARNING: This server is bound to localhost.2018-01-26T15:17:55.353+0800 I CONTROL [initandlisten] ** Remote systems will be unable to connect to this server.2018-01-26T15:17:55.353+0800 I CONTROL [initandlisten] ** Start the server with --bind_ip &lt;address&gt; to specify which IP2018-01-26T15:17:55.353+0800 I CONTROL [initandlisten] ** addresses it should serve responses from, or with --bind_ip_all to2018-01-26T15:17:55.353+0800 I CONTROL [initandlisten] ** bind to all interfaces. If this behavior is desired, start the2018-01-26T15:17:55.353+0800 I CONTROL [initandlisten] ** server with --bind_ip 127.0.0.1 to disable this warning.2018-01-26T15:17:55.353+0800 I CONTROL [initandlisten]&gt; 4685*9894633465&gt; 连接成功, 然后就可以对数据库进行操作了.]]></content>
      <categories>
        <category>配置相关</category>
      </categories>
      <tags>
        <tag>mongod</tag>
        <tag>基本配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[busy recently]]></title>
    <url>%2Flog-busy%2F</url>
    <content type="text"><![CDATA[最近有点忙一些想记的笔记想吐的槽都被忙碌的时间搁了浅早九晚九+周末单休+今天也是在夜深人静后挤出的 “闲暇” 时光可能忙碌中才能更好的积累与沉淀吧 刚有空把书签栏整理一下删掉了许多不在需要或者无效的书签看起来更舒服了]]></content>
      <categories>
        <category>东拉西扯</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[charles 抓取 https]]></title>
    <url>%2FcharlesConfig%2F</url>
    <content type="text"><![CDATA[待完善Charles 电脑上下载证书 始终相信 保存并导出证书 导入在手机中并安装]]></content>
      <categories>
        <category>配置相关</category>
      </categories>
      <tags>
        <tag>charles</tag>
        <tag>https</tag>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[term]]></title>
    <url>%2Fterm%2F</url>
    <content type="text"><![CDATA[待完善内存带宽单线程多线程进程死锁单点故障三次握手子网掩码端口集群高并发持续集成内存泄漏虚拟地址物理地址负载均衡虚拟DOM压力测试前后端分离反向代理闭包HTTPHTTPSes6新特性 new Proxy/async/await/map/setdockerSEOTPSCPUCPU 密集型闭包算法]]></content>
      <categories>
        <category>专业术语</category>
      </categories>
      <tags>
        <tag>术语</tag>
        <tag>进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017 LastDay]]></title>
    <url>%2F2017-last-day%2F</url>
    <content type="text"><![CDATA[2017年的最后一天 时间过得好快，夜幕就要降临，我想我必须要离开,当我正要走时我看到一家… 等等… 这是什么节奏,明明要写年终总结，还是被神曲洗脑带偏了 关于90后的”18岁” 昨天朋友圈被许许多多的 “18岁” 要成为成年人的照片刷爆了屏， 90后中最小的成员从明天开始也成为了成年人，开始扛起中国新时代的大旗， 从某种层面上就意味着90后这个群体已 不再年轻 的同时肩上的责任更重了， 相对于80后，90后的时代应该是比较幸运的，更过姿多彩的， 在身处信息爆炸的时代，信息与知识的获取已经变得及其容易， 一些像 “我吃的盐比你走的路都要多” 这样的话，已经变越来越不能证明什么了， 之前在法治栏目看过一个毒贩就是在百度上通过搜索相关资料就可以自己制作出冰毒， 网络是一把双刃剑，让人们生活变的便利的同时，风险和危险也会随之而来, 呃，好像有点扯远了… 我自己的18岁 其实本来没什么的，原本计划今年跨年陪家人吃个饭其他一切照常， 但被刷爆的朋友圈的影响下，自己也不仅多了一些感慨， 18岁啊18岁，这个真是一个花样年华的年纪，我已记不清那时的我在做什么。 但有一点我是确认的，就是去网吧再也不用用别人的身份证了， 哈哈…可能就这点出息了 年龄什么的现在一般都记得不确切， 如果说90后最小的明天就成年了，那么 00-94+18 = 24岁 对，是，没错 我今年已经24岁，24啊24 , &quot;曾经沧海难为水，除去巫山不是云&quot; 突然就想到这句话了 不贴切， 但我实际想说的是，18岁时得我以为 25岁什么的离我很遥远， 现在看来还真是 too young 啊！ 现在25都不用24++，只要一个虚岁就到了… 关于 2017 年 如果要总结2017年的话我真的要想想 提取记忆中 一月份... 二月份... 三月份... 四月份... 五月份... 六月份... 七月份... 八月份... 九月份... 十月份... 十一月份... 十二月份...大脑运行内存不足，提取失败! 这他喵的尴尬了，身为一个程序员，直接导出 database 效果不是想要的， 要按照关键词提取嘛! 提取关键词中 加班加班加班... 撕逼撕逼撕逼... 砍需求砍需求... 狗粮狗粮狗粮... bugbugbug... 撸撸撸撸撸撸... 学习学习学习...扎心了老铁,提取成功！ 这他喵的还是尴尬啊，哎 不管了，虽然2017年有缺憾的地方，但这不就是人生嘛， 某某牛逼闪闪放光芒的某某学家就说过 “没有遗憾，不是人生” 翻译成大白话就是 “你连遗憾有没有你还是人？” 2017关键词自己总结2017年关键词的话就是： 学习、沉淀、孤独、坚持、成长 关键词提取核心观念 持续学习 =&gt; 不学习就会被淘汰 积累沉淀 =&gt; 量变引起质变 选择孤独 =&gt; 孤独好似美酒 不懈坚持 =&gt; 爱好&gt;环境&gt;毅力 迎接成长 =&gt; 只是以上关键词附属品 2017年其实不错、很好、very棒，忙碌而充实，是我想要的。 2018 展望其实说展望有点怪怪的，因为明天就是2018了，而明天在说今天就是回顾2017了，哈哈 哇塞，刚打到2018时有种2008的既视感， 转眼间已过十年，十年啊， 十年之前我不认识你，你不属于我，我们还是一样，陪在一个陌生人左右… 等等… 咋又开始了，由此可见 muisc 的魔力，总是能被它影响 2017到2018，也就是由 咯咯咯到汪汪汪，而我是属汪汪汪的啊，那么就是我的本命年了啊！ 是不是就应该带红绳什么的，光想想就好激动的呢！ 2018年要和2017年一样继续积累与沉淀。]]></content>
      <categories>
        <category>东拉西扯</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mac终端常用命令]]></title>
    <url>%2Fmac%E7%BB%88%E7%AB%AF%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Mac 终端常用命令 命令名 功能描述 使用举例 mkdir 创建一个目录 mkdir dirname rmdir 删除一个目录 rmdir dirname mv -f 移动或重命名一个目录 mv -f dir1 dir2 cd 改变当前目录 cd dirname pwd 显示当前目录的路径名 pwd touch 新建一个文件 touch index.html ls 显示当前目录的内容 ls -la cat 显示或连接文件 cat filename rm 删除文件或目录 rm filename mv 改变文件名或所在目录 mv file1 file2 open 使用默认的程序打开文件 open filename grep 在文件中按模式查找 grep “^[a-zA-Z]” filename passwd 修改用户密码 passwd ping 给一个网络主机发送 回应请求 ping hpc.sp.net.edu.cn history 列出最近执行过的几条命令及编号 history alias 给某个命令定义别名 alias del=rm -i unalias 取消对某个别名的定义 unalias del clear 清除屏幕或窗口内容 clear uniq 去掉文件中的重复行 uniq file1 file2 env 显示当前所有设置过的环境变量 env who 列出当前登录的所有用户 who whoami 显示当前正进行操作的用户名 whoami Mac 终端命令大全目录操作 命令名 功能描述 使用举例 mkdir 创建一个目录 mkdir dirname rmdir 删除一个目录 rmdir dirname mv -f 移动或重命名一个目录 mv -f dir1 dir2 cd 改变当前目录 cd dirname pwd 显示当前目录的路径名 pwd ls 显示当前目录的内容 ls -la dircmp 比较两个目录的内容 dircmp dir1 dir2 文件操作 命令名 功能描述 使用举例 cat 显示或连接文件 cat filename pg 分页格式化显示文件内容 pg filename more 分屏显示文件内容 more filename od 显示非文本文件的内容 od -c filename cp 复制文件或目录 cp file1 file2 rm 删除文件或目录 rm filename mv 改变文件名或所在目录 mv file1 file2 ln 联接文件 ln -s file1 file2 find 使用匹配表达式查找文件 find . -name “*.c” -print file 显示文件类型 file filename open 使用默认的程序打开文件 open filename 选择文件 命令名 功能描述 使用举例 head 显示文件的最初几行 head -20 filename tail 显示文件的最后几行 tail -15 filename cut 显示文件每行中的某些域 cut -f1,7 -d: /etc/passwd colrm 从标准输入中删除若干列 colrm 8 20 file2 paste 横向连接文件 paste file1 file2 diff 比较并显示两个文件的差异 diff file1 file2 sed 非交互方式流编辑器 sed “s/red/green/g” filename grep 在文件中按模式查找 grep “^[a-zA-Z]” filename awk 在文件中查找并处理模式 awk ‘{print $1 $1}’ filename sort 排序或归并文件 sort -d -f -u file1 uniq 去掉文件中的重复行 uniq file1 file2 comm 显示两有序文件的公共和非公共行 comm file1 file2 wc 统计文件的字符数、词数和行数 wc filename nl 给文件加上行号 nl file1 &gt;file2 安全操作 命令名 功能描述 使用举例 passwd 修改用户密码 passwd chmod 改变文件或目录的权限 chmod ug+x filename umask 定义创建文件的权限掩码 umask 027 chown 改变文件或目录的属主 chown newowner filename chgrp 改变文件或目录的所属组 chgrp staff filename xlock 给终端上锁 xlock -remote 编程操作 命令名 功能描述 使用举例 make 维护可执行程序的最新版本 make touch 更新文件的访问和修改时间 touch -m 05202400 filename dbx 命令行界面调试工具 dbx a.out xde 图形用户界面调试工具 xde a.out 进程操作 命令名 功能描述 使用举例 ps 显示进程当前状态 ps u kill 终止进程 kill -9 30142 nice 改变待执行命令的优先级 nice cc -c *.c renice 改变已运行进程的优先级 renice +20 32768 时间操作 命令名 功能描述 使用举例 date 显示系统的当前日期和时间 date cal 显示日历 cal 8 1996 time 统计程序的执行时间 time a.out 网络与通信操作 命令名 功能描述 使用举例 telnet 远程登录 telnet hpc.sp.net.edu.cn rlogin 远程登录 rlogin hostname -l username rsh 在远程主机执行指定命令 rsh f01n03 date ftp 在本地主机与远程主机之间传输文件 ftp ftp.sp.net.edu.cn rcp 在本地主机与远程主机 之间复制文件 rcp file1 host1:file2 ping 给一个网络主机发送 回应请求 ping hpc.sp.net.edu.cn mail 阅读和发送电子邮件 mail write 给另一用户发送报文 write username pts/1 mesg 允许或拒绝接收报文 mesg n Korn Shell 命令 命令名 功能描述 使用举例 history 列出最近执行过的几条命令及编号 history r 重复执行最近执行过的某条命令 r -2 alias 给某个命令定义别名 alias del=rm -i unalias 取消对某个别名的定义 unalias del 其它命令 命令名 功能描述 使用举例 uname 显示操作系统的有关信息 uname -a clear 清除屏幕或窗口内容 clear env 显示当前所有设置过的环境变量 env who 列出当前登录的所有用户 who whoami 显示当前正进行操作的用户名 whoami tty 显示终端或伪终端的名称 tty stty 显示或重置控制键定义 stty -a du 查询磁盘使用情况 du -k subdir df 显示文件系统的总空间和可用空间 df /tmp w 显示当前系统活动的总信息 w]]></content>
      <categories>
        <category>快捷操作</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>命令</tag>
        <tag>mac</tag>
        <tag>终端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim 基本操作]]></title>
    <url>%2Fvim%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Vim的三种模式命令模式 刚刚启动Vim时，便进入了命令模式。 此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。 比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。 以下是常用的几个命令： 命令 含义 i 切换到插入模式，以输入字符。 x 删除当前光标所在处的字符。 : 切换到底线命令模式，以在最底一行输入命令。 输入模式 在命令模式下按下i就进入了输入模式 命令 含义 字符按键以及Shift组合 输入字符 ENTER 回车键，换行 BACK SPACE 退格键，删除光标前一个字符 DEL 删除键，删除光标后一个字符 方向键 在文本中移动光标 HOME/END 移动光标到行首/行尾 Page Up/Page Down 上/下翻页 Insert 切换光标为输入/替换模式，光标将变成竖线/下划线 ESC 退出输入模式，切换到命令模式 底线命令模式 按ESC键可随时退出底线命令模式 命令 含义 :q 不保存,直接退出(未编辑) :q! 不保存，并强制退出 :e! 放弃所有修改，从上次保存文件开始再编辑 :w 保存文件,但不退出 :w! 强制保存，不退出 :wq或:x 保存，并退出 :wq! 强制保存，并退出]]></content>
      <categories>
        <category>快捷操作</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>vim</tag>
        <tag>基本操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 笔记]]></title>
    <url>%2Fgit%2F</url>
    <content type="text"><![CDATA[回退相关操作工作区 命令 含义 git checkout – file.txt 丢弃 file.txt 中的修改 git reset –hard 重设暂存区所有文件并且还原工作区所有修改 暂存区 命令 含义 git reset 重设暂存区所有文件 git reset HEAD 撤销最新一次的 add 状态 git reset file.txt 把 file.txt 的放入工作区 git reset –hard 重设暂存区所有文件并且还原工作区所有修改 版本区 HEAD =&gt; 当前版本 HEAD^ =&gt; 上一个版本 HEAD^^ =&gt; 上上一个版本 HEAD~100 =&gt; 上一100个版本 命令 含义 git revert HEAD 撤销最新一次的 commit ,分支没有改动文件才能执行(存在该commit记录) git reset &lt;commit&gt; 删除最新一次的 commit 并且重设暂存区所有文件 (不存在该commit版本号) git reset HEAD~2 将当前分支倒退两个提交(高危操作) git reset –hard HEAD^ 回退上一个版本 删除文件 命令 含义 rm file.txt 删除文件 git checkout – file.txt 撤销删除 (未commit之前) git clean -n 查看那些未被跟踪文件会被移除 git clean -f 移除当前目录下未被跟踪的文件 git clean -df 移除未跟踪的文件以及目录 git clean -f &lt;path&gt; 移除未跟踪的文件，但限制在某个路径下 git clean -xf 移除当前目录下未跟踪的文件，以及 Git 一般忽略的文件 创建与合并分支 命令 含义 git checkout -b dev 创建并且切换到dev分支 git checkout -b hotfix dev 基于dev分支创建一个hotfix分支 git checkout dev 切换到dev分支 git branch 查看所有的分支 git branch -d dev 删除dev分支(当前分支无法自行删除) git branch -D dev 强制删除分支(用于未合并分支) git merge dev 将dev分支合并到当前分支 远程仓库的操作 命令 含义 git remote -v 查看远程仓库的详细信息 git remote add remote-name URL 添加远程仓库 git push origin master 将内容提交到远程仓库 origin 的 master 分支上 git remote rm origin 将远程仓库 origin 删除 git remote rename origin pb 将远程仓库 origin 改为 pb git clone URL 克隆一个远程仓库，这里的URL是远程仓库的地址 git pull origin 将远程仓库中更新的数据拉到本地 git pull origin dev 拉取远程仓库dev分支到本地 git push origin aaa 将 aaa 分支推送到远程仓库 git pull –rebase URL git rebase 代替 git merge 合并本地分支 git push –force 强制推送 git commit 命令 含义 git commit –amend 和上一次 commit 合并,并在该基础上编辑commit信息 git commit –amend –no-edit 和上一次 commit 合并, 不编辑信息 git commit -a -m “some modified” git add -A &amp;&amp; git commit -m ‘some modified’ git rebase &lt;base&gt; 是可以使任何类型的提交引用（ID/分支名/标签/HEAD） 参考文档1 参考文档2 什么是 git rebase(变基==改变基线) 变基是将分支移到一个新的基提交的过程, 产生的是一个快速向前的合并以及完美的线性历史 rebase 就好像是说「我想将我的更改建立在其他人的进展之上」 绝不要在公共的分支上使用它 git rebase &lt;base&gt; =&gt; git merge &lt;base&gt; 相似 git rebase –continue =&gt; 解决冲突后可执行的命令 git rebase –abort =&gt; 终止rebase的行动，并且所在分支会回到rebase开始前的状态。 git rebase -i &lt;base&gt; =&gt; 交互式 fixup startq squash git reflog Git 用引用日志这种机制来记录分支顶端的更新 git reflog =&gt; 显示本地仓库的引用日志 git reflog –relative-date =&gt; 用相对的日期显示引用日志 git reset –hard 0254ea7 配合使用 注: 引用日志提供的安全网只对提交到本地仓库的更改有效，而且只有移动操作会被记录 其他操作 git log –oneline =&gt; 简洁的显示 log 记录 报错处理 fatal: Unable to create ‘project_path/.git/index.lock’: File exists. 删除该分支 =&gt; rm -f .git/index.lock error: failed to push some refs to &lt;URL&gt; 第一种解决方式: 强推，即利用强覆盖方式用你本地的代码替代git仓库内的内容 =&gt; git push -f 第二种解决方式: 这条命令等于合并远程分支，合并完成之后同目录会出现README.md目录 =&gt; git pull –rebase origin master fatal: remote origin already exists 先删除远程 Git 仓库 =&gt; git remote rm origin 再添加远程 Git 仓库 =&gt; git remote add origin &lt;URL&gt; 如果执行 git remote rm origin 还报错的话 我们可以手动修改 gitconfig 文件的内容 =&gt; vi .git/config 把 [remote “origin”] 那一行删掉就好了。 error: src refspec master does not match any 引起该错误的原因是，目录中没有文件，空目录是不能提交上去的 touch README =&gt; git add README =&gt; git commit -m ‘first commit’ =&gt; git push origin maste 用 git reset --hard 命令导致目录下所有文件全部被清除。 首先用 git reflog 命令查找到对应的sha值,如：cd7b575 通过“git reset –hard cd7b575” 注意：第二步操作有时会报错, 如: fatal: Unable to create ‘D:/chenjunjun/.git/index.lock’: File exists. 需要手动删除.git目录下的index.lock文件]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FEDAY3 笔记]]></title>
    <url>%2FFEDAY3%2F</url>
    <content type="text"><![CDATA[构建大型应用分享人：孟红伦(钉钉) 重要的俩块 使用 TypeScript 解决代码 复杂 ,数据模型的问题 使用 RxJS 更好的解决 异步 带来的问题 代码如何复杂 上百个 RPC 接口 几十种消息推送 10W + 行代码 模块依赖关系复杂 数据模型复杂 钉钉犯过的错 开发时没有考虑到个人用户登录时的 ‘org’ 字段 因为开发环境中是 归属某个企业 的,忽视了对 不归属任何企业的个人用户的测试 最后还是用户主动反映了这个问题 问题责任:测试的锅 什么是Typescript 它是 JS 的超集,兼容 ES5,ES2015/16/17. 它的编译结果是 JS , 可以运行在浏览器/Node端. 它支持 TS 和 JS 混用 主流框架支持程度 Angular 2.0 完全支持 VUE 2.0 部分支持 模板中还不具备 Type Check 的能力 React 完全支持 jsx 不是 ‘模板’而是 js,所以 Type Check 支持的很好 异步逻辑的处理 RxJS 实现渐进式搜索 使用 Rx.js Observable 可以更好更直观的描述这些 API,帮助你在错综复杂的异步 API 调用中少犯错 项目中如何选择框架和库分享人：张克军(豆瓣) 特指公司规模比较大,协作开发的人数比较多,商业型项目 商业型项目的核心 注重以结果为导向 高效率高质量的产出产品 考虑方面 迭代周期长,方案的选择就要 长期有效性 代码可维护性 伸缩性,用比较小的成本应对可能随时变更的需求 方案的选择需要更务实 基本前提 成本和效率 实现目标的成本和效率 团队协作的成本和效率 后续迭代的成本和效率 选择库时经常谈到的关键词 模式,普及率,成熟度 体量,局限性,学习成本 性能,活跃度,周边资源 前景,契合度,文档质量 选择的原则 妥适性原则(避免过度实现) 库的选择: 缩小依赖范围和向稳定方向依赖 避重趋轻、避繁逐简、以简驭繁、避虚就实 可替代性 主框架的选择 没有不二法则 拥抱未来 经验价值高 架构上的优势为重 选择的原则(白话版) 妥适性原则(避免过度实现) 库的选择，尽量同时满足以下条件 单一性 普遍性 轻量型 依赖少 主框架的选择：做足调研和实践，多和老司机交流 code Review 十分重要 包分析工具可以分析出项目中库的依赖和自己写得代码的比重 https://www.npmjs.com/package/webpack-bundle-analyzer RN跨三端技术实践分享人：刘威(京东金融) 移动开发常见问题 原生开发 门槛高 原生发版到上线相对 周期长 原生线上问题相对 难修复 H5 相对原生 体验差 RN优缺点 优点 学习成本低 体验接近原生 二端代码可复用 社区活跃 缺点 不支持热更新 不支持h5 向下兼容性差 低端机型会有崩溃 三端平台-架构 关于热更新苹果官方停掉热更新之后并不影响RN，因为RN热更新没有更改底层的OC代码 缓存机制 模块名称 bundle文件下载地址 文件校验安全码 版本号 更新机制 插件安全码是否一致 大体思路好像是： 用户进入APP 默认下载一个某个接口的数据到本地 接口中包括模块名称、bundle文件下载地址、文件校验安全码、版本号 当用户再一次进入APP中的时候会再次下载接口中的数据 然后在对比之前的数据是否发生了变化，安全码是否一致 如果不一致，就重新下载一遍，以此实现热更新 拆分bundle 底层框架Bundle 基础RN JS库 三端组件 JS库 业务代码Bundle 纯业务JS 可参考react-native-split 灾备策略当在低版本手机点击时出现崩溃备用方案 低版本的原生跳H5 原生连续崩溃降级至H5 如何支持web端 编译时转译RN API react-native-web node-haste-webpack-plugin 版本控制 入口配置灵活 指定端和版本(可以指定版本打对应的包) 指定人群定向(作用主要用于测试) 小流量 跳转中心 低版本H5 高版本原生 全量包URL 拆分包URL App 外输出H5页面 性能优化 数据上报 三端平台-集成方案三端组件 JS UI组件 为抹平三端差异化的API，基于视觉的规范UI层JS组件 UIButon、UIExplain、UISwipe… JS 业务组件 Fetch、Login… 变色龙三端开发平台文档 三端工具 本地Nodejs脚手架 本地模拟器-Android 本地模拟器-IOS 独立调试IOS APP 本地IDE客户端 链家网前端工程实践分享人：杨永林(链家) 都说了什么]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>FEDAY3</tag>
        <tag>笔记</tag>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RN 中 ES6 书写规范]]></title>
    <url>%2FReactES6%2F</url>
    <content type="text"><![CDATA[前言很多时候我们学会了很多东西,但是不知道 怎么用、如何用、在哪用这时这篇文章就显得 很有用 了。参考依照：ES5 ES6写法对照表 模块引用import &#123; Image, Text&#125; from 'react-native' 导出单个类/* 导出 */export default class MyComponent extends Component&#123; ...&#125;/* 引入 */import MyComponent from './MyComponent'; 组件定义组件class Photo extends React.Component &#123; render() &#123; return ( &lt;Image source=&#123;this.props.source&#125; /&gt; ); &#125;&#125; 给组件定义方法class Photo extends React.Component &#123; componentWillMount() &#123; &#125; render() &#123; return ( &lt;Image source=&#123;this.props.source&#125; /&gt; ); &#125;&#125; 定义组件的 属性类型 和 默认属性在ES6里，可以统一使用 static 成员来实现 class Video extends React.Component &#123; static defaultProps = &#123; autoPlay: false, maxLoops: 10, &#125;; // 注意这里有分号 static propTypes = &#123; // 定义 autoPlay必须是 布尔值 autoPlay: React.PropTypes.bool.isRequired, maxLoops: React.PropTypes.number.isRequired, posterFrameSrc: React.PropTypes.string.isRequired, videoSrc: React.PropTypes.string.isRequired, &#125;; // 注意这里有分号 render() &#123; return ( &lt;View /&gt; ); &#125; // 注意这里既没有分号也没有逗号&#125; 初始化 STATE第一种写法：方便、简单 class Video extends React.Component &#123; state = &#123; loopsRemaining: this.props.maxLoops, &#125;&#125; 第二种写法：语法上易理解，可以根据需要做一些计算 class Video extends React.Component &#123; constructor(props)&#123; super(props); this.state = &#123; loopsRemaining: this.props.maxLoops, &#125;; &#125;&#125; 把方法作为 回调在ES6下，需要通过bind来绑定this引用，或者使用箭头函数来调用 class PostInfo extends React.Component&#123; handleOptionsButtonClick(e)&#123; this.setState(&#123;showOptionsModal: true&#125;); &#125; render()&#123; return ( &lt;TouchableHighlight onPress=&#123;this.handleOptionsButtonClick.bind(this)&#125; // bind绑定 onPress=&#123;e=&gt;this.handleOptionsButtonClick(e)&#125; // 箭头函数 &gt; &lt;Text&gt;&#123;this.props.label&#125;&lt;/Text&gt; &lt;/TouchableHighlight&gt; ) &#125;,&#125; 需要注意的是，不论是bind还是箭头函数，每次被执行都返回的是一个新的函数引用，因此如果你还需要函数的引用去做一些别的事情（譬如卸载监听器），那么你必须自己保存这个引用 class PauseMenu extends React.Component&#123; constructor(props)&#123; super(props); this._onAppPaused = this.onAppPaused.bind(this); &#125; componentWillMount()&#123; AppStateIOS.addEventListener('change', this._onAppPaused); &#125; componentDidUnmount()&#123; AppStateIOS.removeEventListener('change', this._onAppPaused); &#125; onAppPaused(event)&#123; &#125;&#125;]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>书写规范</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-native 笔记]]></title>
    <url>%2FReact-native%2F</url>
    <content type="text"><![CDATA[前言 对中文网的的 ReactNative 的内容进行的 提炼 对其中的内容进行了 简化 对一些我个人认为较复杂且不常用的功能或概念 采取忽略 对 ReactNative 不了解 的同学可能会有一点帮助 如笔记整理有错误还请 留言 深度阅读请访问 ReactNative中文网 ReactNative 使用安装运行 ReactNative react-native init AwesomeProject cd AwesomeProject &amp;&amp; react-native run-ios 提示: version参数 可用来指定版本,例如 react-native init MyApp --version 0.44.3。 Hello World/* 引用 React 的默认方法 与 Component 组件 */import React, &#123; Component &#125; from 'react';/* 引用 react-native 的AppRegister 与 Text 组件 */import &#123; AppRegistry, Text &#125; from 'react-native';/* 定义 Hello 组件 并扩展到 react 的 Component 中*/class Hello extends Component &#123; /* JSX 渲染语法 */ render() &#123; return ( &lt;Text&gt;Hello world!&lt;/Text&gt; ); &#125;&#125;/* AppRegistry的内置模块对 Hello组件 进行了“注册”操作,在整个应用里只会用一次 */AppRegistry.registerComponent('Hello', () =&gt; Hello); Props(属性)多数组件在创建时就可使用 props参数 来定制。 Image组件使用 propsimport React, &#123; Component &#125; from 'react';import &#123; AppRegistry, Image &#125; from 'react-native';class Bananas extends Component &#123; render() &#123; let pic = &#123; uri: 'https://upload.wikimedia.org/wikipedia/commons/d/de/Bananavarieties.jpg' &#125;; return ( &lt;Image source=&#123;pic&#125; style=&#123;&#123;width: 193, height: 110&#125;&#125; /&gt; ); &#125;&#125;AppRegistry.registerComponent('Bananas', () =&gt; Bananas); 自定义的组件使用 props State(状态) RN中可通过 props 和 state 来控制一个组件 props 数据是在父组件中指定，仅生效一次 state 数据可根据需求进行改写 constructor 可用来初始化state ,需要改写时调用 setState 方法 文字变换例子 Style(样式) 按照JS的语法要求使用了驼峰命名法 StyleSheet.create 来集中定义组件的样式 import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, StyleSheet, Text, View &#125; from 'react-native';class LotsOfStyles extends Component &#123; render() &#123; return ( &lt;View&gt; &lt;Text style=&#123;styles.red&#125;&gt;just red&lt;/Text&gt; &lt;Text style=&#123;styles.bigblue&#125;&gt;just bigblue&lt;/Text&gt; /* 常见的做法是按顺序使用属性，即后属性会覆盖前属性 */ &lt;Text style=&#123;[styles.bigblue, styles.red]&#125;&gt;bigblue, then red&lt;/Text&gt; &lt;Text style=&#123;[styles.red, styles.bigblue]&#125;&gt;red, then bigblue&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; bigblue: &#123; color: 'blue', fontWeight: 'bold', fontSize: 30, &#125;, red: &#123; color: 'red', &#125;,&#125;);AppRegistry.registerComponent('LotsOfStyles', () =&gt; LotsOfStyles); Flexbox 布局 flexDirection 的默认值是 column 而不是row，而flex也只能指定一个数字值。 Flexbox 主要三属性 flexDirection justifyContent alignItems 居中排列 import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, View &#125; from 'react-native';class AlignItemsBasics extends Component &#123; render() &#123; return ( // 尝试把`alignItems`改为`flex-start`看看 // 尝试把`justifyContent`改为`flex-end`看看 // 尝试把`flexDirection`改为`row`看看 &lt;View style=&#123;&#123; flex: 1, flexDirection: 'row', justifyContent: 'center', alignItems: 'center', &#125;&#125;&gt; &lt;View style=&#123;&#123;width: 50, height: 50, backgroundColor: 'powderblue'&#125;&#125; /&gt; &lt;View style=&#123;&#123;width: 50, height: 50, backgroundColor: 'skyblue'&#125;&#125; /&gt; &lt;View style=&#123;&#123;width: 50, height: 50, backgroundColor: 'steelblue'&#125;&#125; /&gt; &lt;/View&gt; ); &#125;&#125;;AppRegistry.registerComponent('AwesomeProject', () =&gt; AlignItemsBasics); TextInput TextInput 是一个允许用户输入文本的基础组件。 onChangeText 属性接受一个函数，而此函数会在 文本变化时 被调用。 onSubmitEditing 属性，会在 文本被提交后（用户按下软键盘上的提交键）调用。 ScrollView ScrollView 是一个通用的可滚动的容器，其中可放入多个组件和视图，不区分类型,可以 水平滚动 ScrollView 适合用来显示 数量不多 的滚动元素 import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, StyleSheet, Text, View, ScrollView, Image&#125; from 'react-native';export default class testApp extends Component &#123; render() &#123; return( &lt;ScrollView&gt; &lt;Text style=&#123;&#123;fontSize:96&#125;&#125;&gt;Scroll me plz&lt;/Text&gt; &lt;Image source=&#123;require('./src/img/aaa.png')&#125; style=&#123;&#123;height:200,width:200&#125;&#125;/&gt; &lt;Image source=&#123;require('./src/img/aaa.png')&#125; style=&#123;&#123;height:200,width:200&#125;&#125;/&gt; &lt;Image source=&#123;require('./src/img/bbb.jpeg')&#125; style=&#123;&#123;height:200,width:200&#125;&#125;/&gt; &lt;Image source=&#123;require('./src/img/aaa.png')&#125; style=&#123;&#123;height:200,width:200&#125;&#125;/&gt; &lt;Image source=&#123;require('./src/img/aaa.png')&#125; style=&#123;&#123;height:200,width:200&#125;&#125;/&gt; &lt;Text style=&#123;&#123;fontSize:96&#125;&#125;&gt;If you like&lt;/Text&gt; &lt;Image source=&#123;require('./src/img/bbb.jpeg')&#125; style=&#123;&#123;height:200,width:200&#125;&#125;/&gt; &lt;Text style=&#123;&#123;fontSize:80&#125;&#125;&gt;React Native&lt;/Text&gt; &lt;/ScrollView&gt; ); &#125;&#125;AppRegistry.registerComponent('testApp', () =&gt; testApp); ListView RN 中展示长列表数据的常用组件有俩个 FlatList SectionList FlatList 组件 特点 适用展示一组 仅数据不同的垂直滚动列表 适用 长列表数据 且元素的个数可以增删 FlatList 优先渲染屏幕上可见的元素 使用 FlatList 组件 必须 的两个属性是 data 和 renderItem 。 data 是列表的 数据源 renderItem 是从数据源中逐个 解析数据 ，然后返回一个设定好格式的组件来渲染。 import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, StyleSheet, Text, View, ScrollView, Image, FlatList&#125; from 'react-native';export default class testApp extends Component &#123; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;FlatList data=&#123;[ &#123;key: 'Devin'&#125;, &#123;key: 'Jackson'&#125;, &#123;key: 'James'&#125;, &#123;key: 'Joel'&#125;, &#123;key: 'John'&#125;, &#123;key: 'Jillian'&#125;, &#123;key: 'Jimmy'&#125;, &#123;key: 'Julie'&#125;, &#123;key: 'Julie'&#125;, &#123;key: '白晓健'&#125;, &#123;key: '白晓建'&#125;, &#123;key: '白晓见'&#125;, &#123;key: '白小剑'&#125;, ]&#125; // renderItem 一个对象, 里面有一个箭头函数其参数是一个对象,对象的值时 data 中的 每一项 renderItem=&#123;(&#123;item&#125;) =&gt; &#123; return &lt;Text style=&#123;styles.item&#125;&gt; 你好&#123;item.key&#125; ,welcome &lt;/Text&gt; &#125;&#125; /&gt; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, paddingTop: 22, &#125;, item: &#123; padding: 10, fontSize: 18, height: 44, backgroundColor:'pink' &#125;,&#125;)AppRegistry.registerComponent('testApp', () =&gt; testApp); SectionList如果想提供一组数据分成 逻辑部分 或 章节标题 ，可以使用 SectionList 。 网络请求(fetch)发起网络请求想从地址获取内容,只需将网址作为参数即可 export default class testApp extends Component &#123; state = &#123; movies:[ &#123;key: '白晓健'&#125;, &#123;key: '白晓建'&#125;, &#123;key: '白晓见'&#125;, &#123;key: '白小剑'&#125;, ], &#125;; fatchData=()=&gt;&#123; fetch('https://api.douban.com/v2/movie/in_theaters') // 转换成 Text 是为了当意外发生时,更容易锁定错误 .then((response) =&gt; response.text()) .then((responseText) =&gt; &#123; const json = JSON.parse(responseText); console.log(json) // 重新设置 state 中 movies 的 值,也就是给 movies 赋值 this.setState(&#123;movies:json.subjects&#125;); &#125;) .catch((error) =&gt; &#123; console.error(error); &#125;); &#125; componentDidMount() &#123; this.fatchData() &#125; render() &#123; return ( // const &#123; movies &#125; = this.state; &lt;View style=&#123;styles.container&#125;&gt; &lt;FlatList data=&#123;this.state.movies&#125; // 一个对象 里面有一个 renderItem=&#123;(&#123;item&#125;) =&gt; &#123; return &lt;Text style=&#123;styles.item&#125;&gt; 你好,&#123;item.title&#125; ,welcome &lt;/Text&gt; &#125;&#125; /&gt; &lt;/View&gt; ); &#125;&#125; fetch 的第二个可选参数,可用来定制HTTP请求一些参数 /* 指定header参数，指定使用POST方法，提交数据 */fetch('https://mywebsite.com/endpoint/', &#123; method: 'POST', headers: &#123; 'Accept': 'application/json', 'Content-Type': 'application/json', &#125;, body: JSON.stringify(&#123; firstParam: 'yourValue', secondParam: 'yourOtherValue', &#125;)&#125;) 处理响应数据 网络请求天生就是一种异步操作 Fetch 方法会返回一个 Promise实例 ，其用意是简化异步风格的代码 默认情况下，iOS会 阻止所有非https的请求 ,解决方案 getMoviesFromApiAsync() &#123; return fetch('https://facebook.github.io/react-native/movies.json') .then((response) =&gt; response.json()) .then((responseJson) =&gt; &#123; return responseJson.movies; &#125;) .catch((error) =&gt; &#123; console.error(error); &#125;); &#125; RN 应用中使用 ES7标准中 的async/await 语法： // 注意这个方法前面有async关键字 async getMoviesFromApi() &#123; try &#123; // 注意这里的await语句，其所在的函数必须有async关键字声明 let response = await fetch('https://facebook.github.io/react-native/movies.json'); let responseJson = await response.json(); return responseJson.movies; &#125; catch(error) &#123; /* 别忘了catch住fetch可能抛出的异常，否则出错时你可能看不到任何提示。 */ console.error(error); &#125; &#125; 使用其他的网络库 RN 中已经内置了 XMLHttpRequest 也就是 ajax 基于 XMLHttpRequest 封装的第三方库有 frisbee 或是 axios 等 没有跨域限制 WebSocketRN 支持 WebSocket，这种协议可以在单个 TCP 连接上提供 全双工 的通信信道 深度阅读 使用导航器跳转页面从0.44版本开始， Navigator 被从react native的核心组件库中 抽离 到了一个名为 react-native-deprecated-custom-components 的单独模块中。如果需要继续使用 Navigator ，则需要先 yarn add react-native-deprecated-custom-components 安装，然后从这个模块中 import，即 import { Navigator } from &#39;react-native-deprecated-custom-components&#39; . React Navigation社区今后主推的方案是一个 单独 的导航库 react-navigation ，它的使用十分简单。 详细了解 首先是在当前应用中安装此库 yarn add react-navigation 基本例子 import React from 'react';import &#123; AppRegistry, Text, View, Button&#125; from 'react-native';import &#123; StackNavigator &#125; from 'react-navigation';/* 导入组件 */import Detail from './src/components/Detail';import ChatScreen from './src/components/Chat';import TestScreen from './src/components/Test';class HomeScreen extends React.Component &#123; /* 定义本页面的导航栏设置*/ static navigationOptions = &#123; /* 定义标题,此标题也是跳入其他页面时返回键上的信息 */ title: 'Welcome', &#125;; render() &#123; /* 使标题生效 */ const &#123; navigate &#125; = this.props.navigation; return ( &lt;View&gt; &lt;Text&gt;Hello, Chat App!&lt;/Text&gt; &lt;Button /* 设置文本点击事件,进入指定组件 */ onPress=&#123;() =&gt; navigate('Chat')&#125; title="Chat with Lucy" /&gt; &lt;/View&gt; ); &#125;&#125;/* 在根文件中用 StackNavigator 声明这些组件(类似于定义路由),键就是 路由名称 */const testApp = StackNavigator(&#123; Home: &#123; screen: HomeScreen &#125;, aaa: &#123; screen: Detail &#125;, Chat: &#123; screen: ChatScreen &#125;, Test: &#123; screen: TestScreen &#125;,&#125;);AppRegistry.registerComponent('testApp', () =&gt; testApp); 图片静态图片资源引用方式// 正确&lt;Image source=&#123;require('./my-icon.png')&#125; /&gt;// 错误var icon = this.props.active ? 'my-icon-active' : 'my-icon-inactive';&lt;Image source=&#123;require('./' + icon + '.png')&#125; /&gt;// 正确var icon = this.props.active ? require('./my-icon-active.png') : require('./my-icon-inactive.png');&lt;Image source=&#123;icon&#125; /&gt; 注意:require中的图片名字必须是一个静态字符串, 不能使用变量 ！ 静态非图片资源require 语法也可以用来静态地加载你项目中的声音、视频或者文档等文件。 注意: 视频必须指定尺寸 而不能使用flex样式. 网络图片// 正确&lt;Image source=&#123;&#123;uri: 'https://facebook.github.io/react/img/logo_og.png'&#125;&#125; style=&#123;&#123;width: 400, height: 400&#125;&#125; /&gt;// 错误&lt;Image source=&#123;&#123;uri: 'https://facebook.github.io/react/img/logo_og.png'&#125;&#125; /&gt; 可携带参数 &lt;Image source=&#123;&#123; uri: 'https://facebook.github.io/react/img/logo_og.png', method: 'POST', headers: &#123; Pragma: 'no-cache' &#125;, body: 'Your Body goes here'&#125;&#125;style=&#123;&#123;width: 400, height: 400&#125;&#125; /&gt; 背景图片组件开发者们常面对的一种需求就是类似web中的背景图（background-image）。要实现这一用例，只需简单使用组件，然后把需要背景图的子组件嵌入其中即可。 return ( &lt;ImageBackground source=&#123;...&#125;&gt; &lt;Text&gt;Inside&lt;/Text&gt; &lt;/ImageBackground&gt;); 处理触摸事件点击事件class MyButton extends Component &#123; _onPressButton() &#123; console.log("You tapped the button!"); &#125; render() &#123; return ( &lt;TouchableHighlight onPress=&#123;this._onPressButton&#125;&gt; &lt;Text&gt;Button&lt;/Text&gt; &lt;/TouchableHighlight&gt; ); &#125;&#125; 具体使用哪种组件，取决于希望给用户什么样的视觉反馈： TouchableHighlight:来制作按钮或者链接。用户手指按下时 背景变暗 TouchableNativeFeedback:用户手指按下时形成类似 墨水涟漪 的视觉效果(限Android) TouchableOpacity:会在用户手指按下时 降低透明度 TouchableWithoutFeedback:点击事件的时 无效果 某些场景中你可能需要检测用户是否进行了 长按操作 。可以在上面列出的任意组件中使用 onLongPress 属性来实现。 列表滑动 ScrollView 可实现用户会在列表中或快或慢的 各种滑动 还可以配置 pagingEnabled 属性来让用户 整屏滑动 水平方向的滑动还可以使用Android上的 ViewPagerAndroid 组件。 ListView 是一种特殊的ScrollView，用于显示 较长垂直列表 动画 RN 提供了两个互补的动画系统： 用于 全局 的布局动画 LayoutAnimation 用于创建更 精细 的交互控制的动画 Animated 深度阅读 定时器RN 实现了和浏览器一致的定时器 Timer 。 定时器 setTimeout, clearTimeout setInterval, clearInterval setImmediate, clearImmediate requestAnimationFrame, cancelAnimationFrame setImmediate 和 setTimeout 有略微不同.requestAnimationFrame 和 setInterval 有略微不同. 详细阅读 注意: 卸载组件前务必清除定时器 直接操作在 RN 中， setNativeProps 就是等价于直接在底层操作DOM节点的方法。 注意: 在使用 setNativeProps 之前,先尝试用 setState 或 shouldComponentUpdate 方法来解决问题 ReactNative 问题端口占用当运行时提示 “Packager can’t listen on port 8081” ，说明 8081 端口被占用 第一种 检查占用端口的程序并关闭 第二种 启动服务时指定端口号 react-native start --port 8083 手动修改项目下的 node_modules/react-native/local-cli/server/server.js 中的 port 字段]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-redux 笔记]]></title>
    <url>%2FReact-redux%2F</url>
    <content type="text"><![CDATA[未完待续简介如果你的应用有以下场景，可以考虑使用 Redux。 某个组件的状态 需要共享 某个状态需要在 任何地方 都可以获取 一个组件想要 改变全局状态 一个组件想要 改变另一个组件状态 核心思想 web 应用是一个 状态机 ，视图与状态是 相对应 的,并且 所有的状态都保存在一个对象里。 基本概念和 APIStore Store 就是保存数据的地方，你可以把它看成一个容器。 整个应用只能有一个 Store。 import &#123; createStore &#125; from 'redux';const store = createStore(reducer);/* createStore函数接受另一个函数作为参数，返回新生成的 Store 对象。 */ State Store对象包含所有数据。 store.getState() 可获得当前 State import &#123; createStore &#125; from 'redux';const store = createStore(reducer);const state = store.getState();/* * Redux 规定， 一个 State 对应一个 View。 * 只要 State 相同，View 就相同。 * 你知道 State，就知道 View 是什么样，反之亦然。 */ Action Action 只是一个对象 Action 可改变 State, 其变化会同步到 View type属性必须 ，表示 Action 的名称,其他属性随意 const action = &#123; type: 'ADD_TODO', payload: 'Learn Redux'&#125;; Action CreatorView 要发送多少种消息，就会有多少种 Action。如果都手写，会很麻烦。可以定义一个函数来生成 Action，这个函数就叫 Action Creator。 const ADD_TODO = '添加 TODO';function addTodo(text) &#123; return &#123; type: ADD_TODO, text &#125;&#125;const action = addTodo('Learn Redux');/* addTodo函数就是一个 Action Creator。 */ store.dispatch()store.dispatch()是 View 发出 Action 的唯一方法。 import &#123; createStore &#125; from 'redux';const store = createStore(reducer);/* store.dispatch接受一个 Action 对象作为参数，将它发送出去。*/store.dispatch(&#123; type: 'ADD_TODO', payload: 'Learn Redux'&#125;);/* 结合 Action Creator，这段代码可以改写如下。 */store.dispatch(addTodo('Learn Redux')); Reducer Reducer 是一个函数 接受 当前State 和 Action 作为参数并返回新的 State const chatReducer = (state = defaultState, action = &#123;&#125;) =&gt; &#123; const &#123; type, payload &#125; = action; switch (type) &#123; case ADD_CHAT: return Object.assign(&#123;&#125;, state, &#123; chatLog: state.chatLog.concat(payload) &#125;); case CHANGE_STATUS: return Object.assign(&#123;&#125;, state, &#123; statusMessage: payload &#125;); case CHANGE_USERNAME: return Object.assign(&#123;&#125;, state, &#123; userName: payload &#125;); default: return state; &#125;&#125;; store.subscribe() store.subscribe 方法是用来设置监听函数，一旦 State 发生变化，就自动执行这个函数。 import &#123; createStore &#125; from 'redux';const store = createStore(reducer);/** * 把 View 的更新函数（对于 React 项目，就是组件的render方法或setState方法）放入listen，就会实现 View 的自动渲染。 */let unsubscribe = store.subscribe(listener);/* store.subscribe 方法返回一个函数，调用该函数就可以 解除监听 。 */unsubscribe(); 流程步骤 首先需要在 reducer 函数内,定义 type 值和默认值对应的操作 把 reducer 函数放到 storeCreate(reducer) 进行初始化 ,初始化时 返回的是 reducer 函数内的默认值 通过 store.dispatch({type:’xxx’,value:123}) 来发送 Action 数据格式,以此来触发 reducer 函数,并更新 state 当前值 在通过 store.subscribe 检测 State 的变化,以此来更新 View]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 笔记]]></title>
    <url>%2FReact%2F</url>
    <content type="text"><![CDATA[注意点 注意区分大小写 单标签后面一定要有 / 闭合符 ReactDOM.render() React 的最基本方法，用于 将模板转为 HTML 语言，并插入到指定的 DOM 节点。 JSX 语法 JSX 的基本语法规则： 遇到 HTML 标签（以 &lt; 开头），就用 HTML 规则解析； 遇到代码块（以 { 开头），就用 JavaScript 规则解析; JSX 允许直接在模板插入 JS 变量 {x}。 如果这个变量是一个数组，则会展开这个数组的所有成员 组件React 允许将代码封装成组件（component），然后像插入普通 HTML 标签一样，在网页中插入这个组件。 组建类的第一个字母必须大写,否则会报错 组件类只能包含一个顶层标签,否则也会报错 组件可以任意加属性 比如 &lt;HelloMessage name=&quot;John&quot;&gt; 组件的属性可以在组件类的 this.props对象上获取 比如 this.props.John 添加组件属性，保留字需要注意就是 class 属性需要写成 className for 属性需要写成 htmlFor this.props.children this.props 对象的属性与组件的属性一一对应. this.props.children 属性,表示组件的所有子节点 React.Children.map 是专门来遍历 this.props.children 的一个方法 PropTypes 组件的属性可以接受任意值，字符串、对象、函数等等都可以。 有时，我们需要一种机制，验证别人使用组件时，提供的参数是否符合要求。 getDefaultProps 方法可以用来设置组件属性的默认值。 获取真实的DOM节点 组件是存在于内存之中的一种数据结构，叫做虚拟(virtual) DOM,只有当它插入文档以后，才会变成真实的 DOM 。 React 中所有的 DOM 变动之前都先在虚拟 DOM 上发生，然后再将 实际发生变动 的部分，反映在真实DOM上，这种算法叫做 DOM diff ，它可以极大提高网页的性能表现。 但是，有时需要从组件获取真实 DOM 的节点，这时就要用到 ref 属性. var MyComponent = React.createClass(&#123; handleClick: function() &#123; this.refs.myTextInput.focus(); &#125;, render: function() &#123; return ( &lt;div&gt; &lt;input type="text" ref="myTextInput" /&gt; &lt;input type="button" value="Focus the text input" onClick=&#123;this.handleClick&#125; /&gt; &lt;/div&gt; ); &#125;&#125;);ReactDOM.render( &lt;MyComponent /&gt;, document.getElementById('example')); 组件 MyComponent 的子节点有一个文本输入框，用于获取用户的输入。 这时就必须获取真实的 DOM 节点，虚拟 DOM 是拿不到用户输入的。 为了做到这一点，文本输入框 必须有一个 ref 属性，然后 this.refs.[refName] 就会返回这个真实的 DOM 节点。 由于 this.refs.[refName] 属性获取的是 真实 DOM ，所以必须等到虚拟 DOM 插入文档以后，才能使用这个属性，否则会报错。 上面代码中，通过为组件指定 Click 事件的回调函数，确保了只有等到真实 DOM 发生 Click 事件之后，才会读取 this.refs.[refName] 属性。 this.stateReact 中将组件看成是一个状态机，开始有一个初始状态，然后用户互动，导致状态变化，从而触发重新渲染 UI var LikeButton = React.createClass(&#123; getInitialState: function() &#123; return &#123;liked: false&#125;; &#125;, handleClick: function(event) &#123; this.setState(&#123;liked: !this.state.liked&#125;); &#125;, render: function() &#123; var text = this.state.liked ? 'like' : 'haven\'t liked'; return ( &lt;p onClick=&#123;this.handleClick&#125;&gt; You &#123;text&#125; this. Click to toggle. &lt;/p&gt; ); &#125;&#125;);ReactDOM.render( &lt;LikeButton /&gt;, document.getElementById('example')); LikeButton 组件中的 getInitialState 方法用于定义初始状态，也就是一个对象，这个对象可以通过 this.state 属性读取。 当用户点击组件，导致状态变化，this.setState 方法就修改状态值，每次修改以后，自动调用 this.render 方法，再次渲染组件。 由于 this.props 和 this.state 都用于描述组件的特性，可能会产生混淆。 this.props 表示那些一旦定义，就不再改变的特性 this.state 是会随着用户互动而产生变化的特性 表单类似于双向数据绑定 var Input = React.createClass(&#123; getInitialState: function() &#123; return &#123;value: 'Hello!'&#125;; &#125;, handleChange: function(event) &#123; this.setState(&#123;value: event.target.value&#125;); &#125;, render: function () &#123; var value = this.state.value; return ( &lt;div&gt; &lt;input type="text" value=&#123;value&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;p&gt;&#123;value&#125;&lt;/p&gt; &lt;/div&gt; ); &#125;&#125;);ReactDOM.render(&lt;Input/&gt;, document.body); 文本输入框的值，不能用 this.props.value 读取，而要定义一个 onChange 事件的回调函数，通过 event.target.value 读取用户输入的值。 组建的生命周期 组件周期的三个状态 Mounting：已插入真实 DOM Updating：正在被重新渲染 Unmounting：已移出真实 DOM React 为每个状态都提供了两种处理函数，will 函数在进入状态之前调用，did 函数在进入状态之后调用 componentWillMount() componentDidMount() componentWillUpdate(object nextProps, object nextState) componentDidUpdate(object prevProps, object prevState) componentWillUnmount() 此外，React 还提供两种特殊状态的处理函数。 componentWillReceiveProps(object nextProps)：已加载组件收到新的参数时调用 shouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用 参考自:阮一峰入门实例教程]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 笔记]]></title>
    <url>%2FHexo%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[基本操作常用命令 命令 说明 hexo n “我的博客” hexo new “我的博客” #新建文章 hexo p hexo publish hexo g hexo generate#生成 hexo s hexo server #启动服务预览 hexo d hexo deploy#部署 hexo d #部署 #可与hexo g合并为 hexo d -g 服务器 命令 说明 hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器 hexo server -s #静态模式 hexo server -p 5000 #更改端口 hexo server -i 192.168.1.1 #自定义 IP hexo clean #清除缓存 网页正常情况下可以忽略此条命令 完成后部署 命令 说明 hexo g #生成静态网页 hexo d #开始部署 模版 命令 说明 hexo new “postName” #新建文章 hexo new page “pageName” #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server） hexo deploy #将.deploy目录部署到GitHub 写作 变量 描述 :title 标题 :year 建立的年份（4 位数） :month 建立的月份（2 位数） :i_month 建立的月份（去掉开头的零） :day 建立的日期（2 位数） :i_day 建立的日期（去掉开头的零） 示例： title: 搭建个人博客layout: postdate: 2020-01-01 12:00:00comments: truecategories: Blogtags: [Hexo]words: Hexo, Blogdescription: 搭建个人博客还是要用 Hexo 书写语法自定义图片大小标准：&#123;% img [class names] /path/image [width] [height] [title text [alt text]] %&#125;例如：&#123;% img /imgs/baiyan.jpg 100 50 %&#125; 突破容器宽度限制的图片的三种方式当使用此标签引用图片时，图片将自动扩大 26%，并突破文章容器的宽度。 此标签使用于需要突出显示的图片, 图片的扩大与容器的偏差从视觉上 提升图片的吸引力 。 &lt;img src=&quot;/image-url&quot; class=&quot;full-image&quot; /&gt;&#123;% fullimage /image-url, alt, title %&#125;&#123;% fi /image-url, alt, title %&#125; Bootstrap Callout&#123;% note class_name %&#125; Content (md partial supported) &#123;% endnote %&#125; 其中，class_name 可以是以下列表中的一个值： default 默认 primary 提示 success 成功 info 提示 warning 警告 danger 危险 从书中引用新：DevDocs现在附带语法高亮。http://devdocs.io @DevDocstwitter.com/devdocs/status/356095192085962752 文本居中的引用3中方式&lt;blockquote class=&quot;blockquote-center&quot;&gt;blah blah blah&lt;/blockquote&gt;&#123;% centerquote %&#125;blah blah blah&#123;% endcenterquote %&#125;&#123;% cq %&#125;人一切的痛苦，本质上都是对自己的无能的愤怒&#123;% endcq %&#125; 推荐]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 笔记]]></title>
    <url>%2Fes6%2F</url>
    <content type="text"><![CDATA[前言 对阮一峰的ES6的内容进行的 提炼 对其中的内容进行了 简化 对一些我个人认为较复杂且不常用的功能或概念 采取忽略 对ES6 不熟悉 的同学 可能会有一点帮助 如笔记整理有错误还请留言 指出 深度阅读请访问 http://es6.ruanyifeng.com let 与 const代码块：外层作用域无法读取内层作用域中的变量 共同点 只在块级作用域中有效 暂时性死区 不允许重复声明 不存在变量提升 不同点 const 声明时 必须赋值 并且 值不可变 关于解析赋值数组的数组的元素是按 次序排列 的，变量的取值要与位置匹配 典型例子 let [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4]let [x, y, ...z] = ['a'];x // "a"y // undefinedz // []let [a, [b], d] = [1, [2, 3], 4];a // 1b // 2d // 4 设置默认值 ：解构赋值允许指定默认值。 let [x, y = 'b'] = ['a']; // x='a', y='b'let [x, y = 'b'] = ['a', undefined]; // x='a', y='b'-------------------------------------------function f() &#123; console.log('aaa');&#125;// 函数 f 没有执行，因为 x 的值是 1 不属于 undefinedlet [x = f()] = [1]; 对象的对象的属性虽没有次序，但变量必须与属性同名 典型例子 let &#123; bar, foo &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;foo // "aaa"bar // "bbb"let &#123; baz &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;baz // undefined-------------------------------------------/* 如果变量名与属性名不一致，必须写成下面这样。*//***********注意:对于let和const来说，变量不能重新声明，所以一旦赋值的变量以前声明过，就会报错。************/let obj = &#123; first: 'hello', last: 'world' &#125;;let &#123; first: f, last: l &#125; = obj;f // 'hello'l // 'world'-------------------------------------------/***********下面代码中，let命令下面一行的圆括号是必须的，否则会报错。因为解析器会将起首的大括号，理解成一个代码块，而不是赋值语句。************/let foo;(&#123;foo&#125; = &#123;foo: 1&#125;); // 成功let baz;(&#123;bar: baz&#125; = &#123;bar: 1&#125;); // 成功 设置默认值 ：解构赋值允许指定默认值。 var &#123;x = 3&#125; = &#123;&#125;;x // 3var &#123;x, y = 5&#125; = &#123;x: 1&#125;;x // 1y // 5var &#123;x:y = 3&#125; = &#123;&#125;;y // 3var &#123;x:y = 3&#125; = &#123;x: 5&#125;;y // 5var &#123; message: msg = 'Something went wrong' &#125; = &#123;&#125;;msg // "Something went wrong" 函数的 经典范例 /* 函数move的参数是一个对象，如果通过解构，得不到变量x或y的值，那么x和y等于默认值。*/function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, 0]. 因为 x 有值 就会赋值 ，y 没有值 就是默认值move(&#123;&#125;); // [0, 0]move(); // [0, 0]-------------------------------------------/* undefined就会触发函数参数的默认值。 */[1, undefined, 3].map((x = 'yes') =&gt; x);// [ 1, 'yes', 3 ] 基本用途交换变量的值 上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。 let x = 1;let y = 2;[x, y] = [y, x]; 从函数返回多个值 函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。 // 返回一个数组function example() &#123; return [1, 2, 3];&#125;let [a, b, c] = example();// 返回一个对象function example() &#123; return &#123; foo: 1, bar: 2 &#125;;&#125;let &#123; foo, bar &#125; = example(); 函数参数的定义 解构赋值可以方便地将一组参数与变量名对应起来。 // 参数是一组有次序的值function f([x, y, z]) &#123; ... &#125;f([1, 2, 3]);// 参数是一组无次序的值function f(&#123;x, y, z&#125;) &#123; ... &#125;f(&#123;z: 3, y: 2, x: 1&#125;); 提取JSON数据 解构赋值对提取JSON对象中的数据，尤其有用。 let jsonData = &#123; id: 42, status: "OK", data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 42, "OK", [867, 5309] 函数参数的默认值 指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || ‘default foo’;这样的语句。 jQuery.ajax = function (url, &#123; async = true, beforeSend = function () &#123;&#125;, cache = true, complete = function () &#123;&#125;, crossDomain = false, global = true, // ... more config&#125;) &#123; // ... do stuff&#125;; 遍历Map结构 ap结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就非常方便。 var map = new Map();map.set('first', 'hello');map.set('second', 'world');for (let [key, value] of map) &#123; console.log(key + " is " + value);&#125;// first is hello// second is world-------------------------------------------/* 如果只想获取键名，或者只想获取键值，可以写成下面这样。 */// 获取键名for (let [key] of map) &#123; // ...&#125;// 获取键值for (let [,value] of map) &#123; // ...&#125; 输入模块的指定方法 加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。 const &#123; SourceMapConsumer, SourceNode &#125; = require("source-map"); 关于类型的扩展字符串扩展–模板字符串// 普通字符串输出： '\n' 换行，trim（） 消除字符前后空格` In JavaScript '\n' is a line-feed. `.trim()// 字符串中嵌入变量 : `$&#123;&#125;`var name = "Bob";`Hello $&#123;name&#125;,`// 大括号内部可以进行运算var x = 1，y = 2;`$&#123;x + y&#125;`// "3"// 大括号内部可以调用函数function fn() &#123; return "Hello World";&#125;`foo $&#123;fn()&#125; bar`// foo Hello World bar 正则的扩展–后行断言目前，有一个 提案 ，引入后行断言。 /* 先行断言 ,只匹配百分号之前的数字 *//\d+(?=%)/.exec('of US presidents 100% have been male') //["100"]/* 后行断言 ,只匹配百分号之后的数字 *//(?&lt;=\$)\d+/.exec('Benjamin Franklin is on the $100 bill') //["100"] 数值的扩展 方法 作用 Number.isNaN() 判断值是否为NaN，为NaN返回true Number.parseInt()/parseFloat() ES6将这俩个全局方法移植到了Number对象上 Number.isInteger() 判断值是否为整数 Math.trunc() 返回整数部分 Math.sign() 判断一个数是正数、负数、0，对应返回值 +1、-1、0 数组的扩展Array.from(对象，_对象处理函数，_this指向)可将 数组的对象 和 可遍历的对象 转换为数组结构 /* 类似数组的对象 */let arrayLike = &#123; '0': 'a', '1': 'b', '2': 'c', length: 3&#125;;let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']/******************************************************//* 可遍历的对象 */let namesSet = new Set(['a', 'b']) // nameSet &#123;'a','b'&#125;Array.from(namesSet) // ['a', 'b'] Array.of()将一组值转换为数组 Array.of(3, 11, 8) // [3,11,8]Array.of(3) // [3]Array.of(3,2).length // 2 find()、findIndex()、includes() find 方法，用于找出 第一个 符合条件的数组中的值，否则返回 undefined findIndex 返回 第一个 符合条件的位置，否则返回-1。 includes() 和 indexOf() 很像，前者返回布尔值后者返回数值 [1, 4, -5, 10].find((n) =&gt; n &lt; 0)// -5[1, 5, 10, 15].findIndex(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 2 数组的遍历entries() 、keys()、values() for (let index of ['a', 'b'].keys()) &#123; console.log(index);&#125;// 0// 1for (let elem of ['a', 'b'].values()) &#123; console.log(elem);&#125;// 'a'// 'b'for (let [index, elem] of ['a', 'b'].entries()) &#123; console.log(index, elem);&#125;// 0 "a"// 1 "b" 函数的扩展函数参数的默认值 函数内部是不可以再次声明形参 函数的执行时形参会形成作用域 函数体内&gt;形参内&gt;全局内 /* 如实例化时x、y没有传入参数，那么x、y的默认值就是 0 */function Point(x = 0, y = 0) &#123; this.x = x; this.y = y; //&#125;var p = new Point();p // &#123; x: 0, y: 0 &#125;/* 调用时不传参数会报错 */function foo(&#123;x, y = 5&#125;) &#123; console.log(x, y);&#125;foo(&#123;&#125;) // undefined, 5 , 因为只传了一个空对象，y有默认值 x等同于声明了未定义，即undefinedfoo() // 报错. 因为没有传参数， 那么形参的声明的默认值就不会正确执行，即报错/* 调用时不传参数不会报错 */function foo(&#123;x, y = 5&#125; = &#123;&#125;) &#123; console.log(x, y);&#125;foo() // undefined, 5 这样就不会报错了 rest 形参 rest 只能在形参中的最后一位 函数的length属性不包括 rest 函数 function mypush(array, ...items) &#123; items.forEach(item=&gt;&#123; array.push(item); &#125;);&#125;var a = [];mypush(a, 1, 2, 3); // a = [1,2,3]; 扩展运算符的应用小应用/* * 取得最大值 */Math.max(...[14, 3, 77])/* * 将一个数组添加到另一个数组的尾部 */var arr1 = [0, 1, 2], arr2 = [3, 4, 5];arr1.push(...arr2);/* * 生成指定时间 */new Date(...[2015, 1, 1]);/* * 合并数组 */[...arr1, ...arr2, ...arr3]/* * 与解构赋值结合 */const [first, ...rest] = [1, 2, 3, 4, 5];first //1rest //[2, 3, 4, 5]const [first, ...rest] = [];first //undefinedrest //[]const [first, ...rest] = ["foo"];first //"foo"rest //[]/* * 函数的返回值 * 从数据库取出一行数据，通过扩展运算符，直接将其传入构造函数Date。 */va r dateFields = readDateFields(database);var d = new Date(...dateFields);// 将字符串转为真正的数组[...'hello']// [ "h", "e", "l", "l", "o" ] 实现了 Iterator 接口的对象任何 Iterator 接口的对象，都可以用扩展运算符转为 真正的数组。 var nodeList = document.querySelectorAll('div');var array = [...nodeList];/* * 扩展运算符可以将伪数组nodeList 转换真正的数组， * 原因就在于 NodeList 对象实现了 Iterator 接口。 */let arrayLike = &#123; '0': 'a', '1': 'b', '2': 'c', length: 3&#125;;let arr = [...arrayLike];// 报错/** * arrayLike是一个类似数组的对象，但是没有部署Iterator接口，扩展运算符就会报错。 * 这时，可以改为使用Array.from方法将arrayLike转为真正的数组。 */ Map和Set结构，Generator函数因此只要 具有Iterator接口的对象，都可以使用扩展运算符 let map = new Map([ [1, 'one'], [2, 'two'], [3, 'three'],]);let arr = [...map.keys()]; // [1, 2, 3] Generator函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。 var go = function*()&#123; yield 1; yield 2; yield 3;&#125;;[...go()] // [1, 2, 3] 上面代码中，变量go是一个 Generator 函数，执行后返回的是一个遍历器对象，对这个遍历器对象执行扩展运算符，就会将内部遍历得到的值，转为一个数组。 箭头函数使用注意 箭头函数体内的 this 指向的是 父作用域 不可以当作构造函数 不可以使用 arguments 对象，可以用 rest 参数代替。 不可以使用 yield 命令 基本使用/* 一个形参 */var f = v =&gt; v;/* 多个形参 */var sum = (num1, num2) =&gt; num1 + num2;/* 由于大括号被解释为代码块，所以返回对象时要加上小括号 */var getTempItem = id =&gt; (&#123; id: id, name: "Temp" &#125;);/* 多条语句卸载大括号内 */var sum = (num1, num2) =&gt; &#123; return num1 + num2; &#125;/* 箭头函数与变量解构结合使用 */const full = (&#123; first, last &#125;) =&gt; first + ' ' + last;// 等同于function full(person) &#123; return person.first + ' ' + person.last;&#125; 绑定 this 绑定 this 是用来取代call、apply、bind调用 函数绑定运算符是并排的两个冒号（::） foo::bar; /* 等同于 */ bar.bind(foo);foo::bar(...arguments); /* 等同于 */ bar.apply(foo, arguments);/* 如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。 */var method = obj::obj.foo; /* 等同于 */ var method = ::obj.foo;var log = ::console.log; /* 等同于 */ var log = console.log.bind(console); 尾调用(Tail Call)ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。 尾调用是函数式编程 的一个重要概念，就是指 某个函数 最后一步 以 return 的方式调用另一个函数 /* 尾调用 */function f(x)&#123; return g(x);&#125;/* 函数m和n都属于尾调用，因为它们都是函数f的最后一步操作。*/function f(x) &#123; if (x &gt; 0) &#123; return m(x) &#125; return n(x);&#125; 对于尾调用优化的理解 每函数执行时在内存中形成调用帧（保存调用位置和内部变量等信息），调用帧的释放 取决于该函数是否执行了return ，系统默认会自执行 return， 但前提是需要等待程序执行完毕时，那在这个过程中累积的调用帧无疑加大了内存的开销。所以结尾处以 return 形式调用另一个函数 可以使 调用帧及时释放以减少无用的内存浪费 对象的扩展属性的简洁表示法/* 对象内可以使用变量名 */var foo = 'bar';var baz = &#123;foo&#125;;baz // &#123;foo: "bar"&#125;function f(x, y) &#123;/*内部默认执行了 x = 1,y = 2 ，所以形参也是变量*/ return &#123;x, y&#125;;&#125;f(1, 2) // Object &#123;x: 1, y: 2&#125;/* 对象内方法的简写 */var o = &#123; method() &#123; return "Hello!"; &#125;&#125;; 应用场景场景一 ：对象中直接放一个变量 var birth = '2000/01/01';var Person = &#123; name: '张三', birth, hello() &#123; console.log('我的名字是', this.name); &#125;&#125;;Person.birth // '2000/01/01' 场景二 ：这种写法用于函数的返回值，将会非常方便。 function getPoint() &#123; var x = 1; var y = 10; return &#123;x, y&#125;;&#125;getPoint()// &#123;x:1, y:10&#125; 场景三 ：CommonJS 模块输出变量 ，就非常合适使用简洁写法。 var ms = &#123;&#125;;function getItem (key) &#123; return key in ms ? ms[key] : null;&#125;function setItem (key, value) &#123; ms[key] = value;&#125;function clear () &#123; ms = &#123;&#125;;&#125;module.exports = &#123; getItem, setItem, clear &#125;;// 等同于module.exports = &#123; getItem: getItem, setItem: setItem, clear: clear&#125;; 属性名表达式/* 例子一 */let propKey = 'foo';let obj = &#123; [propKey]: true, ['a' + 'bc']: 123&#125;;obj.foo // trueobj.abc // 123/* 例子二 */var lastWord = 'last word';var a = &#123; 'first word': 'hello', [lastWord]: 'world'&#125;;a['first word'] // "hello"a[lastWord] // "world"a['last word'] // "world" 属性表达式定义方法名let obj = &#123; ['h' + 'ello']() &#123; return 'hi'; &#125;&#125;;obj.hello() // hi/* 属性名表达式与简洁表示法，不能同时使用 */// 报错var foo = 'aaa';var aaa = 'abc';var baz = &#123; [foo] &#125;;// 正确var foo = 'aaa';var baz = &#123; [foo]: 'abc'&#125;;baz.aaa // abc Object.is()比较俩个值是否相等,和 === 类似 . Object.js(1,2) 等同于 1 === 2 Object.assign()Object.assign方法用于合并对象，第一个参数是目标对象 ，后面的参数都是源对象。 var target = &#123; a: 1 &#125;;var source1 = &#123; b: 2 &#125;;var source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target // &#123;a:1, b:2, c:3&#125; 应用场景 为对象添加属性 class Point &#123; constructor(x, y) &#123; Object.assign(this, &#123;x, y&#125;); &#125;&#125;/* 通过Object.assign方法，将x、y属性添加到 Point 类的对象实例中 */ 为对象添加方法 /* *通过 Object.assgin 函数将 aaa、bbb函数 添加到 SomeClass.prototype 原型中。 */Object.assign(SomeClass.prototype, &#123; aaa(arg1, arg2) &#123; ··· &#125;, bbb() &#123; ··· &#125;&#125;);// 等同于下面的写法SomeClass.prototype.aaa = function (arg1, arg2) &#123; ···&#125;;SomeClass.prototype.bbb = function () &#123; ···&#125;; 合并多个对象 const merge = (...sources) =&gt; Object.assign(&#123;&#125;, ...sources); 为属性指定默认值 const DEFAULTS = &#123; logLevel: 0, outputFormat: 'html'&#125;;/* DEFAULTS对象是默认值，options对象是用户提供的参数。 */function processContent(options) &#123; options = Object.assign(&#123;&#125;, DEFAULTS, options); console.log(options); // &#123;logLevel: 0, outputFormat: "html"&#125;&#125; 属性的遍历 方法 作用 for…in 遍历自身的和继承的可枚举属性（不含 Symbol 属性）。 Object.keys(obj) 返回数组，（不含继承的）所有可枚举属性（不含 Symbol 属性）。 Object.getOwnPropertyNames(obj) 返回自身对象的一个数组，不含 Symbol 属性，但是包括不可枚举属性）。 Object.getOwnPropertySymbols(obj) 返回自身对象的一个数组，含所有 Symbol 属性。 Reflect.ownKeys(obj) 返回自身对象的一个数组，不管属性名是 Symbol 或字符串，也不管是否可枚举。 以上的5种方法遍历对象的属性，都遵守同样的属性遍历的次序规则。 首先遍历 为数值的属性，按照 数字排序 。 其次遍历 字符串的属性，按照生成时间排序。 最后遍历 Symbol 值的属性，按照生成时间排序。 Reflect.ownKeys(&#123; [Symbol()]:0, b:0, 10:0, 2:0, a:0 &#125;)// ['2', '10', 'b', 'a', Symbol()] proto 属性 Object.getprototypeOf() == 读取一个对象的原型对象 Object.setprototypeOf() == 设置一个对象的原型对象 Object.keys()/values()/entries()可将对象中所有的 键或值 单独分离进行独立出来 var obj = &#123; foo: 'bar', baz: 42 &#125;;Object.keys(obj) // ["foo", "baz"]Object.values(obj) // ["bar", 42]Object.entries(obj) // [ ["foo", "bar"], ["baz", 42] ] 对象的扩展运算符let &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;;x // 1y // 2z // &#123; a: 3, b: 4 &#125;/*******************************/let obj = &#123; a: &#123; b: 1 &#125; &#125;;let &#123; ...x &#125; = obj;obj.a.b = 2;x.a.b // 2/*******************************/let z = &#123; a: 3, b: 4 &#125;;let n = &#123; ...z &#125;;n // &#123; a: 3, b: 4 &#125;/** * 扩展运算符可以用于合并两个对象。 */let ab = &#123; ...a, ...b &#125;;// 等同于let ab = Object.assign(&#123;&#125;, a, b); 扩展运算符花样操作 let aWithOverrides = &#123; ...a, x: 1, y: 2 &#125;;// 等同于let aWithOverrides = &#123; ...a, ...&#123; x: 1, y: 2 &#125; &#125;;// 等同于let x = 1, y = 2, aWithOverrides = &#123; ...a, x, y &#125;;// 等同于let aWithOverrides = Object.assign(&#123;&#125;, a, &#123; x: 1, y: 2 &#125;); Symbol 为了从根本上解决命名冲突 ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值 目前总共7种分别是: undefined、null、Nubmber、String、Boolean、Object、 Symbol Set 和 Map 数据结构Set基本用法 类似于数组 ，但成员的值 没有重复 的 可接受 任何数组 作为参数进行初始化 Set 本身是一个构造函数，用来生成 Set 数据结构。 const set = new Set([1,1,2,3,4,4]);[...set]// [1, 2, 3, 4] Set 属性 属性 作用 构造函数 Set.prototype.constructor 成员总数 Set.prototype.size Set 方法 操作方法 作用 add(value)： 添加某个值，返回Set结构本身。 delete(value)： 删除某个值，返回一个布尔值，表示删除是否成功。 has(value)： 返回一个布尔值，表示该值是否为Set的成员。 clear()： 清除所有成员，没有返回值。 遍历方法 作用 keys() / values()： 返回键名的遍历器 entries()： 返回键和值，但键和值都一样 forEach()： 使用回调函数遍历每个成员 let set = new Set(['red', 'green', 'blue']);/* set 的默认方法就是 set.values */for (let item of set) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.entries()) &#123; console.log(item);&#125;// ["red", "red"]// ["green", "green"]// ["blue", "blue"]/* forEach对每个成员执行某种操作，没有返回值。 */let set = new Set([1, 2, 3]);set.forEach((value, key) =&gt; console.log(value * 2) )// 2// 4// 6 应用数组去重//方法一let arr = [3, 5, 2, 2, 5, 5];let unique = [...new Set(arr)];// [3, 5, 2]//方法二let arr = Array.from(new Set([1,2,2,3,4]))// [1, 2, 3, 4] 数组的 map 和 filter 方法结合Set轻松实现并、交、差集let a = new Set([1, 2, 3]);let b = new Set([4, 3, 2]);// 并集let union = new Set([...a, ...b]);// Set &#123;1, 2, 3, 4&#125;// 交集let intersect = new Set([...a].filter(x =&gt; b.has(x)));// set &#123;2, 3&#125;// 差集let difference = new Set([...a].filter(x =&gt; !b.has(x)));// Set &#123;1&#125; Map解决对象的键只能是字符串的痛点（null、undefined都可以），Map 结构提供了“值和值”的对应 基本用法/* 注意是 二维数组的方式 [ [],[],[] ]*/const map = new Map([ ['name', '张三'], ['title', 'Author']]);map.set(o, 'content')map.has('name') // truemap.get('name') // "张三"map.size // 3 注意 :Map 结构只会对 有对象引用的 , 才将其视为一个键。 const map = new Map();map.set(['a'], 555);map.get(['a'])// undefined 的原因是 set 时候的 ['a'] 和 get 时候的 ['a'] 在内存地址中不是同一个位置。/*****************************************************/const map = new Map();const k1 = ['a'];const k2 = ['a'];/* 链式写法 */map.set(k1, 111).set(k2, 222);map.get(k1) // 111map.get(k2) // 222/* 因为k1 的值是对象 ，而对象是引用类型储存在堆中， set 和 get 用的 都是一个引用地址，所以就能取到对应的值, k1 和 k2 的值虽然一样但是 存储的引用地址不一样，so 不会冲突 */ 属性和方法属性：size ，返回 Map结构成员总数。 方法： 操作的 作用 set(key,value)： 设置 key 对应的键值,可采用链式写法 get(key)： 读取 key 对应的键值，找不到返回 undefined has(value)： 返回一个布尔值，表示该值是否为 Map 的成员。 delete(value)： 删除某个值，返回一个布尔值，表示删除是否成功。 clear()： 清除所有成员，没有返回值。 遍历的 作用 keys() 返回键名的遍历器 values() 返回键值的遍历器 entries()： （默认）返回键和值的遍历器 forEach()： 遍历map的所有成员 forEach方法还可以接受第二个参数，用来绑定 this。 const reporter = &#123; report: function(key, value) &#123; console.log("Key: %s, Value: %s", key, value); &#125;&#125;;map.forEach(function(value, key, map) &#123; this.report(key, value);&#125;, reporter); 与其他数据结构的互相转换Map 转为数组 直接用扩展运算符就可以很方便的进行转化 const myMap = new Map() .set(true, 7) .set(&#123;foo: 3&#125;, ['abc']);[...myMap]// [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ 'abc' ] ] ] 数组转为 Map 直接将数组传入 Map 构造函数，就可以转化为 Map 。 new Map([ [true, 7], [&#123;foo: 3&#125;, ['abc']]])// Map &#123;// true =&gt; 7,// Object &#123;foo: 3&#125; =&gt; ['abc']// &#125; Map 转为对象 如果所有 Map 的键都是字符串，它可以转为对象。 function strMapToObj(strMap) &#123; let obj = Object.create(null); for (let [k,v] of strMap) &#123; obj[k] = v; &#125; return obj;&#125;const myMap = new Map() .set('yes', true) .set('no', false);strMapToObj(myMap)// &#123; yes: true, no: false &#125; 对象转为 Mapfunction objToStrMap(obj) &#123; let strMap = new Map(); for (let k of Object.keys(obj)) &#123; strMap.set(k, obj[k]); &#125; return strMap;&#125;objToStrMap(&#123;yes: true, no: false&#125;)// Map &#123;"yes" =&gt; true, "no" =&gt; false&#125; Map 转为 JSON Map 转为 JSON 要区分两种情况。一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。 function strMapToJson(strMap) &#123; return JSON.stringify(strMapToObj(strMap));&#125;let myMap = new Map().set('yes', true).set('no', false);strMapToJson(myMap)// '&#123;"yes":true,"no":false&#125;'/************************************************************//* 另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。 */function mapToArrayJson(map) &#123; return JSON.stringify([...map]);&#125;let myMap = new Map().set(true, 7).set(&#123;foo: 3&#125;, ['abc']);mapToArrayJson(myMap)// '[[true,7],[&#123;"foo":3&#125;,["abc"]]]' JSON 转 Map JSON 转为 Map，正常情况下，所有键名都是字符串。 function jsonToStrMap(jsonStr) &#123; return objToStrMap(JSON.parse(jsonStr));&#125;jsonToStrMap('&#123;"yes": true, "no": false&#125;')// Map &#123;'yes' =&gt; true, 'no' =&gt; false&#125; Proxy （代理）详细介绍 在目标对象之前设置了一个中间人，外界访问该对象时都必须先通过这个中间人，这种机制就可以对外界的访问进行过滤和改写 ES6 原声提供 Proxy 构造函数，用来生成 proxy 实例。 var proxy = new Proxy(target, handler); new Proxy(): 表示生成一个 Proxy实例 target : 参数表示所要 拦截的目标对象 handler: 参数也是一个对象，用来 定制拦截行为。 应用场景Proxy 对象可以拦截目标对象的任意属性，这使得它很合适用来写 Web 服务的客户端。 /* 新建了一个 Web 服务的接口，这个接口返回各种数据。*/const service = createWebService('http://example.com/data');service.employees().then(json =&gt; &#123; const employees = JSON.parse(json); // ···&#125;);/***********************************************//*Proxy 可以拦截这个对象的任意属性，所以不用为每一种数据写一个适配方法，只要写一个 Proxy 拦截就可以了。*/function createWebService(baseUrl) &#123; return new Proxy(&#123;&#125;, &#123; get(target, propKey, receiver) &#123; return () =&gt; httpGet(baseUrl+'/' + propKey); &#125; &#125;);&#125; Promise（承诺） 对象了解 Promise Promise 是异步编程的一种解决方案 Promise 是一个保存着一个未来才会结束的事件 Promise 的俩个特点 只有异步操作的 结果，才能决定当前是哪一种 状态 Pending（进行中） Resolved（已完成，又称 Fulfilled） Rejected（已失败） 一旦状态改变，就不会再变，任何时候都可以得到这个结果。 状态的改变只有两种可能：从 Pending 变为 Resolved 和 从 Pending 变为 Rejected。 如果某些事件不断地反复发生，一般来说，使用 Stream 模式是比部署Promise更好的选择。 基本操作ES6 规定，Promise对象是一个 构造函数 ，用来生成Promise实例。 Promise构造函数 接受一个函数作为参数，该函数的两个参数也是函数分别是resolve和reject。 resolve 函数： 在异步操作成功时调用，并将异步操作的结果，作为参数传递出去； reject 函数：在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 /* 生成 promise 实例 */var promise = new Promise(function(resolve, reject) &#123; // ... some code if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;);/** * Promise实例生成以后，可以用then方法 分别指定Resolved状态 和 Reject状态的回调函数。 */promise.then(function(value) &#123; // 成功时&#125;, function(error) &#123; // 失败时 （该函数可选）&#125;); 一个 Promise 对象的简单例子 一个用Promise对象实现的 Ajax 操作的例子 Promise.prototype.then() then方法是定义在原型对象Promise.prototype上的 then(Resolved状态回调函数,Rejected 状态的回调函数) then方法返回的是一个 新的 Promise实例,因此可以采用链式写法，即then方法后面再调用另一个then方法。 Promise.prototype.catch()Promise.prototype.catch 方法是 .then(null, rejection)的别名，用于 指定发生错误时的回调函数。 p.then((val) =&gt; console.log('fulfilled:', val)) .catch((err) =&gt; console.log('rejected', err));// 等同于p.then((val) =&gt; console.log('fulfilled:', val)) .then(null, (err) =&gt; console.log("rejected:", err)); 例子 var promise = new Promise(function(resolve, reject) &#123; throw new Error('test');&#125;);promise.catch(function(error) &#123; console.log(error);&#125;);/* promise抛出一个错误，就被catch方法指定的回调函数捕获。 */// Error: test 俩种捕捉错误的方法 // badpromise .then(function(data) &#123; // success &#125;, function(err) &#123; // error &#125;);// goodpromise .then(function(data) &#123; //cb // success &#125;) .catch(function(err) &#123; // error &#125;); 其他深度阅读 Promise.all()Promise.all用于将多个 Promise 实例，包装成一个新的 Promise 实例。 Promise.resolve()有时需要将现有对象转为Promise对象，Promise.resolve 方法就起到这个作用。 Promise.reject()也会返回一个新的 Promise 实例，该实例的状态为 rejected。 Iterator 和 for…of循环Iterator 概念 ES6中有四种数据集合分别是：数组、对象(没有Iterator接口)、Map、Set 用户如果想组合使用这些数据，就需要一种统一的接口机制，来处理所有不同的数据结构。 遍历器（Iterator）就是为各种不同的数据结构 提供统一的访问机制的接口 。 任何数据结构只要部署Iterator接口 ，就可以完成遍历操作。 Iterator的三个作用 为各种数据结构，提供一个统一访问接口 ； 使得数据结构的成员能够按 某种次序排列 ； Iterator接口主要 配合for...of 。 默认的 Iterator 接口 默认的Iterator接口 部署在数据结构的 Symbol.iterator属性 也就是，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”。 Symbol.iterator就是 默认生成遍历器的函数,执行它就会返回一个遍历器。 原生具备 Iterator 接口的数据结构：Array、Map、Set、String、TypedArray、函数的 arguments 对象 /* 具备原生 Iterator ：Array */let arr = ['a', 'b', 'c'];/*执行它就会返回一个遍历器,根本特征就是具有 next 方法 */let iter = arr[Symbol.iterator]();iter.next() // &#123; value: 'a', done: false &#125;iter.next() // &#123; value: 'b', done: false &#125;iter.next() // &#123; value: 'c', done: false &#125;iter.next() // &#123; value: undefined, done: true &#125; 调用 Iterator 接口的场合/** * 1.解析赋值 */let [first, ...rest] = ['a','b','c'];// first='a'; rest=['b','c'];/** * 2.扩展运算符 */let arr = ['b', 'c'];['a', ...arr, 'd']// ['a', 'b', 'c', 'd']/** * 3. yield* * yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。 */let generator = function* () &#123; yield 1; yield* [2,3,4]; yield 5;&#125;;var iterator = generator();iterator.next() // &#123; value: 1, done: false &#125;iterator.next() // &#123; value: 2, done: false &#125;iterator.next() // &#123; value: 3, done: false &#125;iterator.next() // &#123; value: 4, done: false &#125;iterator.next() // &#123; value: 5, done: false &#125;iterator.next() // &#123; value: undefined, done: true &#125; 遍历器对象的 return(),throw()遍历器对象具有next、_return、_throw方法。 return方法的使用场合是，如果for...of循环提前退出（通常是因为出错，或者有break语句或continue语句），就会调用return方法。 for…of 循环for…of循环 内部调用 的是数据结构的Symbol.iterator方法，所以只要数据结构只要部署了Symbol.iterator属性，就可以用for…of循环遍历它的成员 与其他遍历语法比较 for循环 没有 fo…of 简洁 forEach 无法中途跳出forEach循环，break命令或return命令都不能奏效 for…in 主要是为遍历对象而设计的，不适用于遍历数组 Generator 函数的语法基本概念Generator 函数是 ES6 提供的一种 异步编程解决方案 ，语法行为与传统函数 完全不同 。 Generator 函数有多种理解角度。 从语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。 同时执行 Generator 函数会 返回一个遍历器对象 返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。 Generator 函数形式上的两个特征。 function 与函数名的中间有一个星号； 函数体内部使用yield表达式，定义不同的内部状态（ yield 在英语里的意思就是“产出”）。 yield 表达式由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以 暂停执行的函数,yield表达式就是暂停标志。 遍历器对象的next方法的运行逻辑如下。 遇到yield表达式，暂停并将 紧跟在yield后面的那个 表达式的值 ，作为返回的对象的value属性值。 下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。 如果没有再遇到新的yield表达式，就一直运行到return语句为止，并以对象行使返回return语句后面的表达式的值 如果该函数没有return语句，则返回的对象的value属性值为undefined。 yield 于 return 的区别 yield 函数暂停执行，下一次再从该位置继续向后执行，具备记忆 一个函数里面，只能执行一次return语句，但是可以执行多个yield表达式。 正常函数只能返回一个值，因为只能执行一次return； 函数可以返回一系列的值，因为可以有任意多个yield。 yield表达式如果用在另一个表达式之中，必须放在圆括号里面。 function* demo() &#123; console.log('Hello' + yield); // SyntaxError console.log('Hello' + yield 123); // SyntaxError console.log('Hello' + (yield)); // OK console.log('Hello' + (yield 123)); // OK&#125; next 方法的参数next方法的参数 表示 上一个yield表达式的返回值 /* 简单例子 */ function* f() &#123; for(var i = 0; true; i++) &#123; var reset = yield i; if(reset) &#123; i = -1; &#125; &#125; &#125; var g = f(); g.next() // &#123; value: 0, done: false &#125; g.next() // &#123; value: 1, done: false &#125; /* 当next方法带一个参数true时， 变量reset就被重置为这个参数（即true）， 因此i会等于-1，下一轮循环就会从-1开始递增。 */ g.next(true) // &#123; value: 0, done: false &#125;/* 再看一个通过next方法的参数，向 Generator 函数内部输入值的例子 */ function* dataConsumer() &#123; console.log('Started'); console.log(`1. $&#123;yield&#125;`); console.log(`2. $&#123;yield&#125;`); return 'result'; &#125; let genObj = dataConsumer(); genObj.next(); // Started genObj.next('a') // 1. a genObj.next('b') // 2. b Generator.prototype.throw()Generator 函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。 Generator.prototype.return()Generator函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历Generator函数。 yield* 表达式如果在 Generator 函数内部，调用另一个 Generator 函数，默认情况下是没有效果的。 function* inner() &#123; yield 'hello!';&#125;function* outer2() &#123; yield 'open' yield* inner() yield 'close'&#125;var gen = outer2()gen.next().value // "open"gen.next().value // "hello!"gen.next().value // "close" 作为对象属性的 Generator 函数/* myGeneratorMethod属性前面有一个星号，表示这个属性是一个 Generator 函数。 */ let obj = &#123; * myGeneratorMethod() &#123; // ··· &#125; &#125;;/* 与上面的写法是等价的 */ let obj = &#123; myGeneratorMethod: function* () &#123; // ··· &#125; &#125;; 应用场景 异步操作的同步化表达 控制流管理 部署 Iterator 接口 作为数据结构 Generator 函数的异步应用异步编程对 JavaScript 语言太重要,因为 Javascript 语言的执行环境是 “单线程”的. 详细阅读 async 函数 一句话，它就是 Generator 函数的语法糖 详细阅读 Class 的基本语法ES6 的class写法只是让对象原型的 写法更加清晰 、更接近主流面向对象编程 的语法而已。 深度阅读 Class的继承 Module 的语法概述 历史上，JavaScript 一直没有模块体系，直接导致了对开发大型的、复杂的项目造成了巨大障碍。 ES6 实现了 模块功能 ，而且实现得 相当简单 ，完全可以取代其他规范。 ES6 模块的设计思想是尽量的静态化，使得 编译时 就能 确定 模块的 依赖关系 ，以及输入和输出的变量。 CommonJS 与 ES6 模块的区别 严格模式ES6 的模块自动采用严格模式，不管你有没有在模块头部加上 &quot;use strict&quot; 严格模式主要有以下限制 变量必须声明后再使用 函数的参数不能有同名属性，否则报错 不能使用 with 语句 不能对只读属性赋值，否则报错 不能使用前缀0表示八进制数，否则报错 不能删除不可删除的属性，否则报错 不能删除变量 delete prop，会报错，只能删除属性 delete global[prop] eval 不会在它的外层作用域引入变量 eval 和 arguments 不能被重新赋值 arguments不会自动反映函数参数的变化 不能使用 arguments.callee 不能使用 arguments.caller 禁止 this 指向全局对象 不能使用 fn.caller 和 fn.arguments 获取函数调用的堆栈 增加了保留字（比如 protected 、static 和 interface ） export 命令模块功能主要由两个命令构成：export 命令用于 规定 模块的 对外接口 ，import 命令用于 输入其他模块提供的功能。 输出变量 一个模块就是一个独立的文件，其内部所有变量 外部无法获取。 如果希望外部能够读取模块内部的某个变量，就必须使用 export输出该变量。 // profile.jsexport var firstName = 'Michael';export var lastName = 'Jackson';export var year = 1958;/* 上下写法等同 */// profile.jsvar firstName = 'Michael';var lastName = 'Jackson';var year = 1958;export &#123;firstName, lastName, year&#125;; 输出函数或类 export function multiply(x, y) &#123; return x * y;&#125;;// 输出 multiply 函数 使用as关键字重命名function v1() &#123; ... &#125;function v2() &#123; ... &#125;export &#123; v1 as streamV1, v2 as streamV2, v2 as streamLatestVersion&#125;;/* 使用as关键字，重命名了函数v1和v2的对外接口。重命名后，v2可以用不同的名字输出两次。*/ 特别注意export 规定是: 对外的接口 与 模块内部的变量 建立一一 对应关系 。 import 命令使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。 /** * 1.import命令，用于加载profile.js文件，并从中输入变量。 * 2.import命令接受一对大括号，里面指定要从其他模块导入的变量名。 * 3.大括号里面的变量名，必须与被导入模块（profile.js）对外接口的名称相同。 */// main.jsimport &#123;firstName, lastName, year&#125; from './profile';/* import命令要使用 as 关键字，将输入的变量重命名。*/// import &#123; lastName as surname &#125; from './profile';function setName(element) &#123; element.textContent = firstName + ' ' + lastName;&#125; 知识点 from指定模块文件的位置时可以是相对或绝对路径，.js可以省略 如果只是模块名，不带有路径，那么必须有配置文件，告诉 JS 引擎该模块的位置。 import命令具有提升效果，会提升到整个模块的头部，首先执行。 模块的整体加载整体加载：即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。 /* 模块的整体加载 */import * as circle from './circle';console.log('圆面积：' + circle.area(4));console.log('圆周长：' + circle.circumference(14));/* 上下同等 */import &#123; area, circumference &#125; from './circle';console.log('圆面积：' + area(4));console.log('圆周长：' + circumference(14)); export default 命令为模块指定默认输出// export-default.jsexport default function () &#123; console.log('foo');&#125;/** * 模块文件export-default.js，它的默认输出是一个函数, * 其他模块加载该模块时，import命令可以为该匿名函数指定任意名字，不需要大括号包裹 */// import-default.jsimport customName from './export-default';customName(); // 'foo' 比较默认输出和正常输出// 第一组export default function crc32() &#123; // 输出 // ...&#125;import crc32 from 'crc32'; // 输入/********************************************/// 第二组export function crc32() &#123; // 输出 // ...&#125;;import &#123;crc32&#125; from 'crc32'; // 输入 本质上，export default就是输出一个叫做default的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。 // modules.jsfunction add(x, y) &#123; return x * y;&#125;export &#123;add as default&#125;;// 等同于// export default add;// app.jsimport &#123; default as xxx &#125; from 'modules';// 等同于// import xxx from 'modules'; 有了export default命令，输入模块时就非常直观了，以输入 lodash 模块为例。 /* 将默认方法 赋值到 _*/import _ from 'lodash';/* 同时输入默认方法和其他接口 */import _, &#123; each, each as forEach &#125; from 'lodash';// 对应上面代码的export语句如下。export default function (obj) &#123; // ···&#125;export function each(obj, iterator, context) &#123; // ···&#125;export &#123; each as forEach &#125;; // 暴露出forEach接口，默认指向each接口，即forEach和each指向同一个方法。 export 与 import 的复合写法如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。 /****************************************/// export和import语句可以结合在一起export &#123; foo, bar &#125; from 'my_module';// 等同于import &#123; foo, bar &#125; from 'my_module';export &#123; foo, bar &#125;;/****************************************/// 接口改名export &#123; foo as myFoo &#125; from 'my_module';// 整体输出export * from 'my_module';// 默认接口的写法export &#123; default &#125; from 'foo';/****************************************/// 具名接口改为默认接口的写法export &#123; es6 as default &#125; from './someModule';// 等同于import &#123; es6 &#125; from './someModule';export default es6;/****************************************/// 默认接口也可以改名为具名接口export &#123; default as es6 &#125; from './someModule'; 模块的继承假设有一个circleplus模块，继承了circle模块。 // circleplus.js 输出文件export * from 'circle'; // 表示再输出circle模块的所有属性和方法export var e = 2.71828182846; // 又输出了自定义的e变量和默认方法。export default function(x) &#123; // 输出默认方法 return 'test';&#125;export &#123; area as circleArea &#125; from 'circle'; // 只输出circle模块的area方法，且将其改名为circleArea。//main.js 输入文件import * as math from 'circleplus'; // 加载 circleplus 上所有方法import aaa from 'circleplus'; // 将circleplus的默认方法命名为 aaaconsole.log(aaa()); // test 跨模块常量设置跨模块的常量，或者说一个值要被多个模块共享，可以采用下面的写法。 // constants.js 模块export const A = 1;export const B = 3;export const C = 4;// test1.js 模块import * as constants from './constants';console.log(constants.A); // 1console.log(constants.B); // 3// test2.js 模块import &#123;A, B&#125; from './constants';console.log(A); // 1console.log(B); // 3 如果要使用的常量非常多，可以建一个专门的constants目录，将各种常量写在不同的文件里面，保存在该目录下。 // constants/db.jsexport const db = &#123; url: 'http://my.couchdbserver.local:5984', admin_username: 'admin', admin_password: 'admin password'&#125;;// constants/user.jsexport const users = ['root', 'admin', 'staff', 'ceo'];/******************************************************/// constants/index.jsexport &#123;db&#125; from './db';export &#123;users&#125; from './users';/******************************************************/// 使用的时候，直接加载 出入该模块，会自动加载其中的 index.js 文件// script.jsimport &#123;db, users&#125; from './constants'; import() 只是有一个 提案，建议引入import()函数，完成动态加载。 import()类似于 Node 的require方法，区别主要是前者是异步加载，后者是同步加载。 适用场合 按需加载 条件加载 动态的模块路径 Module 的加载实现浏览器加载传统方法 &lt;!-- 页面内嵌的脚本 --&gt;&lt;script type=&quot;application/javascript&quot;&gt; // module code&lt;/script&gt;&lt;!-- 外部脚本 --&gt;&lt;script type=&quot;application/javascript&quot; src=&quot;path/to/myModule.js&quot;&gt;&lt;/script&gt;&lt;!-- 异步加载的俩种方式 --&gt;&lt;script src=&quot;path/to/myModule.js&quot; defer&gt;&lt;/script&gt; // 等到整个页面正常渲染结束，才会执行&lt;script src=&quot;path/to/myModule.js&quot; async&gt;&lt;/script&gt; // 一旦下载完成，立马执行 加载规则 浏览器加载 ES6 模块，也使用 &lt;script&gt; 标签，但是要加入 type=&quot;module&quot; 属性。 &lt;script type=&quot;module&quot; src=&quot;foo.js&quot;&gt;&lt;/script&gt;浏览器对于带有type=&quot;module&quot; 都是执行 defer属性的异步加载 与Node相关的ES6 编程风格块级作用域 let 完全取代var let 和 const 之间，优先使用 const 字符串静态字符串一律使用 单引号或反引号，不使用双引号 // badconst a = "foobar";const b = 'foo' + a + 'bar';// goodconst a = 'foobar';const b = `foo$&#123;a&#125;bar`;const c = 'foobar'; 解构赋值const arr = [1, 2, 3, 4];// badconst first = arr[0];const second = arr[1];// goodconst [first, second] = arr; 对象 单行定义的对象，最后一个成员 不以逗号结尾。 多行定义的对象，最后一个成员 以逗号结尾。 // badconst a = &#123; k1: v1, k2: v2, &#125;;const b = &#123; k1: v1, k2: v2&#125;;// goodconst a = &#123; k1: v1, k2: v2 &#125;;const b = &#123; k1: v1, k2: v2,&#125;; 数组使用扩展运算符 (…) 拷贝数组 // badconst len = items.length;const itemsCopy = [];let i;for (i = 0; i &lt; len; i++) &#123; itemsCopy[i] = items[i];&#125;// goodconst itemsCopy = [...items]; 使用Array.from方法，将伪数组转为真数组。 const foo = document.querySelectorAll('.foo');const nodes = Array.from(foo); 函数/** * 立即执行函数可以写成箭头函数的形式。 */(() =&gt; &#123; console.log('Welcome to the Internet.');&#125;)();/** * 需要使用函数表达式的场合，尽量用箭头函数代替 */[1, 2, 3].map((x) =&gt; &#123; return x * x;&#125;);// 或者[1, 2, 3].map(x =&gt; x * x);/** * 所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数 */function divide(a, b, &#123; option = false &#125; = &#123;&#125;) &#123;&#125;/** * 使用rest运算符（...）代替 arguments */function concatenateAll(...args) &#123; return args.join('');&#125;/** * 设置形参默认值。 */function handleThings(opts = &#123;&#125;) &#123; // ...&#125; Map 结构 注意区分 Object 和 Map。 如果只是需要key: value的数据结构，使用Map结构。 Class用Class 取代需要 prototype 的操作，因为Class的写法更简洁，更易于理解。 模块 Module 语法是 JS 模块的 标准写法 ，坚持使用这种写法。 使用 import 取代 require。 使用 export 取代 module.exports。 注意事项 如果模块只有一个输出值，才使用export default。 在模块输入中使用通配符，就无法确保有一个默认输出值 模块默认输出一个函数，函数名首字母小写。 模块默认输出一个对象，对象名首字母大写。]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flex]]></title>
    <url>%2Fflex%2F</url>
    <content type="text"><![CDATA[Flex 布局是什么 Flex 是 Flexble Box 的缩写，意为 “弹性布局”，用来为盒状提供最大的灵活性。 任何一个容器都可以指定为 Flex 布局 注意，设为 Flex 布局以后，子元素 的loadt、cleat和vertical-align 将失去作用 &lt;style type="text/css"&gt; .box&#123; display: flex; &#125; .box&#123; /* 行内元素也可以使用 Flex 布局。 */ display: inline-flex; &#125;&lt;/style&gt; # flex-flow简写：这是flex-direction和flex-wrap两个属性的缩写,默认值是row nowrap。 容器的属性主轴方向：flex-direction: 属性值 属性作用 row（默认）； 从左到右 row-reverse； 从右到左 column； 从上到下 column-reverse； 从下到上 flex-wrap：是否换行 属性值 属性作用 nowrap（默认）； 不换行 wrap； 正常换行 wrap-reverse； 返向换行 justify-content：设伸缩项目在相对 主轴 水平上的对齐方式 属性值 属性作用 flex-start（默认）： 左对齐 flex-end： 右对齐 center： 居中 space-between： 首尾对齐，项目之间的间隔相等。 space-around： 每个项目两侧的间隔相等。 align-content:设伸缩项目在相对 主轴 水垂直的对齐方式 属性值 属性作用 flex-start： 上对齐 flex-end： 下对齐 center： 居中 space-between： 首尾对齐，项目之间的间隔相等。 space-around： 每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认）： 每个项目两侧的间隔相等。 align-items：管理伸缩容器侧轴方向的额外空间 属性值 属性作用 flex-start（默认）： 左对齐 flex-end： 右对齐 center： 居中 baseline: 项目的第一行文字的基线对齐。 stretch（默认）： 如果项目未设置高度或设为auto，将占满整个容器的高度。 # 项目的属性 属性作用 属性值说明 order 数值越小，排列越靠前，默认为0。 flex-grow 定义一个Flex项目的扩大比例，默认为0 flex-shrink 定义一个Flex项目的缩小比例，默认为0 flex-basis 定义了Flex项目在分配Flex容器剩余空间之前的一个默认尺寸，类似width align-self：管理伸缩容器侧轴方向的额外空间 属性值 属性作用 auto 自动 flex-start（默认）： 左对齐 flex-end： 右对齐 center： 居中 baseline: 项目的第一行文字的基线对齐。 stretch（默认）： 如果项目未设置高度或设为auto，将占满整个容器的高度。 简写：flex flex是flex-grow，flex-shrink，flex-basis三个属性的缩写。第二个和第三个参数是可选值。默认值是0 1 auto。 建议使用缩写属性。如果flex取值为none，等于0 0 auto。 参考一 参考二]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>flex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node 笔记]]></title>
    <url>%2Fnode%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Node.js 开发环境检查 ~/.profile 或者 ~/.bash_profile 中有没有这样两句 export NVM_DIR="/Users/YOURUSERNAME/.nvm"[ -s "$NVM_DIR/nvm.sh" ] &amp;&amp; . "$NVM_DIR/nvm.sh" # This loads nvm 1. 一个最简单的 express 应用 express 是 Node.js 应用最广泛的 web 框架 express 官网 ，我常常上去看它的 API 需求: 当访问 http://localhost:3000/ 时，输出 你好，世界要点: 新建 express 实例并定义 routes 从而产生输出 // 引入 `express` 模块var express = require('express');// 调用 express 实例，不带参数调用时，会返回一个 express 实例var app = express();// app 本身有很多方法，其中包括最常用的 get、post、put/patch、delete，在这里我们调用其中的 get 方法，为我们的 `/` 路径指定一个 handler 函数。// 这个 handler 函数会接收 req 和 res 两个对象，他们分别是请求的 request 和 response 。// request 中包含了浏览器传来的各种信息，比如 query 啊，body 啊，headers 啊之类的，都可以通过 req 对象访问到。// res 对象，我们一般不从里面取信息，而是通过它来定制我们向浏览器输出的信息，比如 header 信息，比如想要向浏览器输出的内容。这里我们调用了它的 #send 方法，向浏览器输出一个字符串。app.get('/', function (req, res) &#123; res.send('Hello World');&#125;);// 定义好我们 app 的行为之后，让它监听本地的 3000 端口。这里的第二个函数是个回调函数，会在 listen 动作成功后执行，我们这里执行了一个命令行输出操作，告诉我们监听动作已完成。app.listen(3000, function () &#123; console.log('app is listening at port 3000');&#125;); 补充问:node代码监听了3000端口，然后通过访问 http://localhost:3000/ 得到了内容，为什么呢？ 端口端口的作用：通过 端口区分 电脑内不同应用或者进程，从而实现一条 物理网线 同时 链接多个程序 app.listen(3000)，进程就被 打标 ，当电脑接收到的3000端口的网络消息时就会启动对应打标的进程 URLRFC1738 定义的url格式笼统版本&lt;scheme&gt;:&lt;scheme-specific-part&gt;，scheme有我们很熟悉的http、https、ftp，以及著名的ed2k，thunder。 精简版&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/&lt;url-path&gt; scheme=http, host=localhost, port=3000, url-path=/, 再联想对照一下浏览器端window.location对象。著名的localhost，你可以在电脑的hosts文件上找到 2. 学习使用外部模块 需求: 访问 http://localhost:3000/?q=alsotang 时，输出 alsotang 的 sha1 值，即 e3c766d71667567e18f77869c65cd62f6a1b9ab9要点: 掌握 req.query 的用法 // 引入依赖var express = require('express');var utility = require('utility');// 建立 express 实例var app = express();app.get('/', function (req, res) &#123; // 从 req.query 中取出我们的 q 参数。 // 如果是 post 传来的 body 数据，则是在 req.body 里面，不过 express 默认不处理 body 中的信息，需要引入 https://github.com/expressjs/body-parser 这个中间件才会处理，这个后面会讲到。 // 如果分不清什么是 query，什么是 body 的话，那就需要补一下 http 的知识了 var q = req.query.q; // 调用 utility.md5 方法，得到 md5 之后的值 // 之所以使用 utility 这个库来生成 md5 值，其实只是习惯问题。每个人都有自己习惯的技术堆栈， // 我刚入职阿里的时候跟着苏千和朴灵混，所以也混到了不少他们的技术堆栈，仅此而已。 // utility 的 github 地址：https://github.com/node-modules/utility // 里面定义了很多常用且比较杂的辅助方法，可以去看看 var md5Value = utility.md5(q); res.send(md5Value);&#125;);app.listen(3000, function (req, res) &#123; console.log('app is running at port 3000');&#125;); 3. 使用 superagent 与 cheerio 完成简单爬虫 需求: 访问 http://localhost:3000/ 时，以 json 形式输出包括主题的作者 例如:[ &#123; "title": "【公告】发招聘帖的同学留意一下这里", "href": "http://cnodejs.org/topic/541ed2d05e28155f24676a12", "author": "alsotang" &#125;, &#123; "title": "发布一款 Sublime Text 下的 JavaScript 语法高亮插件", "href": "http://cnodejs.org/topic/54207e2efffeb6de3d61f68f", "author": "otheruser" &#125;] 要点: 使用 superagent 抓取网页 、使用 cheerio 分析网页 superagent 是 http 的一个库，可以发送 get/post 请求 cheerio 就是 Node.js 中的 jquery app.get('/', function (req, res, next) &#123; // 用 superagent 去抓取 https://cnodejs.org/ 的内容 superagent.get('https://cnodejs.org/') .end(function (err, sres) &#123; // 常规的错误处理 if (err) &#123; return next(err); &#125; // sres.text 里面存储着网页的 html 内容，将它传给 cheerio.load 之后 // 就可以得到一个实现了 jquery 接口的变量，我们习惯性地将它命名为 `$` // 剩下就都是 jquery 的内容了 var $ = cheerio.load(sres.text); var items = []; $('#topic_list .topic_title').each(function (idx, element) &#123; var $element = $(element); items.push(&#123; title: $element.attr('title'), href: $element.attr('href') &#125;); &#125;); res.send(items); &#125;);&#125;); 4. 使用 eventproxy 控制并发 需求: 以上文目标为基础，输出 comment1 的作者，以及他在 cnode 社区的积分值要点: 体会 Node.js 的 回调地狱 之美 、使用 eventproxy 这一利器控制并发 注意: cnodejs.org 网站有 并发连接数 的限制，当请求发送太快时会导致返回值为空或报错 抓取所有的 a 链接 访问 a 链接并收集所需数据 var eventproxy = require('eventproxy');var superagent = require('superagent');var cheerio = require('cheerio');var url = require('url');var cnodeUrl = 'https://cnodejs.org/';superagent.get(cnodeUrl) // 请求结束后 .end(function (err, res) &#123; // error 处理 if (err) &#123; return console.error(err); &#125; // 初始化储存 a 链接的数组 var topicUrls = []; // 成功返回信息 $ 化 var $ = cheerio.load(res.text); // 处理信息中的 href 字段并放入数组中 $('#topic_list .topic_title').each(function (idx, element) &#123; var $element = $(element); var href = url.resolve(cnodeUrl, $element.attr('href')); topicUrls.push(href); &#125;); // 初始 eventProxy (事件代理) var ep = new eventproxy(); // 当 topic_html emit topicUrls.length 次时 , 回调函数就会触发 ep.after('topic_html', topicUrls.length, function (topics) &#123; // topics 是个二维数组，类似 [[url, text], [url,text]] topics = topics.map(function (topicPair) &#123; var topicUrl = topicPair[0]; var topicHtml = topicPair[1]; var $ = cheerio.load(topicHtml); return (&#123; title: $('.topic_full_title').text().trim(), href: topicUrl, comment1: $('.reply_content').eq(0).text().trim(), &#125;); &#125;); console.log('final:'); console.log(topics); &#125;); topicUrls.forEach(function (topicUrl) &#123; superagent.get(topicUrl) .end(function (err, res) &#123; console.log('fetch ' + topicUrl + ' successful'); // 触发 topic_html 事件并发送响应的数据 ep.emit('topic_html', [topicUrl, res.text]); &#125;); &#125;); &#125;); 5. 使用 async 控制并发 需求: 当请求很多请求并发时, 有的网站有可能会因为发出的并发连接数太多而当做恶意请求，把其 IP 封掉。要点: 使用 async 来 控制并发连接数 此次示例所用且常用到的 async 接口 mapLimit(arr, limit, iterator, callback) queue(worker, concurrency) 控制并发连接数 什么时候用 eventproxy ，什么时候使用 async 呢？它们不都是用来做异步流程控制的吗？ 当需要去多个源(一般是小于 10 个)汇总数据的时候，用 eventproxy 方便 当你需要用到队列，需要控制并发数，使用 async。 6. 测试用例：mocha，should，istanbul待掌握 要点 学习使用测试框架 mocha 学习使用断言库 should 学习使用测试率覆盖工具 istanbul 简单 Makefile 的编写 mocha 输出测试结果 istanbul cover _mocha 输出覆盖率 open coverage/lcov-report/index.html 浏览器查看 7. 浏览器端测试: mocha, chai, phantomjs待掌握 要点 学习使用测试框架 mocha 进行前端测试 了解全栈的断言库 chai 了解 headless 浏览器 phantomjs 8. 测试用例: supertest待掌握]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何才能成为很厉害的人]]></title>
    <url>%2Frexue%2F</url>
    <content type="text"><![CDATA[首先，少年，答应别人的承诺，就一定要兑现。 我以前啊，和你一样，很想成为一个很厉害很厉害很厉害的人。 喜欢看热血的东西，幻想自己是屠龙的勇士，登塔的先锋，我左手有剑，右手有光，没头没脑的燃烧自己，敌人的骑军来了，我说你们何人堪与之战，我的女人在等我。 后来我现实了一点，我觉得我要成为那种说走就走，说日就日的男人，我梳大背头，流浪在欧洲或者新几内亚的，我拍孩子，拍野兽，拍流浪的雏妓，与罗伯特德尼罗握手，说嘿，我给你写了愤怒的公牛2。 再后来，我觉得我人生的梦想，是在城市中心买上一间顶层公寓，把一整面墙都改造成钢化玻璃，在灯火通明的夜晚，我就要端着酒站在巨大的窗前，看整个城市在呼吸，然后我的朋友叩门，他带来了一打嫩模，我们就玩一些成年人的游戏现在，我发现龙并不存在，我不会骑马，不会用单反，家住2楼，我能做的，就是把眼前的事儿做好，赚到足够的钱，这样我可以给我的姑娘一个地球仪，然后用飞镖扎它，扎到哪儿，就去哪儿玩。 这样看来，虽然我的想法随着生殖器的发育，始终在变，但那个很厉害很厉害的人，一直离我很远，甚至越来越远。 我心中曾经执剑的少年，此刻也混迹在市井之间。 血似乎都凉了。 我也不是没有惶恐过，是不是我这一生，都不能左手持剑，右手握着罗伯特德尼罗，说这里的嫩模随便你玩但是你他妈别从窗户上掉下去。 这样一看，我逊得不行，我的朋友都是一些凡人，比我还逊，业余生活就是推塔、中单、跪。 我心想，我是不是这辈子都要做一个逊逼，直到我的坟墓上写好墓志铭，我甚至都想好了：我来，我见，我挂了。 最后我给了自己一个否定的答复，我不要。 我喜欢我的朋友们，喜欢我现在的生活，首先我希望你明白，没有厉害与逊逼得区分，只有血的凉与热，有的人觉得生活就这样吧，我算了，现在没什么不好。 有的人觉得生活这样挺好，但是我还要更好。 这种只要剧情稍微热血一点就会热泪盈眶的傻逼，已经不多了，一刻也不要停留。 所以现在，我和你不一样了，我仍然想成为一个很厉害很厉害很厉害的人，像我们这种剧情稍微热血一点就会热泪盈眶的傻逼，要好好珍惜自己。 很多人坐下来了，跟你说你不行，说你省点儿心吧，说你请静一静。 汹涌的人群就把你这样的少年淹没了，人群散去的时候，你也不见了，你那些承诺，谁也听不见，这个世界对于你，就再不可能有什么更有趣更漂亮的女朋友。 你就失约了，小逼崽子。 这么跟你说。 虽然随着年龄的增长，我趋于现实，不能像你那样分分钟冲动的燃烧，然而我每时每刻都有想做的事，有想达成的目标。 不排除以后的某一年，我会握着罗伯特德尼罗的手，他说这是你写得吗，愤怒的公牛2，只要他还没死。 故事里拳王拉莫塔忍着伤，他举着铁拳，挥汗如雨，要和命运斗争，他说我怎么能失约呢，我是那个要成为很厉害很厉害的拳王拉莫塔！小伙儿，成为很厉害很厉害的人，最重要的，就是要热血，永远也不要让你的血凉下去，你凉下去了，就再也不能找到一个更有趣更漂亮的女友，你就失约了，于是那天她踏梦而来，就成了一个彻头彻尾的笑话。 当有一天你成为你讨厌的那种人，浑浑噩噩，你走在街上，看见那些更有趣更漂亮的女孩，你会不会想起多年以前，你说我答应你，在一个承诺就是永远的年纪。 读书，交友，美容，都不如你这一腔狗血，滚烫，灼人，你要燃上大半辈子，才对得起你现在说的这些话。 我听闻最美的故事，是公主死去了，屠龙的少年还在燃烧。 火苗再小，你都要反复的点燃。 所谓热血的少年，青涩的爱恋，死亡与梦之约。 这么好的故事。 你可别演砸了。 最后我给你点个人建议： 1.读书，读到倦，网上有很多方法，但你从来沉不下心看。 2.学习，学到疼，网上有很多方法，但你从来沉不下心看。 3.开口说话，冷场也要说话，脸皮薄也要说话，挨打也要说话。 4.如果你现在不知道做什么，至少你还可以先从做一个牛逼的学生开始。 5.更漂亮更有趣的女孩，五年以后再找。 6.承诺是鞭子，不是兴奋剂。 7.年纪大了，也不要说什么心如死灰。 改变自己是非常，非常，非常痛苦的，我能看出来你一腔热血的优点，自然知道你孤僻懒散自以为是的缺点，方法很多，不过我不确定你吃不吃得了苦，我和你共勉吧。 在成为最厉害最厉害最厉害的道路上。 作者：朱炫链接：https://www.zhihu.com/question/22921426/answer/23330366来源：知乎]]></content>
      <categories>
        <category>热乎鸡汤</category>
      </categories>
      <tags>
        <tag>知乎</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Quotation]]></title>
    <url>%2Fquotation%2F</url>
    <content type="text"><![CDATA[苟利国家生以死,岂因祸福趋避之出自『林则徐』 只比你努力一点的人,其实已经甩你很远出自『☆』 主动往往能为你赢得更多机会出自『☆』 世界的模样在于你看它的角度出自『☆』 真正成熟的人,脾气永远不会大于他的能力出自『☆』 不要用 “作” 来找存在感出自『☆』 人不牺牲什么就什么也得不到，为了得到什么就要付出同样的代价，那就是炼金术的等价交换原则，那个时候，我们相信那是世界的真实。出自『钢之炼金术师』 思想中一旦有了依附，骨子里便失去了坚强；出自『网络』 星星之火，可以燎原。出自『张居正』 纸上得来终觉浅，绝知此事要躬行。出自『陆游』 要保持剑的锋利就得时时磨拭，要保持头脑灵光就得看书。出自『乔治·马丁』 俗话说不耻下问是一时之耻，耻而不问是一生之耻。出自『白箱』 累过方得闲，苦过方知甜。出自『网络』 不以物喜，不以己悲。出自『范仲淹』 若有恒，何必三更眠五更起；最无益，莫过一日曝十日寒；出自『毛泽东』 战略上藐视敌人，战术上重视敌人；出自『毛泽东』 人生路很长，永远不要高兴太早。出自『平常心』 人生就像一盒的巧克力，你永远不知道下一块是什么口味。出自『阿甘正传』 如果你不努力，一天比一天容易，但一年比一年难；如果你努力了，一天比一天难，但一年比一年容易。出自『网络』 只有内心强大，才能实现自我救赎；出自『9.18』 富，亦指精神；强，亦指内心；出自『9.18』 人一定要认清自己，自己能干什么，干得了什么，不要人云亦云。出自『★』 对社会不要有太多的抱怨。创业的时候不要把自己当人看。有行动不一定能成功，没有行动就一定失败。出自『俞敏洪』 那家伙永远都是挑战者出自『棒球大联盟』 做没做过的事情是要建立在老老实实的成功之后的基础之上。出自『★』]]></content>
      <categories>
        <category>零七碎八</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[photo]]></title>
    <url>%2Fphoto%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>零七碎八</category>
      </categories>
      <tags>
        <tag>picture</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-world%2F</url>
    <content type="text"><![CDATA[历程还记得在 Github 上生成的第一个page时的新奇还记得在 CSDN 的第一次开通博客的 Hello world 的兴奋如今在Github的page上生成了自己的博客，那可谓是即新奇 + 兴奋带来的激动可以在自己的这块领地为所欲为，光想想就有一种迎风而来的酸爽 致敬每一次的开始都仿佛打开一扇门而每扇门的背后都有着无数默默付出和无私奉献的人是他们让现在的这个圈子有了生态没有他们的付出我不会这么顺利的把这个博客搭建起来再次由衷的致敬这些人我愿成为向你们一样的人]]></content>
      <categories>
        <category>东拉西扯</category>
      </categories>
      <tags>
        <tag>Hello</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO+GitHub,搭建博客 - 域名绑定]]></title>
    <url>%2Fwwwyuming%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面也讲过了，我们把博客同时托管到 Github 和 Coding。我们就有两个域名可以访问站点，但是又出现几个问题：使用的不是自己的域名；两个地址的统计信息（文章阅读量，访问量等）相互独立，不能合并；github pages国内访问速度慢（300ms左右，毕竟国外的服务器）。 这就有点坑爹了，强迫症怎么能忍。下面给出解决方法。。 解决方案：我们知道 github 和 coding 的 pages 服务都提供 自定义域名 功能。我们可以利用这一点，绑定自己的域名。域名解析的时候实现国内访问 coding pages ，国外访问 github pages ,从而加快访问速度。 具体怎么实现，往下看： 购买域名首先我们要购买一个域名，推荐到 万网 购买。（毕竟很方便）具体步骤可以参考这篇文章：万网域名注册教程。 购买域名一定要实名认证，否则会停止解析 域名解析这一步是最重要的，我们要把域名指向 github 和 coding 的服务器空间。 登录阿里云，进入 控制台 。依次点击 域名与网站 &gt; 云解析DNS 就会出现你购买的域名信息 点击 解析，然后按照下图依次添加解析：（这张图片可以放大） 从上图可以看出，我们的解析实现了分流。国内线路访问Coding pages，国际线路访问Github Pages。 托管平台设置Coding平台进入对应项目的 pages 设置页面（项目 &gt; 代码 &gt; pages服务） 成功后会显示： Github平台进入对应项目的 pages 设置页面（setting &gt; github pages &gt; Custom domain) 成功后会显示： 到此我们的博客就可以正常运行了！！ 总结一切搞定后，在回头看一下我们的问题：@ 两个地址的统计信息（文章阅读量，访问量等）相互独立，不能合并； 从两个地址访问都会跳转到我们绑定的域名。统计信息自然也是绑定后域名的信息。 @ github pages国内访问速度慢（300ms左右） 我们测试一下 Ping：(表现不错) @ 托管平台给出的二级域名太丑。 不存在的…..]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Next+Hexo</tag>
        <tag>博客搭建</tag>
        <tag>域名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO 博客同时部署到 GitHub 和 Coding]]></title>
    <url>%2Fgithub%E5%92%8Ccoding%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很多人都把 hexo 托管到 Github 上，因为 Github 大家都用的比较久了。但是，你的博客主要访问者肯定还是国内的用户，国内的用户访问 coding 比 github 是要快不少的。还可以利用域名解析实现国内的走 coding，海外的走github，分流网站的访问。 注册GitHub和Codinggithub官网 &nbsp;&nbsp;||&nbsp;&nbsp; Coding官网 &nbsp;&nbsp;注册就不必多说，不会的可自行百度。需要注意的是：最好使用同一个 用户名 和 邮箱 ，以免引起不必要的麻烦。 创建项目在GitHub上创建项目，名称为：yourname.github.io在Coding上创建项目，名称为：yourname 配置SSH配置 shh key 是让本地 git 项目与远程的 github 建立联系 获取ssh 检查是否已经有SSH Key，打开 Git Bash，输入 cd ~/.ssh 如果没有 .ssh 这个目录，则生成一个新的 SSH，输入 ssh-keygen -t rsa -C &quot;your e-mail&quot; 注意: 此处的邮箱地址，是你注册 GitHub 和 coding 时的邮箱地址; 此处的「-C」的是大写的「C」 。 接下来几步都直接按回车键,然后系统会要你输入密码 (防止别人往你的项目里提交内容) Enter passphrase (empty for no passphrase):&lt;输入加密串&gt;Enter same passphrase again:&lt;再次输入加密串&gt; 成功后，我们打开 C:\Users\cwyaml.ssh 打开 id_rsa.pub 文件。里面的代码就是 ssh key。 添加 SSH Key 到 GitHub 和 CodingGitHub添加方法： 进入Github官网，点击头像，再按 settings 进入设置。 点击 New SSH key 创建 title输入邮箱，key里面粘贴刚才右击复制的内容,再点 Add SSH key 即可。（会让你输入密码） Coding添加方法： 登录账号后点击 左侧账户 在点 SSH公钥 设置即可 。（同样要输入密码） 测试SSH是否配置成功打开 Git Bash，首先测试 GitHub 是否成功？输入:ssh -T git@github.com (如配置了密码则要输入密码,输完按回车。)如果显示以下内容，则说明 Github 中的 ssh 配置成功。Hi username! You&apos;ve successfully authenticated, but GitHub does notprovide shell access. 然后测试 Coding 是否成功？ssh -T git@git.coding.net 如果显示以下则说明配置成功：Hello username You&apos;ve connected to Coding.net by SSH successfully! 上传博客文件修改站点配置文件：# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: github: git@github.com:cwyaml/cwyaml.github.io.git,master coding: git@git.coding.net:cwyaml/cwyaml.git,master 然后你就可以 hexo c、hexo g、hexo d 了。 开启pages服务GitHub 已经默认开启，就不必多说了。Coding 进入对应项目，点击 代码&gt;pages服务 ，把部署来源改为 master 即可。 访问博客这样我们整个部署过程就完成了。有两个地址可以访问我们的博客：GitHub pages：https://cwyaml.github.ioCoding pages：https://cwyaml.coding.me]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Next+Hexo</tag>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO+GitHub,搭建博客 - 备份]]></title>
    <url>%2Fbackup%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用Hexo写博客是一件比较享受的事情，无奈如果换电脑或者系统崩了的话，你就会一脸懵B了，备份博客就显得尤为重要。先说说我的感受，博客刚搭建好的时候就想过这个问题，那时候对 git 似懂非懂吧。在网上找了很多教程方法，大概就是说要创建一个分支来存放 blog 文件，但是翻腾来翻腾去还是没有搞定。 最后索性简单粗暴点，在 GitHub 上创建一个仓库，把 blog 文件整个打包上传。使用过程中发现这个方法还不错，至少对于小白来说很容易理解，也很难出错，就一直沿用到现在。 这种方式虽然能够备份 Hexo 博客的源文件，但是对于博主这种懒人，每次更新博文都需要输入两三行重复的Git命令真是一件麻烦的事情。 自动备份准备本方法需要提前将 Hexo 加入 Git仓库 并与 Github 远程仓库绑定之后，才能正常工作。具体做法可以参考：上传本地项目到GitHub 安装 shelljs 模块要实现这个自动备份功能，需要依赖 NodeJs 的一个 shelljs 模块,该模块重新包装了 child_process,调用系统命令更加的方便。使用以下命令，完成 shelljs 模块的安装：npm install --save shelljs 编写自动备份脚本待到模块安装完成，在Hexo根目录 的 scripts文件夹下新建一个js文件，文件名随意取。如果没有scripts目录，请新建一个。require(&apos;shelljs/global&apos;);try &#123; hexo.on(&apos;deployAfter&apos;, function() &#123;//当deploy完成后执行备份 run(); &#125;);&#125; catch (e) &#123; console.log(&quot;产生了一个错误&lt;(￣3￣)&gt; !，错误详情为：&quot; + e.toString());&#125;function run() &#123; if (!which(&apos;git&apos;)) &#123; echo(&apos;Sorry, this script requires git&apos;); exit(1); &#125; else &#123; echo(&quot;======================Auto Backup Begin===========================&quot;); cd(&apos;C:/Blog&apos;); //此处修改为Hexo根目录路径 if (exec(&apos;git add .&apos;).code !== 0) &#123; echo(&apos;Error: Git add failed&apos;); exit(1); &#125; if (exec(&apos;git commit -m &quot;Form auto backup script\&apos;s commit&quot;&apos;).code !== 0) &#123; echo(&apos;Error: Git commit failed&apos;); exit(1); &#125; if (exec(&apos;git push origin master&apos;).code !== 0) &#123; echo(&apos;Error: Git push failed&apos;); exit(1); &#125; echo(&quot;==================Auto Backup Complete============================&quot;) &#125;&#125; 注意： 其中，需要修改第17行的 D:/hexo 路径为 Hexo的根目录 路径。（脚本中的路径为博主的Hexo路径） 如果你的Git远程仓库名称不为 origin 的话，还需要修改第28行执行的push命令，修改成自己的远程仓库名和相应的分支名。 测试保存脚本并退出，然后执行 hexo d 命令，将会得到类似以下结果:INFO Deploying: gitINFO Clearing .deploy_git folder...INFO Copying files from public folder.........======================Auto Backup Begin===========================warning: LF will be replaced by CRLF in package.json.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in source/_posts/hexo1.md.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in source/_posts/update to github.md.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in source/_posts/wangyimusic.md.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in themes/next-5.0.1/layout/_partials/head.swig.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in source/_posts/backup.md.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in source/_posts/encrypt.md.The file will have its original line endings in your working directory.[master 1bb6cc5] Form auto backup script&apos;s commit Committer: unknownYour name and email address were configured automatically basedon your username and hostname. Please check that they are accurate.You can suppress this message by setting them explicitly. Run thefollowing command and follow the instructions in your editor to edityour configuration file: git config --global --editAfter doing this, you may fix the identity used for this commit with: git commit --amend --reset-author 6 files changed, 177 insertions(+), 2 deletions(-) create mode 100644 scripts/autobackup.js create mode 100644 source/_posts/backup.md create mode 100644 source/_posts/encrypt.mdTo https://github.com/cwyaml/blog-backup.git d7bc718..1bb6cc5 master -&gt; master==================Auto Backup Complete============================ 这样子，每次更新博文并 deploy 到服务器上之后，备份就自动启动并完成备份啦~是不是很方便呢？ Enjoy it！ 参考：wanghao大神 自动备份Hexo博客源文件]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Next+Hexo</tag>
        <tag>博客搭建</tag>
        <tag>backup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 使用中常见的问题及解决方法]]></title>
    <url>%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就像 Markdown 官方文档里描述的一样：可读性，无论如何，都是最重要的。 Markdown 的目标是实现 &nbsp; 『易读易写』 。&nbsp;Markdown 从发布到现在备受好评，经过这一段的使用，整体感觉挺顺手，不过还是存在很多问题，所以总结一下喽。。 编辑器其实自己喜欢的才是最好的。(像 vim 、emacs什么的不推荐，因为我也不会用) MAC平台自己没用过，不做推荐。你可以看看这个帖子：Mac 上适合码农用的 Markdown 编辑器是什么？ Windows平台印象笔记马克飞象传送门，界面不是很好看，书写的时候感觉很别扭 有道云笔记有道传送门，同样很丑，强迫症受不了 Sublime Text强大的 Sublime Text 总是能给我们很多惊喜，经过各种对比，sublime 满足了我对审美的要求。首先我们需要安装两个插件：（至于怎么安装就不说了） markdownEditing 用来书写 markdownPreview 用来预览 Atom（强烈推荐）GitHub 推出的编辑器，界面很好（就是启动有点慢），必须支持一下。默认继承了 markdown 预览，快捷键为 Ctrl+shift+M。推荐插件： markdown-preview 实时预览 markdown-scroll-sync 编辑区和预览区同步滚动 markdown-writer 方便管理图片链接等 markdown-table-formatte 表格格式化 使用方法Markdown官方文档 常见问题汇总html标签显示比如说我要写一篇博客，标题为“html中 &lt;canvas&gt; 的使用”## html中 &lt;canvas&gt; 的使用 如果这样写就会出现排版上的问题（不信你试一下），那么怎么解决呢？其实认真想一下就能明白，Markdown 的语法是基于 html 的，我们直接写 &lt;canvas&gt;，自然会被理解为一个标签，而不是要显示的文本。。所以，问题回归到 html 上。在网页中，我们要显示 &lt;canvas&gt; 时要用到 转义字符, 所以 Markdown 中也一样，我们应该这样写：## html中 &amp;lt;canvas&amp;gt; 的使用 代码语法高亮这个问题困扰了我好久，官方文档里竟然没有说明！只好自己去查找方法。Markdown 中显示代码块是这样的格式：显示为：&lt;p&gt;这是一个p标签&lt;/p&gt; 而我们这样写：就可以实现代码高亮了&lt;p&gt;这是一个p标签&lt;/p&gt; 据说这种方式一共支持四十多种语言，有兴趣的话你可以研究一下。 图片Markdown 中嵌入图片，如果使用本地图片就要用到 html 标签来引用，这种方法很稳定，但是使文档变得很大（一张图片最少几百k吧）。所以我们要用到 图床 。 贴图库推荐使用 &nbsp; 贴图库 &nbsp;快速，免费（我使用过程中没掉过链子） 注册登录，就可以上传图片，每张图片自动生成 原图、展示图和 缩略图的图片外链、html代码、Markdown外链等。只要把对应的代码粘贴到你的文档中就可以了。。 七牛云存储这个最近很火，可靠、可扩展、低成本等等有很多优点。你可以试一下。我们主要用到他的 对象存储 服务，创建一个公开仓库，把图片上传就可以生成外链了。 gifGithub 上的开源项目，ReadMe.md 是也支持 Markdown 语法的，通常会看到很多开源项目的 ReadMe 中有 动态演示效果，看到这个项目的人一目了然，非常方便，gif本身也是一种图片格式，在 Markdown 中 引用时和正常图片的引用一样，但需要专门的工具生成 gif 格式的图片才行，在这里强烈推荐 LICEcap，它是一款 windows 上的录屏软件，录制后保存的格式为 gif，体积小并且同样也可以在图床上生成链接。 插入音乐你可以把音乐文件下载到本地，然后简单粗暴的使用 html 中的 &lt;video&gt; 标签。当然，如果这样就不必写下去了，告诉你简单的方法：网易云音乐 打开网易云音乐网页版，搜索自己喜欢的音乐，比如我找到 告白气球 我们可以看到在图片的下边有一个 生成外链播放器 , 点击会出现 选择 合适的尺寸 和 播放模式 之后。把下边的代码复制到你的 Markdown 文档中就可以了。试着听一下吧！！(我选择了最小尺寸) 试着去把一个 歌单生成外链播放器 插入到你的 Markdown 中，这样你跟新歌单你的博文也会跟着变化，而不必在想跟换歌曲时头疼]]></content>
      <categories>
        <category>零七碎八</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单博文加密]]></title>
    <url>%2Fencrypt%2F</url>
    <content type="text"><![CDATA[即使是最简单的加密方式也足以阻止90%的访问者 原理由于 Hexo 最终编译出来的是静态文件，也就意味着文章的所有信息会原封不动展示在页面中，当你输入一篇文章的地址，所有的内容就已经跟随网络传输过来了。那么博客使用加密是怎么实现的呢？ 这就要讲到 js 的阻塞机制了，当调用 alert(); 函数的时候，整个页面会停止运行，直到你点击确定之后，才会继续执行下去。我们这里需要的也是这样一个假象，阻止整个页面的渲染，直到你输入了正确的密码才能让页面继续渲染实际的文章。可是 alert(); 只有提醒的功能，没有输入的功能，所以，这里要用到的是 promt() 方法。 promt()方法介绍这个 promt() 方法有什么作用呢？查看js文档可以知道： prompt()方法 : 用于显示可提示用户进行输入的对话框。如果用户单击提示框的 取消 按钮，则返回 null。如果用户单击 确认按钮，则返回 输入字段当前显示的文本（用户输入的文本）。 我们就是利用 promt() 方法可以返回用户输入的文本这个特性，获取到返回数据，与我们设置的密码进行验证，从而实现文档加密的。。 实践找到 themes\next\layout\_partials\head.swig 文件。在 &lt;meta&gt; 标签之后添加以下代码：&lt;script&gt; (function()&#123; if(&apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123; if (prompt(&apos;请输入文章密码&apos;,&apos;&apos;) !== &apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123; alert(&apos;密码错误！&apos;); history.back(); &#125; &#125; &#125;)();&lt;/script&gt; 这里有必要解释一下 page.password 是什么东西。以下我给出这篇文章的头部参考：首先 page 是一个变量，你可以理解为这篇文章。以下面的代码为参考，那么 page.title = 最简单的翻墙方法; page.comments = fasle;（很好理解吧） title: 最简单的翻墙方法date: 2017-03-01 12:01:05tags: [翻墙,hosts]categories: [外面的世界]keywords: 翻墙,hostscomments: false 所以，要想加密博文，我们要为文章加上 password 属性。description 属性用于对文章进行描述。（加密下显示内容）description: 文章访问密码：passwordpassword: password 总结这种方式只能说是一点小技巧的应用吧，在大神面前可能不管用，但足以阻挡大多数用户。更完美的博文加密方式请参考：加密博客内容，使用密码访问]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Next+Hexo</tag>
        <tag>博客搭建</tag>
        <tag>encrypt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO+GitHub搭建博客 - 优化]]></title>
    <url>%2Fhexo2%2F</url>
    <content type="text"><![CDATA[本篇文章主要介绍基于NexT主题的一些第三方功能的实现。基本功能的设置可以参考Next官网文档 首先，我们需要明白： 在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml 。其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。我们约定，将前者称为 站点配置文件 ，后者称为 主题配置文件。 背景动态背景修改 _layout.swig 模板模板位置：themes\next\layout\_layout.swig在末尾前加上下面一句:（这里提供两种样式，当然你也可以自由更改）&lt;!-- 动态背景 --&gt;#默认灰色线条&lt;script type="text/javascript" src="/js/src/particle.js"&gt;&lt;/script&gt;#浅蓝色线条&lt;script type="text/javascript" src="/js/src/particle.js" count="50" zindex="-2" opacity="1" color="0,104,183"&gt;&lt;/script&gt; 然后在 themes\source\js\src\ 下新建文件 particle.js 写上以下代码:!function()&#123;function n(n,e,t)&#123;return n.getAttribute(e)||t&#125;function e(n)&#123;return document.getElementsByTagName(n)&#125;function t()&#123;var t=e("script"),o=t.length,i=t[o-1];return&#123;l:o,z:n(i,"zIndex",-1),o:n(i,"opacity",.5),c:n(i,"color","0,0,0"),n:n(i,"count",99)&#125;&#125;function o()&#123;c=u.width=window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth,a=u.height=window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight&#125;function i()&#123;l.clearRect(0,0,c,a);var n,e,t,o,u,d,x=[w].concat(y);y.forEach(function(i)&#123;for(i.x+=i.xa,i.y+=i.ya,i.xa*=i.x&gt;c||i.x&lt;0?-1:1,i.ya*=i.y&gt;a||i.y&lt;0?-1:1,l.fillRect(i.x-.5,i.y-.5,1,1),e=0;e&lt;x.length;e++)n=x[e],i!==n&amp;&amp;null!==n.x&amp;&amp;null!==n.y&amp;&amp;(o=i.x-n.x,u=i.y-n.y,d=o*o+u*u,d&lt;n.max&amp;&amp;(n===w&amp;&amp;d&gt;=n.max/2&amp;&amp;(i.x-=.03*o,i.y-=.03*u),t=(n.max-d)/n.max,l.beginPath(),l.lineWidth=t/2,l.strokeStyle="rgba("+m.c+","+(t+.2)+")",l.moveTo(i.x,i.y),l.lineTo(n.x,n.y),l.stroke()));x.splice(x.indexOf(i),1)&#125;),r(i)&#125;var c,a,u=document.createElement("canvas"),m=t(),d="c_n"+m.l,l=u.getContext("2d"),r=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(n)&#123;window.setTimeout(n,1e3/45)&#125;,x=Math.random,w=&#123;x:null,y:null,max:2e4&#125;;u.id=d,u.style.cssText="position:fixed;top:0;left:0;z-index:"+m.z+";opacity:"+m.o,e("body")[0].appendChild(u),o(),window.onresize=o,window.onmousemove=function(n)&#123;n=n||window.event,w.x=n.clientX,w.y=n.clientY&#125;,window.onmouseout=function()&#123;w.x=null,w.y=null&#125;;for(var y=[],s=0;m.n&gt;s;s++)&#123;var f=x()*c,h=x()*a,g=2*x()-1,p=2*x()-1;y.push(&#123;x:f,y:h,xa:g,ya:p,max:6e3&#125;)&#125;setTimeout(function()&#123;i()&#125;,100)&#125;(); 鼠标点击小红心在 \themes\next\source\js\src 文件目录下添加 love.js 文件。内容为：!function(e,t,a)&#123;function n()&#123;c(".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText="left:"+d[e].x+"px;top:"+d[e].y+"px;opacity:"+d[e].alpha+";transform:scale("+d[e].scale+","+d[e].scale+") rotate(45deg);background:"+d[e].color+";z-index:99999");requestAnimationFrame(r)&#125;function o()&#123;var t="function"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement("div");a.className="heart",d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement("style");a.type="text/css";try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName("head")[0].appendChild(a)&#125;function s()&#123;return"rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")"&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 找到 \themes\next\layout\_layout.swing 文件， 在文件的后面， 标签之前 添加以下代码：&lt;!-- 小红心 --&gt;&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt; 头像圆形旋转修改文件 themes/next/source/css/_common/components/sidebar/sidebar-author.styl我的样式文件 文章结尾模板在 \themes\next\_macro 文件目录下添加 passage-end-tag.swig 文件，内容为：(当然你也可以修改为自己喜欢的样式)&#123;% if theme.passage_end_tag.enabled %&#125;&lt;blockquote class="blockquote-center"&gt; &lt;p&gt;如果您觉得本博客还不错，欢迎继续关注本博客，欢迎多提宝贵意见，非常感谢！&lt;/p&gt;&lt;/blockquote&gt;&lt;span id="inline-green" style="border-radius:3px;"&gt;作者&lt;/span&gt;：&lt;a class="link-blue" href="https://github.com/cwyaml" target="_blank"&gt;cwyaml&lt;/a&gt;有问题请 &lt;a class="link-blue" href="https://cwyaml.github.io/about/"&gt;留言&lt;/a&gt;或者私信我的 &lt;a class="link-blue" href="http://weibo.com/u/5742789641?refer_flag=1001030102_&amp;is_all=1" target="_blank"&gt;微博&lt;/a&gt;。&lt;div style="text-align:center; color:#ccc; font-size:14px; "&gt; ------本文结束 &amp;nbsp;&lt;i class="fa fa-paw"&gt;&lt;/i&gt;&amp;nbsp; 感谢阅读------&lt;/div&gt;&#123;% endif %&#125; 找到 \themes\next\_macro\post.swig 文件，使用查找功能找到 reward.swig，在这一个 &lt;div&gt; 的前面添加：&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'passage-end-tag.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 文章底部标签云锚点在 themes\next\layout\_macro\post.swig 文件中找到以下代码：&lt;footer class="post-footer"&gt;&lt;!--这是文章底部标签云锚点，不喜欢就注释掉 &#123;% if post.tags and post.tags.length and not is_index %&#125; &lt;div class="post-tags"&gt; &#123;% for tag in post.tags %&#125; &lt;a href="&#123;&#123; url_for(tag.path) &#125;&#125;" rel="tag"&gt;# &#123;&#123; tag.name &#125;&#125;&lt;/a&gt; &#123;% endfor %&#125; &lt;/div&gt; &#123;% endif %&#125;--&gt; 关于文章内文本样式Markdown 毕竟是为了方便写作，在样式上就过于单调。我们自己来给文章加一些样式。。 Next 作者提供了一个供用户自己定义样式的文件：\themes\next\source\css\_custom\custom.stl 自己按需要写在上述文件中写上自己的 class 类，然后在 Markdown 文档中使用。我的custom.styl 引用前端框架目前流行的前端框架，像 bootstrap、React、Angular 等，提供给我们很好的前端方案，我们可以把喜欢的引入到上面说的那个文件里，然后就可以使用了。 设置动态title 在 \themes\next\source\js\src 目录下新建 dytitle.js 。添加以下内容： &lt;!--崩溃欺骗--&gt;var OriginTitile = document.title; var titleTime; document.addEventListener(&apos;visibilitychange&apos;, function () &#123; if (document.hidden) &#123; $(&apos;[rel=&quot;icon&quot;]&apos;).attr(&apos;href&apos;, &quot;/img/TEP.ico&quot;); document.title = &apos; 页面崩溃啦 ~ | cwyaml！&apos;; clearTimeout(titleTime); &#125; else &#123; $(&apos;[rel=&quot;icon&quot;]&apos;).attr(&apos;href&apos;, &quot;/favicon.ico&quot;); document.title = &apos; 噫又好了~ &apos; + OriginTitile; titleTime = setTimeout(function () &#123; document.title = OriginTitile; &#125;, 2000); &#125; &#125;); 更改 \themes\next\layout\_layout.swig 。在 &lt;/body&gt; 之前添加： &lt;!--崩溃欺骗--&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/dytitle.js&quot;&gt;&lt;/script&gt; 首页动画在 主题配置文件 中，找到 Motion 字段。true 和 false 控制动画的开启与关闭。# Motionuse_motion: true 内容宽度现在一般的笔记本都在15寸以上，博客页面两侧留白太多就显得没有必要，并且不美观，所以有必要调整一下宽度。（可以慢慢试着调整到最合适的状态） 找到 \themes\next\source\css\_common\components\post\post-expand.styl，找到： @media (max-width: 767px)改为：@media (max-width: 1060px) 找到：\themes\next\source\css\ _variables\base.styl ，找到： $main-desktop = 960px$main-desktop-large = 1200px$content-desktop = 700px改为：$main-desktop = 1060px$main-desktop-large = 1200px$content-desktop = 800px 找到 \themes\next\source\css\_schemes\Pisces\_layout.styl ，将第 4 行的 width 改为 1060px ，修改后如下： .header &#123; position: relative; margin: 0 auto; width: 1060px; 统计功能文章阅读次数统计参考： LeanCloud 不蒜子统计站点访问 全局配置：编辑 主题配置文件 中的 busuanzi_count 的配置项，配置以下内容：当 enable: true 时，代表开启全局开关。若 site_uv、site_pv、page_pv 的值均为 false 时，不蒜子仅作记录而不会在页面上显示。 站点 UV/PV 配置：当 site_uv: true 时，代表在页面底部显示站点的 UV 值。当 site_pv: true 时，代表在页面底部显示站点的 PV 值site_uv_header(site_pv_header) 和 site_uv_footer(site_pv_footer) 为自定义样式配置，相关的值留空时将不显示，可以使用（带特效的）font-awesome。显示效果为 [site_uv_header]UV值/PV值[site_uv_footer]。 busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: 本站总访问量 site_uv_footer: # custom pv span for the whole site site_pv: true site_pv_header: 您是第 site_pv_footer: 位小伙伴 单页面 PV 值设置： # custom pv span for one page onlypage_pv: falsepage_pv_header: &lt;i class=&quot;fa fa-file-o&quot;&gt;&lt;/i&gt;page_pv_footer: 开启打赏功能越来越多的平台（微信公众平台，新浪微博，简书等）支持打赏功能，付费阅读时代越来越近，特此增加了打赏功能。 只需要 主题配置文件 中填入 微信 和 支付宝 收款二维码图片地址（放在博客根目录的source文件夹下即可） 即可开启该功能。reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！wechatpay: /weixin.pngalipay: /zhifubao.png 设置RSS 需要安装 hexo-generator-feed 插件。 $ npm install hexo-generator-feed --save 在 站点配置文件 中添加字段： feed: type: atom path: atom.xml limit: 20 hub: content: 听音乐 下载js文件：high.swig。放在 \themes\next\layout\_macro 目录下。 在侧边栏引用该文件：修改 \themes\next\layout\_macro\sidebar.swig ，添加以下代码： &#123;% include &apos;high.swig&apos; %&#125; 样式修改：使 听音乐 和 RSS 并排展示，修改 \themes\next\source\css\_schemes\Pisces\_sidebar.styl display: inline-block; 添加自己喜欢的音乐：修改其中的歌曲链接即可（获取歌曲外链教程） var songs = [ "http://m2.music.126.net/3uHnH7uQAeFwUfuvEB9lrg==/3265549619475054.mp3", "http://m2.music.126.net/NnHwR2HV-1OoKZ6R5LVy4Q==/18502581673300023.mp3", "http://m2.music.126.net/qv3RI4K7ABKJ0TyAdb3taw==/3250156397064860.mp3", "......" ]; 首页听音乐摇晃：需要加载css样式。在 themes\next\layout\_layout.swig 文件的 body标签结束前 添加以下代码： &lt;!-- 听音乐摇晃 --&gt;&lt;link href="http://s3.amazonaws.com/moovweb-marketing/playground/harlem-shake-style.css" rel="stylesheet" type="text/css"&gt; 注意： 有时候使用 Firefox 、Chrome时会提示非法插件并禁止使用，遇到这种情况我们把样式代码引入到 \themes\next\source\css\_custom\custom.stl 文件即可解决。 添加 Forkme on GitHub 丝带首先进入 GitHub Ribbons 选择自己喜欢的丝带样式。找到 \themes\next\layout\_layout.swig 文件，在 &lt;header&gt; 标签前面添加：（记得把链接修改成自己的GitHub主页）&lt;a href="https://github.com/you"&gt;&lt;img style="position: absolute; top: 0; left: 0; border: 0;" src="https://camo.githubusercontent.com/82b228a3648bf44fc1163ef44c62fcc60081495e/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f6c6566745f7265645f6161303030302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_left_red_aa0000.png"&gt;&lt;/a&gt; 给 Blog 添加 LICENSE修改 主题配置文件 （使用查找功能）# Creative Commons 4.0 International License.# http://creativecommons.org/# Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zerocreative_commons: by-nc-sa#creative_commons: Local Search 安装 hexo-generator-searchdb $ npm install hexo-generator-searchdb --save 编辑 站点配置文件 ，添加以下字段： search: path: search.xml field: post format: html limit: 10000 编辑 主题配置文件 ，启用本地搜索 # Local searchlocal_search: enable: true 多说多说评论使用多说前需要先在 多说 创建一个站点。具体步骤如下： 登录后在首页选择“我要安装”。 创建站点，填写站点相关信息。多说域名 这一栏填写的就是你的 duoshuo_shortname, 创建站点完成后在 站点配置文件 中新增 duoshuo_shortname 字段，值设置成上一步中的值即可。 多说评论框自定义 : 我的样式代码 多说分享在 主题配置文件 中设置：# Shareduoshuo_share: true 禁用鼠标经过时分享更多功能（有bug）:找到 \themes\next\layout\_partials\share\duoshuo_share.swig 文件，替换内容为：&lt;div class="ds-share flat" data-thread-key="&#123;&#123; page.path &#125;&#125;" data-title="&#123;&#123; page.title &#125;&#125;" data-content="" data-url="&#123;&#123; page.permalink &#125;&#125;"&gt; &lt;div class="ds-share-inline"&gt; &lt;ul class="ds-share-icons-16"&gt; &lt;li&gt;&lt;span class="ds-more"&gt;分享到：&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;a class="ds-weibo" href="javascript:void(0);" data-service="weibo"&gt;微博&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a class="ds-qzone" href="javascript:void(0);" data-service="qzone"&gt;QQ空间&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a class="ds-qqt" href="javascript:void(0);" data-service="qqt"&gt;腾讯微博&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a class="ds-wechat" href="javascript:void(0);" data-service="wechat"&gt;微信&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a class="ds-facebook" href="javascript:void(0);" data-service="facebook"&gt;Facebook&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a class="ds-google" href="javascript:void(0);" data-service="google"&gt;Google&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class="ds-share-icons-more"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 博文压缩目前知道的有两个插件可以压缩博文，hexo-all-minifier 插件和 gulp插件。hexo-all-minifier 虽然使用比较简单，而且也可以压缩图片，但是对文章缩进（输入法全拼模式下按 Tab）不支持，所以暂时使用 gulp 压缩手段。 hexo-all-minifier 使用方法安装 hexo-all-minifier，在站点的根目录下执行以下命令：$ npm install hexo-all-minifier --save hexo g 编译的时候就会自动压缩 HTML、JS、图片。详情参考插件介绍 hexo-all-minifier glup 使用方法hexo 依赖 gulp 插件安装，在站点的根目录下执行以下命令：$ npm install gulp -g$ npm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp --save 在 package.json 同级目录下，新建 gulpfile.js 并填入以下内容：var gulp = require(&apos;gulp&apos;);var minifycss = require(&apos;gulp-minify-css&apos;);var uglify = require(&apos;gulp-uglify&apos;);var htmlmin = require(&apos;gulp-htmlmin&apos;);var htmlclean = require(&apos;gulp-htmlclean&apos;);// 压缩 public 目录 cssgulp.task(&apos;minify-css&apos;, function() &#123; return gulp.src(&apos;./public/**/*.css&apos;) .pipe(minifycss()) .pipe(gulp.dest(&apos;./public&apos;));&#125;);// 压缩 public 目录 htmlgulp.task(&apos;minify-html&apos;, function() &#123; return gulp.src(&apos;./public/**/*.html&apos;) .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest(&apos;./public&apos;))&#125;);// 压缩 public/js 目录 jsgulp.task(&apos;minify-js&apos;, function() &#123; return gulp.src(&apos;./public/**/*.js&apos;) .pipe(uglify()) .pipe(gulp.dest(&apos;./public&apos;));&#125;);// 执行 gulp 命令时执行的任务gulp.task(&apos;default&apos;, [ &apos;minify-html&apos;,&apos;minify-css&apos;,&apos;minify-js&apos;]); 生成博文是执行 hexo g &amp;amp;&amp;amp; gulp 就会根据 gulpfile.js 中的配置，对 public 目录中的静态资源文件进行压缩。 博文置顶 修改 hexo-generator-index 插件。替换文件：node_modules/hexo-generator-index/lib/generator.js 为：generator.js 设置文章置顶在文章 Front-matter 中添加 top 值，数值越大文章越靠前，如：---title: cwyaml 图集categories: [图片]tags: [picture]date: 2015-04-02 14:36:04top: 10--- 博文部署 message在 \node_modules\hexo-deployer-git\lib\deployer.js 文件末尾找到这一句：（记得个性一点）Lucky Boy: &#123;&#123; now(\&apos;YYYY-MM-DD HH:mm:ss\&apos;) &#125;&#125;. 图片模式 新建博文，设置 type: &quot;picture&quot;，使用 {\% gp x-x \%} ... {\% endgp \%} 标签引用要展示的图片地址，如下所示：(其中的 x-x 为图片展示效果，可以自己尝试一下) ---title: Naruto-Picturescategories: [图片]tags: [picture]date: 2014-06-02 10:36:02type: "picture"comments: false---&#123;% gp 5-3 %&#125;![](http://oapjp6spr.bkt.clouddn.com/18210.jpg)![](http://oapjp6spr.bkt.clouddn.com/196232.jpg)![](http://oapjp6spr.bkt.clouddn.com/224147.jpg)![](http://oapjp6spr.bkt.clouddn.com/199301.jpg)![](http://oapjp6spr.bkt.clouddn.com/213318.jpg)&#123;% endgp %&#125;]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Next+Hexo</tag>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO+GitHub,搭建博客 - 配置]]></title>
    <url>%2Fhexo1%2F</url>
    <content type="text"><![CDATA[本篇文章主要介绍怎样利用 Hexo + Next 在 GitHub 上搭建个人博客。 简介&nbsp;&nbsp;Hexo 是一个快速、简洁且高效的静态站点生成框架，基于 Node.js 。 它有以下特点： 超快速度Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。 支持MarkdownHexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。 一件部署只需一条指令即可部署到Github Pages，或其他网站 丰富的插件Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 Markdown 本身的语法之外，还可以使用 Hexo 提供的 标签插件 来快速的插入特定形式的内容。 基于 Hexo 这个优秀的博客框架，很多优秀的开发者奉献出了它们基于 Hexo 开发的主题。NexT 因其 &nbsp; 精于心，简于形 &nbsp; 的风格，一直被广大用户所喜爱。 准备工作安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序: Node.jsGit 如果您的电脑中已经安装上述必备程序，跳过这一步。如果你的电脑中尚未安装所需要的程序，请根据以下安装指示完成安装。 安装 Git Windows：下载安装 git 。 Download Now Mac：使用 Homebrew，MacPorts 或下载 安装程序 安装 Linux（Ubuntu，Debian）：sudo apt-get install git-core Linux（Fedora，Red Hat，CentOS）：sudo yum install git-core 安装 Node.js安装 Node.js 的最佳方式是使用 nvm。（nvm：Node Version Manager）windows 下使用 nvm 请看这里： nvm-windows ，首先需要下载安装 nvm 。 Download Now windows下安装完nvm以后，我们可以打开命令行中执行命令$ nvm$ nvm install latest 执行完以后，重启命令行，执行命令 node -v ，如果出现版本号，那么 Node.js 就安装成功了。 如果没有安装成功，那可能就是墙的原因。建议下载 Node.js 直接安装。 Download Now 安装Hexo有了 Node.js ，我们可以使用 npm 安装 Hexo。（执行完以后，我们同样可以执行命令 hexo -v 查看是否安装成功就安装成功了。）$ npm install -g hexo-cli Hexo安装完成后，我们需要为我们的blog项目创建一个指定文件夹（例如我在 D 盘根目录下创建了一个文件夹 blog 。D:\blog ），在该文件夹中执行以下命令， Hexo 将会在指定文件夹中新建所需要的文件。$ hexo init$ npm install 等待安装，安装完成后，指定文件夹 的目录如下：├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── 继续执行命令$ hexo g //编译$ hexo s --debug //开启本地服务 这个时候，我们在浏览器中访问 http://localhost:4000/ ，就可以看到基于 Hexo 的默认主题的原型： 到目前为止我们的本地博客已经部署完成。下面我们换上Next主题。 使用Next主题下载 NexT 主题依旧是在当前目录下，使用 Git checkout 代码：$ git clone https://github.com/iissnan/hexo-theme-next themes/next 等待下载完成。 启用 NexT 主题打开 站点配置文件 (Hexo文件夹下的_config.yml文件)，找到 theme 字段，并将其值更改为 next 。到此， NexT 主题安装完成。下一步我们依次执行以下命令验证主题是否正确启用。 $ hexo clean$ hexo g$ hexo s 我们在浏览器中访问 http://localhost:4000/ ，你将看到： 总结本地调试三部曲：$ hexo clean$ hexo g$ hexo s --debug 这种带debug的运行，如果出现错误，可以在命令行中看到错误提示信息。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Next+Hexo</tag>
        <tag>博客搭建</tag>
      </tags>
  </entry>
</search>