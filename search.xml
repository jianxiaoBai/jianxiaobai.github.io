<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python]]></title>
    <url>%2Fpython%2F</url>
    <content type="text"><![CDATA[#开头，注释 缩进的语句视为代码块 大小写敏感 数据类型和变量 True 和 False 首字母大写 and、or 和 not 空值：None 字符串格式化% %d 整数 %f 浮点数 %s 字符串 %x 十六进制整数 补位 &gt;&gt;&gt; '%2d-%02d' % (3, 1)' 3-01'&gt;&gt;&gt; '%.2f' % 3.1415926'3.14' 数组：list 和 tuple list 数组 len(list)得到长度 list[-2]获得倒数第二个元素 list.append(ele)往 list 中追加元素到末尾 list.insert(1, ele)，把元素插入到指定的位置，比如索引号为 1 的位置 list.pop()，删除 list 末尾的元素，用 pop()方法 list.pop(i)删除指定位置的元素，用 pop(i)方法，其中 i 是索引位置 元素的数据类型也可以不同，L = [‘Apple’, 123, True] tuple 数组：classmates = (‘Michael’, ‘Bob’, ‘Tracy’) tuple 一旦初始化就不能修改，代码更安全 条件判断和循环 if elif else for in while range()函数 &gt;&gt;&gt; range(1,5) #代表从1到5(不包含5)[1, 2, 3, 4]&gt;&gt;&gt; range(1,5,2) #代表从1到5，间隔2(不包含5)[1, 3]&gt;&gt;&gt; range(5) #代表从0到5(不包含5)[0, 1, 2, 3, 4] raw_inpit(str)读取的内容永远以字符串的形式返回 dict 和 set dict 就是 map，用 key-value 的形式存储。 d = &#123;'Michael': 95, 'Bob': 75, 'Tracy': 85&#125; 根据 key 获得 value []：一旦 key 不存在就会报错 get()函数：如果 key 不存在，可以返回 None，或者自己指定的 value（作为第二个参数传入） ‘Thomas’ in d 如果不存在则返回 False set 是一组 key 的集合，但不存储 value，key 不能重复。 需要 list 作为输入 add(key)函数用来往里面添加元素，自动忽略重复 remove(key)函数用来删除元素 &amp;操作用来做交集 |操作用来做并集 函数所有内置函数 类型检查 isinstance 可变参数 * 关键字参数 ** , 参数定义的顺序必须 默认参数def power(x, n = 2): s = 1 while n &gt; 0: n = n - 1 s = s * x return s 定义默认参数要牢记一点：默认参数必须指向不变对象！ 可变参数a = [2, 3, 5]def calc(*numbers): sum = 0 for n in numbers: sum = sum + n * n return sumcalc(2, 3, 5) # 10calc(*a) # 10 关键参数extra = &#123;'city': 'Beijing', 'job': 'Engineer'&#125;def person(name, age, **kw): print('name:', name, 'age:', age, 'other:', kw)&gt;&gt;&gt; person('Michael', 30)# name: Michael age: 30 other: &#123;&#125;&gt;&gt;&gt; person('Adam', 45, gender = 'M', job = 'Engineer')# name: Adam age: 45 other: &#123;'gender': 'M', 'job': 'Engineer'&#125;&gt;&gt;&gt; person('Jack', 24, city = extra['city'], job = extra['job'])# name: Jack age: 24 other: &#123;'city': 'Beijing', 'job': 'Engineer'&#125;&gt;&gt;&gt; person('Jack', 24, **extra)# name: Jack age: 24 other: &#123;'city': 'Beijing', 'job': 'Engineer'&#125; kw 获得的 dict 是 extra 的一份拷贝，对 kw 的改动不会影响到函数外的 extra。 命名关键字参数*号 后面的参数被视为 命名关键字参数 def person(name, age, *, city = 'shanghai', job): # 没有 city 和 job 字段或多了其他字段则会报错 print(name, age, city, job)person('Jack', 24, city='Beijing', job='Engineer')# Jack 24 Beijing Engineer 如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符 * 了： def person(name, age, *args, city, job): print(name, age, args, city, job)person('张三', 12, 213, city='北京', job='frontEnd')# 张三 12 (12, 213) 北京 frontEnd 如果没有 可变参数，就必须加一个 * 作为特殊分隔符。如果缺少*，Python 解释器将无法识别 位置参数 和 命名关键字参数 参数组合在 Python 中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这 5 种参数都可以组合使用。 但是请注意，参数定义的顺序必须是： 必选参数 默认参数 x = 5 可变参数 *num 命名关键字参数 **ak 关键字参数 * (如存在可变参数则不需声明) 定义空函数def nop(): pass pass 可以用来作为占位符 高级特性切片（Slice ）&gt;&gt;&gt; L = ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack']&gt;&gt;&gt; L[0:3]['Michael', 'Sarah', 'Tracy'] L[0:3] 表示，从索引 0 开始取，直到索引 3 为止，但不包括索引 3。即索引 0，1，2，正好是 3 个元素。 如果第一个索引是 0，还可以省略。 L[-1] 取倒数第一个元素，也支持倒数切片：L(-2:) 只写[:] 就可以原样复制一个 list L[:10:2] 表示前十个元素，每两个取一个：[0,2,4,6,8] L[:10:2] 前 10 个数，每两个取一个 L[::5] 所有数，每 5 个取一个： tuple 也可以用切片，操作结果也是 tuple 字符串也支持切片 迭代（Iteration） 只要是可迭代对象（list，tuple，dict，set，字符串）都可以用 for…in…迭代 默认情况下，dict 迭代的是 key。 如果要迭代 value，可以用 for value in d.itervalues() 如果要同时迭代 key 和 value，可以用 for k, v in d.iteritems()。 判断一个对象是否是可迭代对象： from collections import Iterableisinstance('abc', Iterable) # str是否可迭代 Trueisinstance([1,2,3], Iterable) # list是否可迭代 Trueisinstance(123, Iterable) # 整数是否可迭代 False 拥有下标的循环： for i, value in enumerate(['A', 'B', 'C']): print i, value for 循环同时引用两个变量： for x, y in [(1, 1), (2, 4), (3, 9)]: print x, y 列表生成式（List Comprehensions） [x * x for x in range(1, 11)] =&gt; [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 加上判断：[x * x for x in range(1, 11) if x % 2 == 0] =&gt; [4, 16, 36, 64, 100] 两层循环（可以用来生成全排列）：[m + n for m in ‘ABC’ for n in ‘XYZ’] =&gt; [‘AX’, ‘AY’, ‘AZ’, ‘BX’, ‘BY’, ‘BZ’, ‘CX’, ‘CY’, ‘CZ’] 生成器（Generator） 在 Python 中，这种一边循环一边计算的机制，称为生成器：generator。 生成器里面装了用来生成一个 list 的算法，这样就不必创建完整的 list，从而大量的节省空间。 如何创建 generator 把列表生成的 [] 改成 () 函数内使用 yield g = (x * x for x in range(3))g.next() # 0g.next() # 1g.next() # 4g.next() # StopIterationfor n in g: print n 定义 generator 的另一种方法，yield： def fib(max): n, a, b = 0, 0, 1 while n &lt; max: yield b a, b = b, a + b n = n + 1 return 'done' 如果一个函数定义中包含 yield 关键字，那么这个函数就不再是一个普通函数，而是一个 generator 可以直接使用 for 循环来迭代, 但是那样获取不到返回值, 必须使用捕获 StopIteration 错误, 返回值包含在 StopIteration 的 value 中： g = fib(6)while True: try: x = next(g) print('g:', x) except StopIteration as e: print('Generator return value:', e.value) break# g: 1# ...# Generator return value: done Generator 的执行顺序generator 函数在每次调用 next()时时候执行到 yield 语句返回，再次执行时从上次返回的 yield 语句处继续执行。 def odd(): print('step 1') yield 1 print('step 2') yield(3) print('step 3') yield(5)o = odd()&gt;&gt;&gt; next(o)# step 1# 返回值 1&gt;&gt;&gt; next(o)# step 2# 返回值 3&gt;&gt;&gt; next(o)# step 3# 返回值 5 迭代器 凡是可作用于 for 循环的对象都是 Iterable 类型； 凡是可作用于 next()函数的对象都是 Iterator 类型，它们表示一个惰性计算的序列； list =&gt; []、dict =&gt; {}、str = ‘aaa’ 是 Iterable 但不是 Iterator 非 Iterator 可以通过 iter() 函数获得一个该对象。 模块mycompany├─ __init__.py├─ abc.py└─ xyz.py 引入了包以后，只要顶层的包名不与别人冲突，那所有模块都不会与别人冲突。现在，abc.py 模块的名字就变成了 mycompany.abc，类似的，xyz.py 的模块名变成了 mycompany.xyz。 每一个包目录下面都 必须有一个 __init__.py 的文件，否则，Python 就把这个目录当成普通目录，而不是一个包。__init.py__ 可以是空文件，也可以有 Python 代码，因为__init.py__ 本身就是一个模块，而它的模块名就是 mycompany。 类似的，可以有多级目录，组成多级层次的包结构。比如如下的目录结构： mycompany ├─ web │ ├─ __init__.py │ ├─ utils.py │ └─ www.py ├─ __init__.py ├─ abc.py └─ xyz.py 文件 www.py 的模块名就是 mycompany.web.www，两个文件 utils.py 的模块名分别是 mycompany.utils 和 mycompany.web.utils。 模块是一组 Python 代码的集合，可以使用其他模块，也可以被其他模块使用。 创建自己的模块时，要注意： 模块名要遵循 Python 变量命名规范，不要使用中文、特殊字符； 模块名不要和系统模块名冲突，最好先查看系统是否已存在该模块，检查方法是在 Python 交互环境执行 import abc，若成功则说明系统存在此模块。 模块模板#!/usr/bin/env python3 # 可以让这个hello.py文件直接在Unix/Linux/Mac上运行# -*- coding: utf-8 -*- # 文件本身使用标准UTF-8编码；' a test module ' # 任何模块代码的第一行字符串都被视为模块的文档注释；__author__ = 'Michael Liao' # 把作者写进去，这样当你公开源代码后别人就可以瞻仰你的大名# 以上就是Python模块的标准文件模板import sysdef test(): args = sys.argv if len(args)==1: print('Hello, world!') elif len(args)==2: print('Hello, %s!' % args[1]) else: print('Too many arguments!')# 当我们在 命令行运行 hello 模块文件时，Python 解释器把一个特殊变量 __name__ 置为 __main__# 也就是下面的这个 if 只有用命令行运行才会执行if __name__=='__main__': test() 作用域 类似__xxx__这样的变量是特殊变量，可以被直接引用，但是有特殊用途，我们自己的变量一般不要用这种变量名； 类似_xxx 和 __xxx__ 这样的函数或变量就是非公开的（private），不应该被直接引用 private 函数或变量不应该被别人引用，那它们有什么用呢？请看例子： def _private_1(name): return 'Hello, %s' % namedef _private_2(name): return 'Hi, %s' % namedef greeting(name): if len(name) &gt; 3: return _private_1(name) else: return _private_2(name) 外部不需要引用的函数全部定义成 private，只有外部需要引用的函数才定义为 public 面向对象编程未完待续…]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>vim</tag>
        <tag>基本操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux 笔记]]></title>
    <url>%2Flinux%2F</url>
    <content type="text"><![CDATA[系统结构目录 目录路径 作用 /usr： 用户的很多应用程序和文件都放在此目录下。 /usr/bin： 系统用户 使用的应用程序。 /usr/sbin： 超级用户 使用的比较高级的管理程序和系统守护程序。 /usr/src： 内核源代码默认的放置目录。 /home： 用户的主目录，该目录名一般是以用户的账号命名的。 /bin： Binary 的缩写, 存放着最经常使用的终端命令。 /root： 该目录为系统管理员，也称作 超级权限者 的用户主目录。 /boot： 启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。 /etc： 存放所有的系统管理所需要的 配置文件 和子目录。 /dev ： Device (设备)的缩写, 该目录下存放的是Linux的外部设备 /proc： 一个映射 系统内存 的虚拟目录，可以通过直接访问此目录获取系统信息。 /sbin： 存放 系统管理员 使用的系统管理程序。 /tmp： 存放一些临时文件的。 /var： 不断扩充或者 经常被修改 的文件会存放在此目录下，比如各种日志文件。 /media： Linux 会把识别的设备挂载到这个目录下。 /lost+found： 当系统非法关机后，这里就存放了一些文件。 /lib： 存放系统最基本的动态连接共享库。几乎所有的应用程序都需要用到这些共享库。 /mnt： 该目录是为了让用户临时挂载其他文件系统的，可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。 /opt： 这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。 /selinux： 这个目录是Redhat/CentOS所特有的目录，Selinux是一个安全机制，类似于windows的防火墙。 /srv： 该目录存放一些服务启动之后需要提取的数据。 /sys： 该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。 网卡与 IP 知识点 网卡 是一个专门负责 网络通讯 的硬件设备 IP 地址 是设置在网卡上的 地址信息, 是保证电脑之间正常通讯的重要设置 127.0.0.1 被称为 本地回环/环回地址，一般用来测试本机网卡是否正常 ping 一般用于检测当前计算机到目标计算机之间的网络 是否通畅 &lt;!-- 可以这样类比: --&gt;电脑 =&gt; 电话网卡 =&gt; SIM 卡IP =&gt; 电话号码ping =&gt; 电话能不能打通 tips：一台计算机中有可能会有一个 物理网卡 和 多个虚拟网卡，在 Linux 中物理网卡的名字通常以 ensXX 表示 SSH 基础在 Linux 中 SSH 是 非常常用 的工具，通过 SSH 客户端 我们可以连接到运行了 SSH 服务器 的远程机器上 SSH 客户端是一种使用 Secure Shell（SSH） 协议连接到远程计算机的软件程序 SSH 是目前较可靠，专为远程登录会话和其他网络服务 提供安全性的协议 利用 SSH 协议 可以有效防止远程管理过程中的信息泄露 通过 SSH 协议 可以对所有传输的数据进行加密，也能够防止 DNS 欺骗和 IP 欺骗 SSH 的另一项优点是传输的数据可以是经过压缩的，所以可以加快传输的速度 域名 由一串 用点分隔 的名字组成，例如：www.itcast.cn 是 IP 地址 的别名，方便用户记忆 端口号 IP 地址：通过 IP 地址 找到网络上的 计算机 端口号：通过 端口号 可以找到 计算机上运行的应用程序 SSH 服务器 的默认端口号是 22，如果是默认端口号，在连接的时候，可以省略 常见服务端口号列表： 服务 端口号 SSH 服务器 22 Web 服务器 80 HTTPS 443 FTP 服务器 21 客户端的简单使用ssh [-p port] user@remote user 是在远程机器上的用户名，如果不指定的话默认为当前用户 remote 是远程机器的地址，可以是 IP／域名，或者是 后面会提到的别名 port 是 SSH Server 监听的端口，如果不指定，就为默认值 22 在工作中，SSH 服务器的端口号很有可能不是 22，如果遇到这种情况就需要使用 -p 选项，指定正确的端口号，否则无法正常连接到服务器 SSH 高级 免密码登录 配置别名 提示：有关 SSH 配置信息都保存在用户家目录下的 .ssh 目录下 免密码登录步骤 配置公钥 执行 ssh-keygen 即可生成 SSH 钥匙，一路回车即可 上传公钥到服务器 执行 ssh-copy-id -p port user@remote，可以让远程服务器记住我们的公钥 示意图 配置别名每次都输入 ssh -p port user@remote，时间久了会觉得很麻烦，特别是当 user, remote 和 port 都得输入，而且还不好记忆 而 配置别名 可以让我们进一步偷懒，譬如用：ssh mac 来替代上面这么一长串，那么就在 ~/.ssh/config 里面追加以下内容： Host mac HostName ip地址 User itheima Port 22 保存之后，即可用 ssh mac 实现远程登录了，scp 同样可以使用 SCP 基础 scp 就是 secure copy，是一个在 Linux 下用来进行 远程拷贝文件 的命令 它的地址格式与 ssh 基本相同，需要注意的是，在指定端口时用的是大写的 -P 而不是小写的 # 把本地当前目录下的 01.py 文件 复制到 远程 家目录下的 Desktop/01.py# 注意：`:` 后面的路径如果不是绝对路径，则以用户的家目录作为参照路径scp -P port 01.py user@remote:Desktop/01.py# 把远程 家目录下的 Desktop/01.py 文件 复制到 本地当前目录下的 01.pyscp -P port user@remote:Desktop/01.py 01.py# 加上 -r 选项可以传送文件夹# 把当前目录下的 demo 文件夹 复制到 远程 家目录下的 Desktopscp -r demo user@remote:Desktop# 把远程 家目录下的 Desktop 复制到 当前目录下的 demo 文件夹scp -r user@remote:Desktop demo 选项 含义 -r 若给出的源文件是目录文件，则 scp 将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名 -P 若远程 SSH 服务器的端口不是 22，需要使用大写字母 -P 选项指定端口 scp 这个终端命令只能在 Linux 或者 UNIX 系统下使用 用户权限相关命令基本概念 用户 是 Linux 系统工作中重要的一环，用户管理包括 用户 与 组 管理 在 Linux 系统中，不论是由本机或是远程登录系统，每个系统都必须拥有一个账号，并且对于不同的系统资源拥有不同的使用权限 在 Linux 中，可以指定 每一个用户 针对 不同的文件或者目录 的 不同权限 对 文件／目录 的权限包括： 序号 权限 英文 缩写 数字代号 01 读 read r 4 02 写 write w 2 03 执行 excute x 1 组 为了方便用户管理，提出了 组 的概念，如下图所示 在实际应用中，可以预先针对 组 设置好权限，然后 将不同的用户添加到对应的组中，从而不用依次为每一个用户设置权限 ls -l 扩展 ls -l 可以查看文件夹下文件的详细信息，从左到右依次是： 权限，第 1 个字符如果是 d 表示目录 硬链接数，通俗地讲，就是有多少种方式，可以访问到当前目录／文件 拥有者，家目录下 文件／目录 的拥有者通常都是当前用户 组，在 Linux 中，很多时候，会出现组名和用户名相同的情况，后续会讲 大小 时间 名称 chmod 简单使用（重要） chmod 可以修改 用户／组 对 文件／目录 的权限 命令格式如下： chmod +/-rwx 文件名|目录名 提示：以上方式会一次性修改 拥有者 / 组 权限，有关 chmod 的高级用法，后续会讲 超级用户 Linux 系统中的 root 账号通常 用于系统的维护和管理，对操作系统的所有资源 具有所有访问权限 在大多数版本的 Linux 中，都不推荐 直接使用 root 账号登录系统 在 Linux 安装的过程中，系统会自动创建一个用户账号，而这个默认的用户就称为“标准用户” sudo su 是 substitute user 的缩写，表示 使用另一个用户的身份 sudo 命令用来以其他身份来执行命令，预设的身份为 root 用户使用 sudo 时，必须先输入密码，之后有 5 分钟的有效期限，超过期限则必须重新输入密码 若其未经授权的用户企图使用 sudo，则会发出警告邮件给管理员 组管理 终端命令 提示：创建组 / 删除组 的终端命令都需要通过 sudo 执行 命令 作用 groupadd 组名 添加组 groupdel 组名 删除组 cat /etc/group 确认组信息 chgrp -R 组名 文件/目录名 递归修改文件/目录的所属组 提示： 组信息保存在 /etc/group 文件中 /etc 目录是专门用来保存 系统配置信息 的目录 在实际应用中，可以预先针对 组 设置好权限，然后 将不同的用户添加到对应的组中，从而不用依次为每一个用户设置权限 演练目标 在 python 用户的桌面文件夹下创建 Python学习 目录 新建 dev 组 将 Python学习 目录的组修改为 dev 用户管理 终端命令 提示：创建用户 / 删除用户 / 修改其他用户密码 的终端命令都需要通过 sudo 执行 创建用户／设置密码／删除用户 命令 作用 说明 useradd -m -g 组 新建用户名 添加新用户 -m 自动建立用户家目录-g 指定用户所在的组，否则会建立一个和同名的组 passwd 用户名 设置用户密码 如果是普通用户，直接用 passwd 可以修改自己的账户密码 userdel -r 用户名 删除用户 -r 选项会自动删除用户家目录 cat /etc/passwd &#124; grep 用户名 确认用户信息 新建用户后，用户信息会保存在 /etc/passwd 文件中 创建用户时，如果忘记添加 -m 选项指定新用户的家目录 —— 最简单的方法就是删除用户，重新创建 创建用户时，默认会创建一个和用户名同名的组名 用户信息保存在 /etc/passwd 文件中 查看用户信息 序号 命令 作用 01 id [用户名] 查看用户 UID 和 GID 信息 02 who 查看当前所有登录的用户列表 03 whoami 查看当前登录用户的账户名 passwd 文件/etc/passwd 文件存放的是用户的信息，由 6 个分号组成的 7 个信息，分别是 用户名 密码（x，表示加密的密码） UID（用户标识） GID（组标识） 用户全名或本地帐号 家目录 登录使用的 Shell，就是登录之后，使用的终端命令，ubuntu 默认是 dash usermod usermod 可以用来设置 用户 的 主组 ／ 附加组 和 登录 Shell，命令格式如下： 主组：通常在新建用户时指定，在 etc/passwd 的第 4 列 GID 对应的组 附加组：在 etc/group 中最后一列表示该组的用户列表，用于指定 用户的附加权限 提示：设置了用户的附加组之后，需要重新登录才能生效！ # 修改用户的主组（passwd 中的 GID）usermod -g 组 用户名# 修改用户的附加组usermod -G 组 用户名# 修改用户登录 Shellusermod -s /bin/bash 用户名 注意：默认使用 useradd 添加的用户是没有权限使用 sudo 以 root 身份执行命令的，可以使用以下命令，将用户添加到 sudo 附加组中 usermod -G sudo 用户名 which（重要） 提示 /etc/passwd 是用于保存用户信息的文件 /usr/bin/passwd 是用于修改用户密码的程序 which 命令可以查看执行命令所在位置，例如： which ls# 输出# /bin/lswhich useradd# 输出# /usr/sbin/useradd bin 和 sbin 在 Linux 中，绝大多数可执行文件都是保存在 /bin、/sbin、/usr/bin、/usr/sbin /bin（binary）是二进制执行文件目录，主要用于具体应用 /sbin（system binary）是系统管理员专用的二进制代码存放目录，主要用于系统管理 /usr/bin（user commands for applications）后期安装的一些软件 /usr/sbin（super user commands for applications）超级用户的一些管理程序 提示： cd 这个终端命令是内置在系统内核中的，没有独立的文件，因此用 which 无法找到 cd 命令的位置 切换用户 序号 命令 作用 说明 01 su - 用户名 切换用户，并且切换目录 - 可以切换到用户家目录，否则保持位置不变 02 exit 退出当前登录账户 su 不接用户名，可以切换到 root，但是不推荐使用，因为不安全 exit 示意图如下： 修改文件权限 命令 作用 chown 修改拥有者 chgrp 修改组 chmod 修改权限 命令格式如下： # 修改文件|目录的拥有者chown 用户名 文件名|目录名# 递归修改文件|目录的组chgrp -R 组名 文件名|目录名# 递归修改文件权限chmod -R 755 文件名|目录名 chmod 在设置权限时，可以简单地使用三个数字分别对应 拥有者 ／ 组 和 其他 用户的权限 # 直接修改文件|目录的 读|写|执行 权限，但是不能精确到 拥有者|组|其他chmod +/-rwx 文件名|目录名 常见数字组合有（u表示用户／g表示组／o表示其他）： 777 ===&gt; u=rwx,g=rwx,o=rwx 755 ===&gt; u=rwx,g=rx,o=rx 644 ===&gt; u=rw,g=r,o=r chmod 演练目标 将 01.py 的权限修改为 u=rwx,g=rx,o=r 将 123.txt 的权限修改为 u=rw,g=r,o=- 将 test 目录以及目录下的 所有 文件权限修改为 u=rwx,g=rwx,o=rx 系统信息相关命令时间和日期 命令 作用 date 查看系统时间 cal calendar 查看日历，-y 选项可以查看一年的日历 磁盘信息 命令 作用 df -h disk free 显示磁盘剩余空间 du -h [目录名] disk usage 显示目录下的文件大小 选项说明 参数 含义 -h 以人性化的方式显示文件大小 进程信息 所谓 进程，通俗地说就是 当前正在执行的一个程序 命令 作用 ps aux process status 查看进程的详细状况 top 动态显示运行中的进程并且排序 kill [-9] 进程代号 终止指定代号的进程，-9 表示强行终止 ps 默认只会显示当前用户通过终端启动的应用程序 ps 选项说明 选项 含义 a 显示终端上的所有进程，包括其他用户的进程 u 显示进程的详细状态 x 显示没有控制终端的进程 提示：使用 kill 命令时，最好只终止由当前用户开启的进程，而不要终止 root 身份开启的进程，否则可能导致系统崩溃 &gt; 要退出 top 可以直接输入 q 其他命令查找文件 find 命令功能非常强大，通常用来在 特定的目录下 搜索 符合条件的文件 命令 作用 find [路径] -name “*.py” 查找指定路径下扩展名是 .py 的文件，包括子目录 如果省略路径，表示在当前文件夹下查找 之前学习的通配符，在使用 find 命令时同时可用 有关 find 的高级使用，在就业班会讲 演练目标 搜索桌面目录下，文件名包含 1 的文件 find -name "*1*" 搜索桌面目录下，所有以 .txt 为扩展名的文件 find -name "*.txt" 搜索桌面目录下，以数字 1 开头的文件 find -name "1*" 02. 软链接 序号 命令 作用 01 ln -s 被链接的源文件 链接文件 建立文件的软链接，用通俗的方式讲类似于 Windows 下的快捷方式 注意： 没有 -s 选项建立的是一个 硬链接文件 两个文件占用相同大小的硬盘空间，工作中几乎不会建立文件的硬链接 源文件要使用绝对路径，不能使用相对路径，这样可以方便移动链接文件后，仍然能够正常使用 演练目标 将桌面目录下的 01.py 移动到 demo/b/c 目录下 在桌面目录下新建 01.py 的 软链接 FirstPython 分别使用 相对路径 和 绝对路径 建立 FirstPython 的软链接 将 FirstPython 移动到 demo 目录下，对比使用 相对路径 和 绝对路径 的区别 硬链接简介（知道） 在使用 ln 创建链接时，如果没有 -s 选项，会创建一个 硬链接，而不是软链接 硬链接演练 在 ~/Desktop/demo 目录下建立 ~/Desktop/demo/b/c/01.py 的硬链接 01_hard 使用 ls -l 查看文件的硬链接数（硬链接——有多少种方式可以访问文件或者目录） 删除 ~/Desktop/demo/b/c/01.py，并且使用 tree 来确认 demo 目录下的三个链接文件 文件软硬链接的示意图 在 Linux 中，文件名 和 文件的数据 是分开存储的 提示： 在 Linux 中，只有文件的 硬链接数 == 0 才会被删除 使用 ls -l 可以查看一个文件的硬链接的数量 在日常工作中，几乎不会建立文件的硬链接，知道即可 打包压缩 打包压缩 是日常工作中备份文件的一种方式 在不同操作系统中，常用的打包压缩方式是不同的 Windows 常用 rar Mac 常用 zip Linux 常用 tar.gz 打包 ／ 解包 tar 是 Linux 中最常用的 备份工具，此命令可以 把一系列文件 打包到 一个大文件中，也可以把一个 打包的大文件恢复成一系列文件 tar 的命令格式如下： # 打包文件tar -cvf 打包文件.tar 被打包的文件／路径...# 解包文件tar -xvf 打包文件.tar tar 选项说明 选项 含义 c 生成档案文件，创建打包文件 x 解开档案文件 v 列出归档解档的详细过程，显示进度 f 指定档案文件名称，f 后面一定是 .tar 文件，所以必须放选项最后 注意：f 选项必须放在最后，其他选项顺序可以随意 打包解包演练 删除桌面下的所有内容 在桌面下新建三个空白文件 01.py、02.py、03.py 将这三个文件打一个 py.tar 的包 新建 tar 目录，并且将 py.tar 移动到 tar 目录下 解包 py.tar 压缩／解压缩gzip tar 与 gzip 命令结合可以使用实现文件 打包和压缩 tar 只负责打包文件，但不压缩 用 gzip 压缩 tar 打包后的文件，其扩展名一般用 xxx.tar.gz 在 Linux 中，最常见的压缩文件格式就是 xxx.tar.gz 在 tar 命令中有一个选项 -z 可以调用 gzip，从而可以方便的实现压缩和解压缩的功能 命令格式如下： # 压缩文件tar -zcvf 打包文件.tar.gz 被压缩的文件／路径...# 解压缩文件tar -zxvf 打包文件.tar.gz# 解压缩到指定路径tar -zxvf 打包文件.tar.gz -C 目标路径 选项 含义 -C 解压缩到指定目录，注意：要解压缩的目录必须存在 bzip2(two) tar 与 bzip2 命令结合可以使用实现文件 打包和压缩（用法和 gzip 一样） tar 只负责打包文件，但不压缩， 用 bzip2 压缩 tar 打包后的文件，其扩展名一般用 xxx.tar.bz2 在 tar 命令中有一个选项 -j 可以调用 bzip2，从而可以方便的实现压缩和解压缩的功能 命令格式如下： # 压缩文件tar -jcvf 打包文件.tar.bz2 被压缩的文件／路径...# 解压缩文件tar -jxvf 打包文件.tar.bz2 软件安装通过 apt 安装／卸载软件 apt 是 Advanced Packaging Tool，是 Linux 下的一款安装包管理工具 可以在终端中方便的 安装／卸载／更新软件包 # 1. 安装软件$ sudo apt install 软件包# 2. 卸载软件$ sudo apt remove 软件名# 3. 更新已安装的包$ sudo apt upgrade 安装演练# 一个小火车提示$ sudo apt install sl# 一个比较漂亮的查看当前进程排名的软件$ sudo apt install htop 压缩解压 tar如果要在服务器之间发送大量数据，肯定少不了压缩和解压这两步，但是 tar 这个命令的参数之多，让我很绝望，于是我发明了一个简单的记忆方法。 使用 tar 命令只要记得参数是『必选+自选+f』即可，我们先来看看『必选！五选一』:-c 意为 create，表示创建压缩包-x 意为 extract，表示解压-t 表示查看内容-r 给压缩包追加文件-u 意为 update，更新压缩包中的文件 注意了，上面是一定要五选一的，不能一个都不选，也不能同时选俩。但是自选的部分就可以按照需要挑选了，比如： -z 使用 gzip 属性-j 使用 bz2 属性-Z 使用 compress 属性-v 意为 verbose，显示详细的操作过程-O 将文件输出到标准输出 然后最后一个一定要是 f 后面跟压缩包名（无论是要解压还是要压缩，都是指压缩包的名字）。接下来我们看看具体实例，就很容易理解具体的用法了。 # 假设我们有很多 .md 文件需要打包，那么可以使用tar -cf posts.tar *.md # c 是创建压缩包，也就是压缩，然后是 f，给出压缩包名，最后是要压缩的文件# 然后我们发现还有一些 .txt 文件也需要打包进去，那么可以使用tar -rf posts.tar *.txt # r 是追加文件# 然后我们发现 hello.md 弄错了，修正后需要更新到压缩包中，可以使用tar -uf post.tar hello.md # u 是更新# 压缩好了，我们来看看压缩包的内容，可以使用tar -tf posts.tar # t 是列出文件内容# 把压缩包发送到其他位置之后，需要解压，可以使用tar -xf posts.tar # x 是解压加入自选参数后的用法（要不要加 v 可以看个人喜好） tar.gz 相关tar -czf posts.tar.gz *.md # 压缩tar -xzf posts.tar.gz # 解压 tar.bz2 相关tar -cjf posts.tar.bz2 *.md # 压缩tar -xjf posts.tar.bz2 # 解压 tar.Z 相关tar -cZf posts.tar.Z *.md # 压缩tar -xZf posts.tar.Z # 解压 总结一波，遇到不同类型的文件，请用不同的套路来应对： .tar -&gt; tar -xf .tar.gz -&gt; tar -xzf .tar.bz2 -&gt; tar -xjf .tar.Z -&gt; tar -xZf .gz -&gt; gzip -d .rar -&gt; unrar e .zip -&gt; unzip 空间占用 du很多时候磁盘被写满了是各种奇怪错误的源头，所以如何快速找到问题所在就很重要了， # 显示当前文件下 Top 10 空间占用的文件/目录，# s 表示不显示每个子目录或文件的大小# h 表示用更加自然的方式显示（比如 K/M/G 这样）du -sh * | sort -nr | head 系统状态 top了解系统状态一般少不了 top 命令，虽然基本上不需要做任何操作，但是还是有一些可以自定义的内容的，比如# 查看某用户的进程top -u wdxtub# 进入系统状态显示后，具体值代表的意思是# PR 进程优先级，越小优先级越高# VIRT 占用的虚拟内存# RES 占用的物理内存# SHR 占用的共享内存# S 进程状态（S - 休眠，R - 正在运行，Z - 僵死状态，N - 优先级为负数）# TIME+ 进程启动后占用的总 CPU 时间# 可以按照不同的指标排序显示，按对应键即可# P 按照 CPU 使用率排序# T 按照 MITE+ 排序# M 按内存使用占比排序 其他查看进程相关信息的命令有 # 查看进程内存分布pmap -d 12345 # 12345 是进程号# 按照内存排序，这里的 grep 可以过滤特定的用户ps -e -o &apos;pid,comm,srgs,pcpu,rsz,vsz,stime,user,uid&apos; | grep wdxtub | sort nrk5 查找 find在命令行界面中进行查找是每个需要在服务器上执行操作的同学都必备的技能，这里用实例来说明常见的实用用法 # 找出七天前的文件find / -type f -mtime +7 -print# / 表示从根目录中查找# -type f 表示找出系统普通文件，不包含目录# -mtime +n 表示寻找 n 天前的数据# -print 打印文件名称# 找出并删除七天前的文件find /temp/ -type f -mtime +7 -print -exec rm -f &#123;&#125; \;# -exec 表示后面执行系统命令# &#123;&#125; 只有该符号能跟在命令你后面# \; 结束符号find /temp/ -type f -mtime +7 -print | xargs rm -f# 使用管道和 xargs = -exec# 查找 /var 下最大的十个文件find /var -type f -ls | sort -k 7 -r -n | head# 查找 /var/log 下大于 5GB 的文件find /var/log/ -type f -size +5120M -exec ls -lh &#123;&#125; \;# 找出今天所有文件并将它们拷贝到另一个目录find /home/wdxtub/ -ctime 0 -print -exec cp &#123;&#125; /mnt/backup/&#123;&#125; \; 远程登录 ssh `ssh -vvv username@ip` ssh 的 debug 模式`ssh -i key.pem username@ip` 用 pem key 登录 ssh 奇技淫巧这里是一些比较零碎的命令行技巧 openssl rand -hex n 产生随机的十六进制数，n 是字符数source /path/to/filename 在当前 shell 里执行一个文件里的命令$&#123;variable:0:5&#125; 截取变量的前五个字符wget -r --no-parent --reject &quot;index.html*&quot; http://hostname/ -P /home/user/dirs 用 wget 抓取完整的网站目录结构，存放到本地目录中mkdir -p /home/wdxtub/&#123;test0,test1,test2&#125; 一次创建多个目录dd if=/dev/zero of=/tmp/output.img bs=8k count=256k; rm -rf /tmp/output.img 测试硬盘写入速度hdparm -Tt /dev/sda 测试硬盘读取速度echo -n &quot;test&quot; | md5sum 获取文本的 md5curl -I http://wdxtub.com 获取 HTTP 头信息netstat -tln4 | awk &apos;&#123;print $4&#125;&apos; | cut -f2 -d: | grep -o &apos;[0-9]*&apos; 显示所有 tcp4 监听端口time command 查看命令的运行时间export 查看所有的环境变量cmp file1 file2 文件内容对比cat -n file 内容前面会显示行号lsof -i:22 查看 22 端口现在运行的程序lsof -c abc 显示 abc 进程现在打开的文件lsof -p 12 看进程号为 12 的进程打开了哪些文件]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[以太坊 笔记]]></title>
    <url>%2Feth%2F</url>
    <content type="text"><![CDATA[常用操作eth.accounts =&gt; 查看账户personal.newAccount() =&gt; 创建账户eth.getBalance(eth.accounts[0]) =&gt; 查看余额miner.start(1) =&gt; 启动挖矿miner.stop() =&gt; 停止挖矿miner.start(1);admin.sleepBlocks(1);miner.stop(); =&gt; 挖矿后web3.fromWei(eth.getBalance(eth.accounts[1])) =&gt; 查看转换过后的数量geth init ./genesis.json --datadir ./data =&gt; 初始化geth --datadir ./data --nodiscover --networkid 1024 --rpc console =&gt; 启动geth --datadir ./data --nodiscover --networkid 1024 --rpc --rpccorsdomain=&quot;\*&quot; console =&gt; 启动时解决本地跨域问题 坑点 60000 * (5000000000 / 1e18) = 60000 * (gasLimit / 1e18) 计算打币需消耗的 eth 地址前面需要加上 0x 否则生成地址不一致的问题 chainId 不一致带来的交易失效问题 --rpccorsdomain=&quot;*&quot; 解决跨域的问题 批量打 true (动态设置 nonce 值) 通过 web3.eth.sendTransaction 发起交易可以记录 tx 交易值 ERC20 APIeth =&gt; 包含一些跟操作区块链相关的方法net =&gt; 包含以下查看p2p网络状态的方法admin =&gt; 包含一些与管理节点相关的方法miner =&gt; 包含启动&amp;停止挖矿的一些方法personal =&gt; 主要包含一些管理账户的方法txpool =&gt; 包含一些查看交易内存池的方法web3 =&gt; 包含了以上对象，还包含一些单位换算的方法 钱包概念以太坊系钱包名词有地址、密码、私钥、助记词、keystore。 若以银行账户为类比，这 5 个词分别对应内容如下： 地址 = 银行卡号密码 = 银行卡密码私钥 = 银行卡号+银行卡密码助记词 = 银行卡号+银行卡密码Keystore+密码 = 银行卡号+银行卡密码Keystore ≠ 银行卡号]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>以太坊</tag>
        <tag>智能合约</tag>
        <tag>去中心化</tag>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象]]></title>
    <url>%2Fjsrelearn%2F</url>
    <content type="text"><![CDATA[Object 对象基本概念JS 中其他所有对象都继承自Object对象，即那些对象都是Object的实例。Object对象的原生方法分成两类：本身和实例方法。 Object() 工具方法Object 本身是一个函数,可以把任意参数转换成对象,如果参数是对象则直接返回该参数,如果参数是原始类型的值, 则将其转为对应的包装对象的实例. Object 构造函数Object构造函数的首要用途，是直接通过它来生成新对象。 var obj = new Object(); // 通过构造函数生成新对象var obj = &#123;&#125;; // 字面量写法等价与前者 构造函数与工具方法基本一样,不同的地方是,Object(value) 是将值转换成对象,new Object() 是生成一个对象. Object 的静态方法 所谓“静态方法”，是指部署在Object对象自身的方法。 get相关操作 含义 Object.values(obj) 以数组形式返回对象的value(不含枚举) Object.keys(obj) 以数组形式返回对象的key(不含枚举) Object.getOwnPropertyNames(obj) 以数组形式返回对象的key(含枚举) 对象属性模型相关 含义 Object.getOwnPropertyDescriptor() 获取某个属性的描述对象。 Object.defineProperty() 通过描述对象，定义某个属性。 Object.defineProperties() 通过描述对象，定义多个属性。 控制对象状态 含义 Object.preventExtensions() 防止对象扩展。 Object.seal() 禁止对象配置。 Object.freeze() 冻结一个对象。 Object.isExtensible() 判断对象是否可扩展。 Object.isSealed() 判断一个对象是否可配置。 Object.isFrozen() 判断一个对象是否被冻结。 原型链相关 含义 Object.create() 该方法可以指定原型对象和属性，返回一个新的对象。 Object.getPrototypeOf() 获取对象的Prototype对象。 Object 的实例方法 方法 含义 Object.prototype.valueOf() 返回当前对象对应的值。 Object.prototype.toString() 返回当前对象对应的字符串形式。 Object.prototype.toLocaleString() 返回当前对象对应的本地字符串形式。 Object.prototype.hasOwnProperty() 判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。 in 运算符 &#39;length&#39; in Date 返回一个布尔值，表示一个对象是否具有某个属性, 不区分属性是自身还是来自继承 Object.prototype.isPrototypeOf() 判断当前对象是否为另一个对象的原型。 Object.prototype.propertyIsEnumerable() 判断某个属性是否可枚举。 Object.prototype.valueOf() 方法的主要用于是用于隐式转换, 当与数值相加时会用 toString() 方法得到本身值在进行计算 Object.prototype.toString() 方法作用是返回一个对象形式的字符串 toString() 的应用：判断数据类型 Object.prototype.toString 返回对象的类型字符串, 因此可以用来判断一个值的类型. 由于实例对象可能会自定义 toString 方法, 所以不会再去引用 Object.prototype 上的 toString 方法,所以为了得到类型字符串, 最好直接使用 Object.prototype.toString 方法.通过函数的 call 方法, 可以在任意值上调用这个方法, 帮助我们判断这个值得类型. Object.prototype.toString.call(2) // "[object Number]"Object.prototype.toString.call([]) // "[object Array]"...... 面向对象编程概念为什么要了解面向对象编程呢?因为要是不懂面向对象编程, 看框架的源码是很费劲的,而面向对象也是不容易掌握的, 其中最重要的一定就是抽象思维 把思维要打开。 对象是单个实物的抽象对象是一个容器, 封装了属性(property) 和方法(method) 构造函数面向对象编程的第一步，就是要生成对象。前面说过，对象是单个实物的抽象。通常需要一个模板，表示某一类实物的共同特征，然后对象根据这个模板生成。 JS 使用构造函数(constructor)作为对象的模板.所谓 “构造函数” ,就是专门用来生成实例对象的函数.他就是对象的一个模板,用来描述对象的基本结构.一个构造函数, 可以生成多个实例对象,这些实例对象都有相同的结构. 构造函数就是一个普通的函数, 但是有自己的特征和用法. var Vehicle = function () &#123; this.price = 1000;&#125; Vehicle 就是构造函数, 为了与普通函数的区别, 构造函数名字的第一个字母通常大写.构造函数的特点有俩个. 函数体内使用了 this 关键字, 代表了所要生成的对象实例 声称对象时必须使用 new 命令 new 命令 new 命令的作用, 就是执行构造函数, 返回一个实例对象. 如果忘了使用 new 命令, 直接调用构造函数时,构造函数就变成了普通函数, 并不会生成实例对象,而且构造函数内的 this 会指向 window,严格模式 this 默认指向 undefined 导致严格模式会出现错误 new 命令的原理使用 new 命令是, 它后面的函数一次执行下面的步骤. 创建一个空对象, 作为将要返回的对象实例. 将这个空对象的原型, 指向构造函数的 prototype 属性 将这个空对象赋值给函数内部的 this 关键字 开始执行构造函数内部的代码 如果对使用new命令的函数内部没有this关键字的话, 返回的就是一个空的对象.如果构造函数内部有return 语句并且是对象, 则直接返回该对象, 反之则忽略, 继续返回 this 对象. 函数内部可以使用 new.targe 属性来区分是否使用 new 命令. Object.create() 创建实例对象 构造函数作为模板, 可以生成实例对象. 但有时是拿不到构造函数, 只能拿到一个现有的对象.这时就可以使用 Object.create() 方法就可以继承现有对象的方法和属性到新的对象上. // 原型对象var A = &#123; print: function () &#123; console.log('hello'); &#125;&#125;;// 实例对象var B = Object.create(A);Object.getPrototypeOf(B) === A // trueB.print() // helloB.print === A.print // true prototype 对象 面向对象编程很重要的一个方面, 就是对象的继承.A 对象通过继承 B 对象, 就能直接拥有 B 对象的所有属性和方法.这对于代码的复用是非常有用的 prototype 属性的作用JavaScript 继承机制的设计思想就是,原型对象的所有属性和方法, 都能被实例对象共享.也就是说, 如果属性和方法定义在原型上,那么所有实例对象就能共享, 不仅节省了内存, 还体现了是实例对象之间的联系 构造函数的缺点构造函数中的方法每新建一个实例, 就会新建构造函数中的方法,这样既没有必要, 又浪费系统资源, 因为所有的构造函数中所有的方法都是同样的行为,所以应该共享, 可以通过 JS 的原型链实现该需求. 原型链JavaScript 规定, 所有对象都有自己的原型对象.一方面, 任何一个对象, 都可以充当其他对象的原型,另一方面, 由于原型对象也是对象, 所以它也有自己的原型.因此, 就会形成一个 “原型链”: 对象到原型, 再到原型的原型 如果一层一层的扒, 所有的原型追到底 都是 Object.prototype,就是 Object 的 prototype 属性. 也就是说 所有对象都集成了 Object.prototype 的属性.这也就是所有对象都有 valueOf 和 toString 方法的原因, 因为这是从 object.prototype 继承的. 那么这个顶级对象的原型有指向何处呢 ?答案是 null, null 没有任何属性和方法, 也没有自己的原型.因此, 原型链的尽头就是 null. Object.getPrototypeOf(Object.prototype) //null 读取对象的某个属性时, JavaScript 引擎会先从自身对象寻找,找不到就会去该属性对象的原型上去找, 以此类推到顶级对象,如果还是找不到则返回 undefined. 注意, 一层一层的在整个圆形脸上寻找某个属性,对性能是有影响的. 所寻找的属性在月上层的原型对象, 对性能的影响越大.如果寻找某个不存在的属性时, 将会遍历整个原型链. constructor 属性 prototype 对象有一个 constructor 属性, 默认指向 prototype 对所在的构造函数. instanceof 运算符 返回一个布尔值, 表示对象是否为某个构造函数的实例. this 关键字涵义this 可以用在构造函数之中, 表示实例对象.除此之外, this 还可以用在别的场合, this 都有一个共同点: 它总是返回一个对象 简单说, this 就是属性或方法 “当前” 所在的对象 var a = &#123; name: '张三', fn: function () &#123; console.log(this) &#125;&#125;a.fn()// &#123; name:'张三', fn: f &#125; 适用场合this 主要有以下几个使用场合 1.全局环境全局环境使用 this , 它指的就是顶层对象 window. 2.构造函数构造函数中的 this, 指的是实例对象. 3.对象的方法如果对象的方法里面包含 this, this 的只想就是方式运行时所在的对象.该方法赋值给另一个对象时就会改变 this 指向. this 使用注意点: 避免多层 this 避免数组处理方法中的 this 避免回调函数中的 this 绑定 this 的方法虽然 this 的切换为 js 提供了超高的灵活性，但同时也加大了代码的可阅读性和困难程度。有时就需要 将 this 固定下来， 避免出现意想不到的情况。JavaScript 中提供的三种方法， 分别是 call、apply、bind。 apply、call、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文； apply、call、bind 三者都可以利用后续参数传参； bind 是返回对应回调函数, 调用时改变其该bind函数的内部this Function.prototype.call()函数实例的 call 方法, 可以改变函数内部的 this 指向为 call 传入的第一个参数对象. call 方法的参数需要是一个对象, 如果参数是 null 或 undefined 那么默认传入全局对象 window var n = 123;var obj = &#123; n: 456 &#125;;function a() &#123; console.log(this.n);&#125;a.call() // 123a.call(null) // 123a.call(undefined) // 123a.call(window) // 123a.call(obj) // 456 call 方法还接受多个参数 function add(a, b) &#123; return a + b&#125;add.call(this, 3, 5)// 8 Function.prototype.apply()apply 方法的作用于 call 基本一致, 唯一的区别就是它是用数组进行传参的. func.apply(thisValue, [arg1, arg2, ...]) Function.prototype.bind()bind 方法用于将函数体内的 this 绑定到某个对象, 然后返回一个新函数.]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>js</tag>
        <tag>进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[腾讯云服务器部署 Node 应用]]></title>
    <url>%2F%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2node%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言就在前天，微信群里有人说腾讯云服务器搞活动 1核2G 一个月10块钱，一起拼团的话还有优惠，我就心动了，一下续了二年的，正好结合我所掌握的技术点，走通上线部署的流程，不仅可以巩固我所掌握的知识点，也是让自己学的东西有个输出。 云服务器我的云服务器主机 centOS 的基本配置 服务器登录Mac 下可以使用自带的终端或者 iTerm2 通过命令方式进行登录 ssh root@&lt;公网IP&gt; 安装 Node 运行环境用 nvm 来管理 node 版本： curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.0/install.sh | bash 安装 node： nvm install v8.9.5node -v 安装 cnpmnpm install -g cnpm --registry=https://registry.npm.taobao.org 安装 gityum install git 生成 ssh 秘钥git config --global user.name &quot;baixiaojian&quot;git config --global user.email &quot;邮箱&quot;ssh-keygen -t rsa -C &quot;邮箱&quot; Hello worldconst http = require('http');const server = http.createServer((req, res) =&gt; &#123; res.statusCode = 200; res.setHeader('Content-Type', 'text/plain'); res.end('Hello World\n');&#125;);server.listen(3000, () =&gt; &#123; console.log(`Server is running at port 3000`);&#125;); 在服务端执行： 在浏览器`中打开: 域名解析虽然可以通过 IP 地址访问, 但是记忆起来比较困难, 可以通过配置域名来访问 node 应用。 我原本就有一个 baixiaojian.com 的域名,所以我再次基础上配一个二级域名指向自己的主机,如 ok.baixiaojian.com, 访问主机时 通过 nginx 反向代理到服务器指定端口应用,这样的一个好处就是可以使 80 端口共用, 域名解析默认是 80 端口, 如果不是 80 端口,就需要指定端口号, 就像这样 ok.baixiaojian.com:4000 这样的体验是非常差的,所以 nginx 使 80 端口可以共用是非常必要的。 安装 nginx配置 nginx TransmitTransmit 是 Mac 下一款实用的 FTP 客户端软件，它使用起来非常的稳定，速度也比较理想。 使用教程 pm2 进程管理pm2 入门指南]]></content>
      <categories>
        <category>快捷操作</category>
      </categories>
      <tags>
        <tag>腾讯云</tag>
        <tag>Node</tag>
        <tag>部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx 笔记]]></title>
    <url>%2Fnginx%2F</url>
    <content type="text"><![CDATA[图源来自知乎 反向代理的优点 保护真实 web 服务器，其对外不可见； 节约了有限的 ip 地址资源； 减少 web 服务器压力，提高响应速度； 请求的统一控制，包括设置权限、过滤规则等； 区分动态和静态可缓存内容； 实现负载均衡，内部可以采用多台服务器来组成服务器集群，外部还是可以采用一个地址访问； 解决 Ajax 跨域问题； 作为真实服务器的缓冲，解决瞬间负载量大的问题； 配置文件main # 全局设置events &#123; # Nginx工作模式 ....&#125;http &#123; # http设置 .... upstream myproject &#123; # 负载均衡服务器设置 ..... &#125; server &#123; # 主机设置 .... location &#123; # URL匹配 .... &#125; &#125; server &#123; .... location &#123; .... &#125; &#125; ....&#125; 功能实现基于域名的虚拟主机第一步: 假设我们在本地开发有3个项目，需要分别在 hosts 里映射到本地的127.0.0.1上： 127.0.0.1 www.aaa.com127.0.0.1 www.bbb.com127.0.0.1 www.ccc.com 第二步: 分别对应于web根目录下的3个文件夹，用域名对应文件夹名字，为了好记： /Users/baixiaojian/www/www.aaa.com//Users/baixiaojian/www/www.bbb.com//Users/baixiaojian/www/www.ccc.com/ 每个目录都有一个 index.html 文件, 都是简单的输出自己的域名. 第三步: 我们要新建3个server来搭建对应个域名的虚拟主机。 这3个 server 配置信息都写成一个 .conf 的配置文件,然后在 http 模块统一导入,这样比较便于维护和管理 mainevents &#123; ....&#125;http &#123; .... include servers/www.aaa.conf; include servers/www.bbb.conf; include servers/www.ccc.conf; # 或者用 *.conf 包含 # include servers/*.conf&#125; 既然每一个conf都是一个server，下面就开始： ### www.aaa.com server &#123; charset utf-8; listen 80; server_name www.aaa.com; location / &#123; root /Users/baixiaojian/www/www.aaa.com/; index index.html index.htm; &#125; &#125; ### www.bbb.com server &#123; charset utf-8; listen 80; server_name www.bbb.com; location / &#123; root /Users/baixiaojian/www/www.bbb.com/; index index.html index.htm; &#125; &#125; ### www.ccc.com server &#123; charset utf-8; listen 80; server_name www.ccc.com; location / &#123; root /Users/baixiaojian/www/www.ccc.com/; index index.html index.htm; &#125; &#125; 这样3个很精简的虚拟域名就搭建好了。重启下nginx，然后打开浏览器访问一下这3个域名，就能看到对应的域名内容了。 反向代理Nginx 使用反向代理，主要是使用location模块下的 proxy_pass 选项。 来个最简单的。当我访问 mac 上的nginx 的 centos.com 的内容时候,就反向代理到虚拟机centos上的 10.211.55.5 的index.html页面。 第一步: 在 hosts 里新加域名: #vi /etc/hosts127.0.0.1 centos.com 第二步: 在 servers 目录中新建一个 .conf 的配置文件： #centos.confserver &#123; listen 80; server_name centos.com; location / &#123; proxy_pass http://10.211.55.5; &#125;&#125; 执行 sudo nginx -s reload 重启后访问 centos.com 负载均衡啥是负载均衡 ?比如我们有一个小网站，刚开始就一台nginx服务器，后来，随着业务量增大，用户增多，一台服务器已经不够用了，我们就又多加了几台服务器。那么这几台服务器 如何调度 ？如何均匀提供访问 ？这就是负载均衡。 负载均衡的好处是可以集群多台机器一起工作，并且对外的IP和域名是一样的，外界看起来就好像一台机器一样。 基于 weight 权重的负载upstream webservers&#123; server 192.168.33.11 weight=10; server 192.168.33.12 weight=10; server 192.168.33.13 weight=10;&#125;server &#123; listen 80; server_name upstream.com; location / &#123; proxy_pass http://webservers; proxy_set_header X-Real-IP $remote_addr; &#125;&#125; 基于 ip_hash 的负载每个请求按访问IP的hash结果分配，这样来自同一个IP的访客固定访问一个后端服务器，有效解决了动态网页存在的session共享问题。 upstream webservers&#123; ip_hash; server 192.168.33.11 weight=1 max_fails=2 fail_timeout=30s; server 192.168.33.12 weight=1 max_fails=2 fail_timeout=30s; server 192.168.33.13 down;&#125; 注: ip_hash 模式下，不要设置 weight 和 backup 页面缓存只需要简单配置下，就能将指定的一个页面缓存起来.原理就是匹配当前访问的url, hash加密后，去指定的缓存目录查找, 有的话就说明匹配到缓存. 先来看一下一个简单的页面缓存的配置： http &#123; proxy_cache_path /data/nginx/cache levels=1:2 keys_zone=cache_zone:10m inactive=1d max_size=100m; # proxy_cache_path path [levels=number] keys_zone=zone_name:zone_size [inactive=time] [max_size=size]; # path =&gt; 缓存路径 # levels =&gt; 文件夹级数 # keys_zone =&gt; 指的是共享池的名称 # inactive =&gt; 表示指定的时间内缓存的数据没有被请求则被删除 # max_size =&gt; 缓存区域的总大小 # clean_time =&gt; 表示每间隔自动清除的时间 upstream myproject &#123; ..... &#125; server &#123; .... location ~ *\.php$ &#123; proxy_cache cache_zone; # keys_zone的名字 proxy_cache_key $host$uri$is_args$args; # 缓存规则 proxy_cache_valid any 1d; # 为不同的http响应状态码设置不同的缓存时间。 proxy_pass http://127.0.0.1:8080; &#125; &#125; ....&#125; 开始进行实战 第一步: Parallels Desktop 上启动一台 linux 虚拟机(10.211.55.5) 第二部: Mac hosts配置 cache.com 域名, 然后按照上面的配置在 servers 下新建一个 cache.conf 文件: proxy_cache_path /usr/local/var/cache levels=1:2 keys_zone=cache_zone:10m inactive=1d max_size=100m;server &#123; listen 80; server_name cache.com; add_header X-Via $server_addr; add_header X-Cache $upstream_cache_status; location / &#123; proxy_set_header X-Real-IP $remote_addr; proxy_cache cache_zone; proxy_cache_key $host$uri$is_args$args; proxy_cache_valid 200 304 1m; proxy_pass http://10.211.55.5; &#125;&#125; 访问 cache.com 查看 network 网络请求选项，我们可以看到，Response Headers，在这里我们可以看到： X-Cache: MISSX-Via: 127.0.0.1 X-cache 为 MISS 表示未命中，请求被传送到后端。因为是第一次访问，没有缓存，所以肯定是未命中。我们再刷新下，就发现其变成了HIT, 表示命中。 X-cache 的其他几种状态： 状态 说明 MISS 未命中，请求被传送到后端 HIT 缓存命中 EXPIRED 缓存已经过期请求被传送到后端 UPDATING 正在更新缓存，将使用旧的应答 STALE 后端将得到过期的应答 BYPASS 缓存被绕过了 我们再去看看缓存文件夹 /usr/local/var/cache里面是否有了文件： cache git:(master) cd a/13➜ 13 git:(master) ls5bd1af99bcb0db45c8bd601d9ee9e13a➜ 13 git:(master) pwd/usr/local/var/cache/a/13 已经生成了缓存文件。 我们在url 后面随便加一个什么参数，看会不会新生成一个缓存文件夹及文件：http://cache.com/?w=ww55 。因为我们使用的生成规则是全部url转换(proxy_cache_key $host$uri$is_args$args;) 查看 X-cache 为 MISS，再刷新 ，变成HIT。缓存文件夹 /usr/local/var/cache 又会多出对应缓存文件. Location 正则模块location / 表示匹配访问根目录。location ~ 表示开启正则匹配。还可以用这个来匹配静态资源，缓存它们，设置过期时间： location ~ .*\.(gif|jpg|jpeg|bmp|png|ico|txt|mp3|mp4|swf)&#123; expires 15d;&#125;location ~ .*\.(css|js)&#123; expires 12d;&#125; 配置说明# 运行用户user www-data;# 启动进程,通常设置成和cpu的数量相等worker_processes 1;# 全局错误日志及PID文件error_log /var/log/nginx/error.log;pid /var/run/nginx.pid;# 工作模式及连接数上限events &#123; use epoll; #epoll是多路复用IO(I/O Multiplexing)中的一种方式,但是仅用于linux2.6以上内核,可以大大提高nginx的性能 worker_connections 1024; #单个后台worker process进程的最大并发链接数 # multi_accept on;&#125;#设定http服务器，利用它的反向代理功能提供负载均衡支持http &#123; #设定mime类型,类型由mime.type文件定义 include /etc/nginx/mime.types; default_type application/octet-stream; #设定日志格式 access_log /var/log/nginx/access.log; #sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，对于普通应用， #必须设为 on,如果用来进行下载等应用磁盘IO重负载应用，可设置为 off，以平衡磁盘与网络I/O处理速度，降低系统的uptime. sendfile on; #将tcp_nopush和tcp_nodelay两个指令设置为on用于防止网络阻塞 tcp_nopush on; tcp_nodelay on; #连接超时时间 keepalive_timeout 65; #开启gzip压缩 gzip on; gzip_disable &quot;MSIE [1-6]\.(?!.*SV1)&quot;; #设定请求缓冲 client_header_buffer_size 1k; large_client_header_buffers 4 4k; include /etc/nginx/conf.d/*.conf; include /etc/nginx/sites-enabled/*; #设定负载均衡的服务器列表 upstream mysvr &#123; #weigth参数表示权值，权值越高被分配到的几率越大 #本机上的Squid开启3128端口 server 192.168.8.1:3128 weight=5; server 192.168.8.2:80 weight=1; server 192.168.8.3:80 weight=6; &#125; server &#123; #侦听80端口 listen 80; #定义使用www.xx.com访问 server_name www.xx.com; #设定本虚拟主机的访问日志 access_log logs/www.xx.com.access.log main; #默认请求 location / &#123; root /root; #定义服务器的默认网站根目录位置 index index.php index.html index.htm; #定义首页索引文件的名称 fastcgi_pass www.xx.com; fastcgi_param SCRIPT_FILENAME $document_root/$fastcgi_script_name; include /etc/nginx/fastcgi_params; &#125; # 定义错误提示页面 error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root /root; &#125; #静态文件，nginx自己处理 location ~ ^/(images|javascript|js|css|flash|media|static)/ &#123; root /var/www/virtual/htdocs; #过期30天，静态文件不怎么更新，过期可以设大一点，如果频繁更新，则可以设置得小一点。 expires 30d; &#125; #PHP 脚本请求全部转发到 FastCGI处理. 使用FastCGI默认配置. location ~ \.php$ &#123; root /root; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /home/www/www$fastcgi_script_name; include fastcgi_params; &#125; #设定查看Nginx状态的地址 location /NginxStatus &#123; stub_status on; access_log on; auth_basic &quot;NginxStatus&quot;; auth_basic_user_file conf/htpasswd; &#125; #禁止访问 .htxxx 文件 location ~ /\.ht &#123; deny all; &#125; &#125; #第一个虚拟服务器 server &#123; #侦听192.168.8.x的80端口 listen 80; server_name 192.168.8.x; #对aspx后缀的进行负载均衡请求 location ~ .*\.aspx$ &#123; root /root;#定义服务器的默认网站根目录位置 index index.php index.html index.htm;#定义首页索引文件的名称 proxy_pass http://mysvr;#请求转向mysvr 定义的服务器列表 #以下是一些反向代理的配置可删除. proxy_redirect off; #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; client_max_body_size 10m; #允许客户端请求的最大单文件字节数 client_body_buffer_size 128k; #缓冲区代理缓冲用户端请求的最大字节数， proxy_connect_timeout 90; #nginx跟后端服务器连接超时时间(代理连接超时) proxy_send_timeout 90; #后端服务器数据回传时间(代理发送超时) proxy_read_timeout 90; #连接成功后，后端服务器响应时间(代理接收超时) proxy_buffer_size 4k; #设置代理服务器（nginx）保存用户头信息的缓冲区大小 proxy_buffers 4 32k; #proxy_buffers缓冲区，网页平均在32k以下的话，这样设置 proxy_busy_buffers_size 64k; #高负荷下缓冲大小（proxy_buffers*2） proxy_temp_file_write_size 64k; #设定缓存文件夹大小，大于这个值，将从upstream服务器传 &#125; &#125;&#125; 参考资料]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>mac</tag>
        <tag>nginx</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac 环境变量相关及开发相关文件解读]]></title>
    <url>%2Fmac%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[图解 环境变量配置OS系统的配置文件加载顺序： /etc/profile /etc/paths ~/.bash_profile /etc/profile、/etc/bashrc 是针对系统所有用户的 全局变量, 如修改需权限,~/.bash_profile 是当前 用户级 的环境变量, 所以通常去修改它来设置环境变量. 操作步骤: 1. 终端输入 vi ~/.bash_profile2. 设置 PATH：export PATH=/usr/local/mysql/bin:$PATH3. 输入 :wq4. 立即生效 source ~/.bash_profile5. 查看变量值 echo $PATH 注: 删除环境变量需重启shell才能立即生效 开发相关文件 应用程序(Applications) 系统(System) 用户(User) 资料库(Library) 隐藏文件夹 文件夹 作用 usr unix 使用者专用文件夹 bin unix 储存基本指令 sbin unix 储存系统指令 etc 系统设定 储存位置 var 频繁改动 置放于此, 如监控、日志等 tmp 系统暂存档 usr/local 本地文件系统配置相关文件 usr/local/etc 相关配置文件 其他 文件夹 作用 / 磁盘根目录 也就是 Macintosh HD 目录下 ~ 或者 /User/ 当前用户目录的顶级目录 /user/Shared 目录可以被本地的所有用户访问 Sites 用户个人站点网页文件。需设置 “系统预置-&gt;共享-&gt;Web共享” 中打开共享 Public 可以把需要与其它用户共享的文件放在这个目录中]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>环境变量</tag>
        <tag>设置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode]]></title>
    <url>%2Fvscode%2F</url>
    <content type="text"><![CDATA[快捷键基础 按键 作用 Commend + X 剪切 Commend + C 复制 Commend + V 粘贴 Alt + up/down 移动行上下 Shift + Alt up/down 在当前行上下复制当前行 Commend + Enter 在当前行下插入新的一行 Commend + Shift + Enter 在当前行上插入新的一行 Commend + Alt + [/] 折叠/展开区域代码 Ctrl + K/O 前缩进/后缩进 Commend + / 添加关闭行注释 Shift + Alt +A 块区域注释 导航 按键 作用 Ctrl + G 跳转行 Commend + P 跳转文件 Commend + R 查找方法或标签 Commend + Shift + M 打开问题展示面板 F8 跳转到下一个错误或者警告 Shift + F8 跳转到上一个错误或者警告 查询与替换 按键 作用 Commend + F 查询 Alt + Enter 选中所有查询结果 F3 / Shift + F3 查询下一个/上一个 Commend + D 选中下一个相同 Control + Commend + G / Commend + F2 选中所有相同 多行光标操作于选择 快捷键 作用 Commend + Click 多选光标 Commend + F2 选中所有相同 Commend + Alt + up/down 上下插入光标 Commend + Shift + Click 集选光标 丰富的语言操作 快捷键 作用 Shift + Alt + F 格式化代码 Ctrl + R 打开 Git Project 文件夹 Commend + K + Commend + F 格式化选中部分的代码 F12 跳转到定义处 Alt + F12 代码片段显示定义 Ctrl + K F12 在其他窗口打开定义处 Shift + F12 显示所有引用 F2 重命名符号 编辑器管理 快捷键 作用 Commend + W 关闭编辑器 Commend + \ 切割编辑窗口 Commend + Alt &lt;-/-&gt; 切割窗口位置调换 文件管理 快捷键 作用 Commend + N 新建文件 Commend + O 打开文件 Commend + S 保存文件 Commend + Alt + S 保存所有文件 Commend + K Commend + W 关闭所有编辑窗口 Commend + W 关闭当前编辑窗口 Commend + Shift + T 撤销最近关闭的一个文件编辑窗口 Commend + Shift + S 另存为 Commend + K S 键盘快捷方式指南 Commend + K P 复制当前打开文件的存放路径 Commend + K R 打开vscode官方快捷键指南 显示 快捷键 作用 Ctrl + Commend + F 切换全屏模式 Commend + =/- 放大 / 缩小 Commend + B 侧边栏显示隐藏 Commend + Shift + E 资源视图和编辑视图的焦点切换 Commend + Shift + F 打开全局搜索 Ctrl + Shift + G 打开Git可视管理 Ctrl + Shift + D 打开DeBug面板 Ctrl + Shift + X 打开插件市场面板 Ctrl + Shift + H 在当前文件替换查询替换 Ctrl + Shift + J 开启详细查询 Ctrl + Shift + V 预览Markdown文件【编译后】 Ctrl + K v 在边栏打开渲染后的视图【新建】 调试 快捷键 作用 F9 添加解除断点 F5 启动调试、继续 F11 / Shift + F11 单步进入/单步跳出 F10 单步跳过 集成终端 快捷键 作用 Commend + ` 打开集成终端 Commend + Shift + ` 创建一个新的终端 Commend + Shift + C 复制所选 Commend + Shift + V 复制到当前激活的终端 插件 插件 功能 Guides 括号高亮 Beautiful 格式化 One Monokai Theme 主题不错 Bookmarks 书签工具 Path Autocomplete 路径智能补全 Path Intellisense 路径智能提示 Code Spell Checker 检查单词拼写 markdownlint markdown 语法检测 expand-region 逐渐选中光标所在内容 ESLint 可以配置自动格式代码规范 Output Colorizer 可以终端日志输出着色，实用 Markdown All in One 自动补全/格式化table/… Debugger for Chrome 在vscode调试代码, 屌的一比 Code Runner 代码编译运行看结果支持多语言 colorize 会给当前颜色代码该颜色的背景 Git Project Manager 可以很方便的打开自己的 git 项目 background 自己敲代码时有一个妹子看的感觉不赖 Version Lens 可以及时看到package.json内部版本的变动 Git Lens 可以很方便的查看 git 的各种提交记录及成员间的更改 Git History 有 Git Lens 没有的功能, 比如查看某一个成员的历史提交 参考资料VS Code折腾记-快捷键VS Code折腾记-必备插件]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>快捷键</tag>
        <tag>vscode</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongodb 安装与基本配置]]></title>
    <url>%2Fmongodb%2F</url>
    <content type="text"><![CDATA[查看brew listbrew search mongodb 安装brew install mongodb 启动首次执行 mongod 尝试启动 MongoDB , 但会失败 exiting: ➜ ~ mongod2018-01-26T15:11:13.278+0800 I CONTROL [initandlisten] MongoDB starting : pid=8954 port=27017 dbpath=/data/db 64-bit host=baixiaojiandeMacBook-Pro.local2018-01-26T15:11:13.278+0800 I CONTROL [initandlisten] db version v3.6.22018-01-26T15:11:13.278+0800 I CONTROL [initandlisten] git version: 489d177dbd0f0420a8ca04d39fd78d0a2c5394202018-01-26T15:11:13.278+0800 I CONTROL [initandlisten] OpenSSL version: OpenSSL 1.0.2n 7 Dec 20172018-01-26T15:11:13.278+0800 I CONTROL [initandlisten] allocator: system2018-01-26T15:11:13.278+0800 I CONTROL [initandlisten] modules: none2018-01-26T15:11:13.278+0800 I CONTROL [initandlisten] build environment:2018-01-26T15:11:13.278+0800 I CONTROL [initandlisten] distarch: x86_642018-01-26T15:11:13.278+0800 I CONTROL [initandlisten] target_arch: x86_642018-01-26T15:11:13.278+0800 I CONTROL [initandlisten] options: &#123;&#125;2018-01-26T15:11:13.279+0800 I STORAGE [initandlisten] exception in initAndListen: NonExistentPath: Data directory /data/db not found., terminating2018-01-26T15:11:13.279+0800 I CONTROL [initandlisten] now exiting2018-01-26T15:11:13.279+0800 I CONTROL [initandlisten] shutting down with code:100 启动 MongoDB 之前, 要先新建一个 MongoDB 默认的数据写入目录 // sudo 并输入密码，重新新建目录$ sudo mkdir -p /data/dbPassword: 给刚才新建的数据库目录赋予权限: $ sudo chown -R baixiaojian /data 此时,执行 mongod 启动 MongoDB 服务: ➜ ~ mongod2018-01-26T15:17:54.988+0800 I CONTROL [initandlisten] MongoDB starting : pid=9551 port=27017 dbpath=/data/db 64-bit host=baixiaojiandeMacBook-Pro.local2018-01-26T15:17:54.989+0800 I CONTROL [initandlisten] db version v3.6.22018-01-26T15:17:54.989+0800 I CONTROL [initandlisten] git version: 489d177dbd0f0420a8ca04d39fd78d0a2c5394202018-01-26T15:17:54.989+0800 I CONTROL [initandlisten] OpenSSL version: OpenSSL 1.0.2n 7 Dec 20172018-01-26T15:17:54.989+0800 I CONTROL [initandlisten] allocator: system2018-01-26T15:17:54.989+0800 I CONTROL [initandlisten] modules: none2018-01-26T15:17:54.989+0800 I CONTROL [initandlisten] build environment:2018-01-26T15:17:54.989+0800 I CONTROL [initandlisten] distarch: x86_642018-01-26T15:17:54.989+0800 I CONTROL [initandlisten] target_arch: x86_642018-01-26T15:17:54.989+0800 I CONTROL [initandlisten] options: &#123;&#125;2018-01-26T15:17:54.990+0800 I STORAGE [initandlisten] wiredtiger_open config: create,cache_size=7680M,session_max=20000,eviction=(threads_min=4,threads_max=4),config_base=false,statistics=(fast),log=(enabled=true,archive=true,path=journal,compressor=snappy),file_manager=(close_idle_time=100000),statistics_log=(wait=0),verbose=(recovery_progress),2018-01-26T15:17:55.353+0800 I CONTROL [initandlisten]2018-01-26T15:17:55.353+0800 I CONTROL [initandlisten] ** WARNING: Access control is not enabled for the database.2018-01-26T15:17:55.353+0800 I CONTROL [initandlisten] ** Read and write access to data and configuration is unrestricted.2018-01-26T15:17:55.353+0800 I CONTROL [initandlisten]2018-01-26T15:17:55.353+0800 I CONTROL [initandlisten] ** WARNING: This server is bound to localhost.2018-01-26T15:17:55.353+0800 I CONTROL [initandlisten] ** Remote systems will be unable to connect to this server.2018-01-26T15:17:55.353+0800 I CONTROL [initandlisten] ** Start the server with --bind_ip &lt;address&gt; to specify which IP2018-01-26T15:17:55.353+0800 I CONTROL [initandlisten] ** addresses it should serve responses from, or with --bind_ip_all to2018-01-26T15:17:55.353+0800 I CONTROL [initandlisten] ** bind to all interfaces. If this behavior is desired, start the2018-01-26T15:17:55.353+0800 I CONTROL [initandlisten] ** server with --bind_ip 127.0.0.1 to disable this warning.2018-01-26T15:17:55.353+0800 I CONTROL [initandlisten]2018-01-26T15:17:55.360+0800 I STORAGE [initandlisten] createCollection: admin.system.version with provided UUID: acffed24-1106-4136-bf4d-d2894c0cb3e32018-01-26T15:17:55.443+0800 I COMMAND [initandlisten] setting featureCompatibilityVersion to 3.62018-01-26T15:17:55.447+0800 I STORAGE [initandlisten] createCollection: local.startup_log with generated UUID: 5414b600-b049-49b5-aad7-c20beb480c412018-01-26T15:17:55.551+0800 I FTDC [initandlisten] Initializing full-time diagnostic data capture with directory &apos;/data/db/diagnostic.data&apos;2018-01-26T15:17:55.551+0800 I NETWORK [initandlisten] waiting for connections on port 27017 MongoDB 启动成功,等待被连接中… 连接新建命令行窗口, 执行 mongo 进入 MongoDB 命令行模式: ➜ ~ mongoMongoDB shell version v3.6.2connecting to: mongodb://127.0.0.1:27017MongoDB server version: 3.6.2Server has startup warnings:2018-01-26T15:17:55.353+0800 I CONTROL [initandlisten]2018-01-26T15:17:55.353+0800 I CONTROL [initandlisten] ** WARNING: Access control is not enabled for the database.2018-01-26T15:17:55.353+0800 I CONTROL [initandlisten] ** Read and write access to data and configuration is unrestricted.2018-01-26T15:17:55.353+0800 I CONTROL [initandlisten]2018-01-26T15:17:55.353+0800 I CONTROL [initandlisten] ** WARNING: This server is bound to localhost.2018-01-26T15:17:55.353+0800 I CONTROL [initandlisten] ** Remote systems will be unable to connect to this server.2018-01-26T15:17:55.353+0800 I CONTROL [initandlisten] ** Start the server with --bind_ip &lt;address&gt; to specify which IP2018-01-26T15:17:55.353+0800 I CONTROL [initandlisten] ** addresses it should serve responses from, or with --bind_ip_all to2018-01-26T15:17:55.353+0800 I CONTROL [initandlisten] ** bind to all interfaces. If this behavior is desired, start the2018-01-26T15:17:55.353+0800 I CONTROL [initandlisten] ** server with --bind_ip 127.0.0.1 to disable this warning.2018-01-26T15:17:55.353+0800 I CONTROL [initandlisten]&gt; 4685*9894633465&gt; 连接成功, 然后就可以对数据库进行操作了.]]></content>
      <categories>
        <category>配置相关</category>
      </categories>
      <tags>
        <tag>mongod</tag>
        <tag>基本配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[busy recently]]></title>
    <url>%2Flog-busy%2F</url>
    <content type="text"><![CDATA[最近有点忙一些想记的笔记想吐的槽都被忙碌的时间搁了浅早九晚九+周末单休+今天也是在夜深人静后挤出的 “闲暇” 时光可能忙碌中才能更好的积累与沉淀吧 刚有空把书签栏整理一下删掉了许多不在需要或者无效的书签看起来更舒服了]]></content>
      <categories>
        <category>东拉西扯</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2017 LastDay]]></title>
    <url>%2F2017-last-day%2F</url>
    <content type="text"><![CDATA[2017年的最后一天 时间过得好快，夜幕就要降临，我想我必须要离开,当我正要走时我看到一家… 等等… 这是什么节奏,明明要写年终总结，还是被神曲洗脑带偏了 关于90后的”18岁” 昨天朋友圈被许许多多的 “18岁” 要成为成年人的照片刷爆了屏， 90后中最小的成员从明天开始也成为了成年人，开始扛起中国新时代的大旗， 从某种层面上就意味着90后这个群体已 不再年轻 的同时肩上的责任更重了， 相对于80后，90后的时代应该是比较幸运的，更过姿多彩的， 在身处信息爆炸的时代，信息与知识的获取已经变得及其容易， 一些像 “我吃的盐比你走的路都要多” 这样的话，已经变越来越不能证明什么了， 之前在法治栏目看过一个毒贩就是在百度上通过搜索相关资料就可以自己制作出冰毒， 网络是一把双刃剑，让人们生活变的便利的同时，风险和危险也会随之而来, 呃，好像有点扯远了… 我自己的18岁 其实本来没什么的，原本计划今年跨年陪家人吃个饭其他一切照常， 但被刷爆的朋友圈的影响下，自己也不仅多了一些感慨， 18岁啊18岁，这个真是一个花样年华的年纪，我已记不清那时的我在做什么。 但有一点我是确认的，就是去网吧再也不用用别人的身份证了， 哈哈…可能就这点出息了 年龄什么的现在一般都记得不确切， 如果说90后最小的明天就成年了，那么 00-94+18 = 24岁 对，是，没错 我今年已经24岁，24啊24 , &quot;曾经沧海难为水，除去巫山不是云&quot; 突然就想到这句话了 不贴切， 但我实际想说的是，18岁时得我以为 25岁什么的离我很遥远， 现在看来还真是 too young 啊！ 现在25都不用24++，只要一个虚岁就到了… 关于 2017 年 如果要总结2017年的话我真的要想想 提取记忆中 一月份... 二月份... 三月份... 四月份... 五月份... 六月份... 七月份... 八月份... 九月份... 十月份... 十一月份... 十二月份...大脑运行内存不足，提取失败! 这他喵的尴尬了，身为一个程序员，直接导出 database 效果不是想要的， 要按照关键词提取嘛! 提取关键词中 加班加班加班... 撕逼撕逼撕逼... 砍需求砍需求... 狗粮狗粮狗粮... bugbugbug... 撸撸撸撸撸撸... 学习学习学习...扎心了老铁,提取成功！ 这他喵的还是尴尬啊，哎 不管了，虽然2017年有缺憾的地方，但这不就是人生嘛， 某某牛逼闪闪放光芒的某某学家就说过 “没有遗憾，不是人生” 翻译成大白话就是 “你连遗憾有没有你还是人？” 2017关键词自己总结2017年关键词的话就是： 学习、沉淀、孤独、坚持、成长 关键词提取核心观念 持续学习 =&gt; 不学习就会被淘汰 积累沉淀 =&gt; 量变引起质变 选择孤独 =&gt; 孤独好似美酒 不懈坚持 =&gt; 爱好&gt;环境&gt;毅力 迎接成长 =&gt; 只是以上关键词附属品 2017年其实不错、很好、very棒，忙碌而充实，是我想要的。 2018 展望其实说展望有点怪怪的，因为明天就是2018了，而明天在说今天就是回顾2017了，哈哈 哇塞，刚打到2018时有种2008的既视感， 转眼间已过十年，十年啊， 十年之前我不认识你，你不属于我，我们还是一样，陪在一个陌生人左右… 等等… 咋又开始了，由此可见 muisc 的魔力，总是能被它影响 2017到2018，也就是由 咯咯咯到汪汪汪，而我是属汪汪汪的啊，那么就是我的本命年了啊！ 是不是就应该带红绳什么的，光想想就好激动的呢！ 2018年要和2017年一样继续积累与沉淀。]]></content>
      <categories>
        <category>东拉西扯</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Unix 终端常用命令]]></title>
    <url>%2Funxi%2F</url>
    <content type="text"><![CDATA[Unix 终端命令大全目录操作 命令名 功能描述 使用举例 mkdir 创建一个目录 mkdir dirname rmdir 删除一个目录 rmdir dirname mv -f 移动或重命名一个目录 mv -f dir1 dir2 cd 改变当前目录 cd dirname pwd 显示当前目录的路径名 pwd ls 显示当前目录的内容 ls -la dircmp 比较两个目录的内容 dircmp dir1 dir2 tree 树状图列出文件目录结构 tree echo 显示参数指定的文字 echo hello &gt; 表示输出，会覆盖文件原有的内容 echo hello &gt; aa.txt &gt;&gt; 表示追加，会将内容追加到已有文件的末尾 echo hello &gt;&gt; aa.txt 文件操作 命令名 功能描述 使用举例 cat 显示或连接文件 cat filename pg 分页格式化显示文件内容 pg filename more 分屏显示文件内容 more filename od 显示非文本文件的内容 od -c filename cp 复制文件或目录 cp file1 file2 rm 删除文件或目录 rm filename mv 改变文件名或所在目录 mv file1 file2 ln 联接文件 ln -s file1 file2 find 使用匹配表达式查找文件 find . -name “*.c” -print file 显示文件类型 file filename open 使用默认的程序打开文件 open filename 选择文件 命令名 功能描述 使用举例 head 显示文件的最初几行 head -20 filename tail 显示文件的最后几行 tail -15 filename cut 显示文件每行中的某些域 cut -f1,7 -d: /etc/passwd colrm 从标准输入中删除若干列 colrm 8 20 file2 paste 横向连接文件 paste file1 file2 diff 比较并显示两个文件的差异 diff file1 file2 sed 非交互方式流编辑器 sed “s/red/green/g” filename grep 在文件中按模式查找 grep “^[a-zA-Z]” filename awk 在文件中查找并处理模式 awk ‘{print $1 $1}’ filename sort 排序或归并文件 sort -d -f -u file1 uniq 去掉文件中的重复行 uniq file1 file2 comm 显示两有序文件的公共和非公共行 comm file1 file2 wc 统计文件的字符数、词数和行数 wc filename nl 给文件加上行号 nl file1 &gt;file2 安全操作 命令名 功能描述 使用举例 passwd 修改用户密码 passwd chmod 改变文件或目录的权限 chmod ug+x filename umask 定义创建文件的权限掩码 umask 027 chown 改变文件或目录的属主 chown newowner filename chgrp 改变文件或目录的所属组 chgrp staff filename xlock 给终端上锁 xlock -remote 编程操作 命令名 功能描述 使用举例 make 维护可执行程序的最新版本 make touch 更新文件的访问和修改时间 touch -m 05202400 filename dbx 命令行界面调试工具 dbx a.out xde 图形用户界面调试工具 xde a.out 进程操作 命令名 功能描述 使用举例 ps 显示进程当前状态 ps u kill 终止进程 kill -9 30142 nice 改变待执行命令的优先级 nice cc -c *.c renice 改变已运行进程的优先级 renice +20 32768 时间操作 命令名 功能描述 使用举例 date 显示系统的当前日期和时间 date cal 显示日历 cal 8 1996 time 统计程序的执行时间 time a.out 网络与通信操作 命令名 功能描述 使用举例 telnet 远程登录 telnet hpc.sp.net.edu.cn rlogin 远程登录 rlogin hostname -l username rsh 在远程主机执行指定命令 rsh f01n03 date ftp 在本地主机与远程主机之间传输文件 ftp ftp.sp.net.edu.cn rcp 在本地主机与远程主机 之间复制文件 rcp file1 host1:file2 ping 给一个网络主机发送 回应请求 ping hpc.sp.net.edu.cn mail 阅读和发送电子邮件 mail write 给另一用户发送报文 write username pts/1 mesg 允许或拒绝接收报文 mesg n ifconfig 查看/配置计算机当前的网卡配置信息 ifconfig Korn Shell 命令 命令名 功能描述 使用举例 history 列出最近执行过的几条命令及编号 history r 重复执行最近执行过的某条命令 r -2 alias 给某个命令定义别名 alias del=rm -i unalias 取消对某个别名的定义 unalias del 其它命令 命令名 功能描述 使用举例 uname 显示操作系统的有关信息 uname -a clear 清除屏幕或窗口内容 clear env 显示当前所有设置过的环境变量 env who 列出当前登录的所有用户 who whoami 显示当前正进行操作的用户名 whoami tty 显示终端或伪终端的名称 tty stty 显示或重置控制键定义 stty -a du 查询磁盘使用情况 du -k subdir df 显示文件系统的总空间和可用空间 df /tmp w 显示当前系统活动的总信息 w]]></content>
      <categories>
        <category>快捷操作</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>命令</tag>
        <tag>Unix</tag>
        <tag>终端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim 基本操作]]></title>
    <url>%2Fvim%2F</url>
    <content type="text"><![CDATA[文件操作 p 在当前位置 之后 粘贴 P 在当前位置 之前 粘贴 yy 拷贝当前行，相当于 ddP x 删除当前光标所在的字符 dd 剪贴当前行 插入模式 a 在光标后插入 O 在当前 行前插入 一个新行 o 在当前 行后插入 一个新行 cw 替换从光标所在位置后到一个单词结尾的字符 移动光标 ^ 到本首 g_ 到本尾 0 到行头 $ 到行末 w b 词移动 gg 文件开头 G 文件结尾 h/j/k/l 左/下/上/右 撤销/重做 u undo &lt;Ctrl+r&gt; redo 退出方式 :e 打开一个文件 :w 存盘 :saveas 另存为 :x, ZZ 或 :wq 保存并退出 :q! 退出不保存 :qa! 强行退出所有文件。 :bn 和 :bp 你可以同时打开很多文件，使用这两个命令来切换下一个或上一个文件。]]></content>
      <categories>
        <category>快捷操作</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>vim</tag>
        <tag>基本操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 笔记]]></title>
    <url>%2Fgit%2F</url>
    <content type="text"><![CDATA[回退相关操作工作区 命令 含义 git checkout – file.txt 丢弃 file.txt 中的修改 git reset –hard 重设暂存区所有文件并且还原工作区所有修改 暂存区 命令 含义 git reset 重设暂存区所有文件 git reset HEAD 撤销最新一次的 add 状态 git reset file.txt 把 file.txt 的放入工作区 git reset –hard 重设暂存区所有文件并且还原工作区所有修改 版本区 HEAD =&gt; 当前版本 HEAD^ =&gt; 上一个版本 HEAD^^ =&gt; 上上一个版本 HEAD~100 =&gt; 上一100个版本 命令 含义 git revert HEAD 撤销最新一次的 commit ,分支没有改动文件才能执行(存在该commit记录) git reset &lt;commit&gt; 删除最新一次的 commit 并且重设暂存区所有文件 (不存在该commit版本号) git reset HEAD~2 将当前分支倒退两个提交(高危操作) git reset –hard HEAD^ 回退上一个版本 删除文件 命令 含义 rm file.txt 删除文件 git checkout – file.txt 撤销删除 (未commit之前) git clean -n 查看那些未被跟踪文件会被移除 git clean -f 移除当前目录下未被跟踪的文件 git clean -df 移除未跟踪的文件以及目录 git clean -f &lt;path&gt; 移除未跟踪的文件，但限制在某个路径下 git clean -xf 移除当前目录下未跟踪的文件，以及 Git 一般忽略的文件 创建与合并分支 命令 含义 git checkout -b dev 创建并且切换到dev分支 git checkout -b hotfix dev 基于dev分支创建一个hotfix分支 git checkout dev 切换到dev分支 git branch 查看所有的分支 git branch -d dev 删除dev分支(当前分支无法自行删除) git branch -D dev 强制删除分支(用于未合并分支) git merge dev 将dev分支合并到当前分支 远程仓库的操作 命令 含义 git remote -v 查看远程仓库的详细信息 git remote add remote-name URL 添加远程仓库 git push origin master 将内容提交到远程仓库 origin 的 master 分支上 git remote rm origin 将远程仓库 origin 删除 git remote rename origin pb 将远程仓库 origin 改为 pb git clone URL 克隆一个远程仓库，这里的URL是远程仓库的地址 git pull origin 将远程仓库中更新的数据拉到本地 git pull origin dev 拉取远程仓库dev分支到本地 git push origin aaa 将 aaa 分支推送到远程仓库 git pull –rebase URL git rebase 代替 git merge 合并本地分支 git push –force 强制推送 git commit 命令 含义 git commit –amend 和上一次 commit 合并,并在该基础上编辑commit信息 git commit –amend –no-edit 和上一次 commit 合并, 不编辑信息 git commit -a -m “some modified” git add -A &amp;&amp; git commit -m ‘some modified’ git rebase &lt;base&gt; 是可以使任何类型的提交引用（ID/分支名/标签/HEAD） 参考文档1 参考文档2 什么是 git rebase(变基==改变基线) 变基是将分支移到一个新的基提交的过程, 产生的是一个快速向前的合并以及完美的线性历史 rebase 就好像是说「我想将我的更改建立在其他人的进展之上」 绝不要在公共的分支上使用它 git rebase &lt;base&gt; =&gt; git merge &lt;base&gt; 相似 git rebase –continue =&gt; 解决冲突后可执行的命令 git rebase –abort =&gt; 终止rebase的行动，并且所在分支会回到rebase开始前的状态。 git rebase -i &lt;base&gt; =&gt; 交互式 fixup startq squash git reflog Git 用引用日志这种机制来记录分支顶端的更新 git reflog =&gt; 显示本地仓库的引用日志 git reflog –relative-date =&gt; 用相对的日期显示引用日志 git reset –hard 0254ea7 配合使用 注: 引用日志提供的安全网只对提交到本地仓库的更改有效，而且只有移动操作会被记录 其他操作 git log –oneline =&gt; 简洁的显示 log 记录 报错处理 fatal: Unable to create ‘project_path/.git/index.lock’: File exists. 删除该分支 =&gt; rm -f .git/index.lock error: failed to push some refs to &lt;URL&gt; 第一种解决方式: 强推，即利用强覆盖方式用你本地的代码替代git仓库内的内容 =&gt; git push -f 第二种解决方式: 这条命令等于合并远程分支，合并完成之后同目录会出现README.md目录 =&gt; git pull –rebase origin master fatal: remote origin already exists 先删除远程 Git 仓库 =&gt; git remote rm origin 再添加远程 Git 仓库 =&gt; git remote add origin &lt;URL&gt; 如果执行 git remote rm origin 还报错的话 我们可以手动修改 gitconfig 文件的内容 =&gt; vi .git/config 把 [remote “origin”] 那一行删掉就好了。 error: src refspec master does not match any 引起该错误的原因是，目录中没有文件，空目录是不能提交上去的 touch README =&gt; git add README =&gt; git commit -m ‘first commit’ =&gt; git push origin maste 用 git reset --hard 命令导致目录下所有文件全部被清除。 首先用 git reflog 命令查找到对应的sha值,如：cd7b575 通过“git reset –hard cd7b575” 注意：第二步操作有时会报错, 如: fatal: Unable to create ‘D:/chenjunjun/.git/index.lock’: File exists. 需要手动删除.git目录下的index.lock文件]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FEDAY3 笔记]]></title>
    <url>%2FFEDAY3%2F</url>
    <content type="text"><![CDATA[构建大型应用分享人：孟红伦(钉钉) 重要的俩块 使用 TypeScript 解决代码 复杂 ,数据模型的问题 使用 RxJS 更好的解决 异步 带来的问题 代码如何复杂 上百个 RPC 接口 几十种消息推送 10W + 行代码 模块依赖关系复杂 数据模型复杂 钉钉犯过的错 开发时没有考虑到个人用户登录时的 ‘org’ 字段 因为开发环境中是 归属某个企业 的,忽视了对 不归属任何企业的个人用户的测试 最后还是用户主动反映了这个问题 问题责任:测试的锅 什么是 Typescript 它是 JS 的超集,兼容 ES5,ES2015/16/17. 它的编译结果是 JS , 可以运行在浏览器/Node 端. 它支持 TS 和 JS 混用 主流框架支持程度 Angular 2.0 完全支持 VUE 2.0 部分支持 模板中还不具备 Type Check 的能力 React 完全支持 jsx 不是 ‘模板’而是 js,所以 Type Check 支持的很好 异步逻辑的处理 RxJS 实现渐进式搜索 使用 Rx.js Observable 可以更好更直观的描述这些 API,帮助你在错综复杂的异步 API 调用中少犯错 项目中如何选择框架和库分享人：张克军(豆瓣) 特指公司规模比较大,协作开发的人数比较多,商业型项目 商业型项目的核心 注重以结果为导向 高效率高质量的产出产品 考虑方面 迭代周期长,方案的选择就要 长期有效性 代码可维护性 伸缩性,用比较小的成本应对可能随时变更的需求 方案的选择需要更务实 基本前提 成本和效率 实现目标的成本和效率 团队协作的成本和效率 后续迭代的成本和效率 选择库时经常谈到的关键词 模式,普及率,成熟度 体量,局限性,学习成本 性能,活跃度,周边资源 前景,契合度,文档质量 选择的原则 妥适性原则(避免过度实现) 库的选择: 缩小依赖范围和向稳定方向依赖 避重趋轻、避繁逐简、以简驭繁、避虚就实 可替代性 主框架的选择 没有不二法则 拥抱未来 经验价值高 架构上的优势为重 选择的原则(白话版) 妥适性原则(避免过度实现) 库的选择，尽量同时满足以下条件 单一性 普遍性 轻量型 依赖少 主框架的选择：做足调研和实践，多和老司机交流 code Review 十分重要 包分析工具可以分析出项目中库的依赖和自己写得代码的比重 https://www.npmjs.com/package/webpack-bundle-analyzer RN 跨三端技术实践分享人：刘威(京东金融) 移动开发常见问题 原生开发 门槛高 原生发版到上线相对 周期长 原生线上问题相对 难修复 H5 相对原生 体验差 RN 优缺点 优点 学习成本低 体验接近原生 二端代码可复用 社区活跃 缺点 不支持热更新 不支持 h5 向下兼容性差 低端机型会有崩溃 三端平台-架构 关于热更新苹果官方停掉热更新之后并不影响RN，因为RN热更新没有更改底层的OC代码 缓存机制 模块名称 bundle 文件下载地址 文件校验安全码 版本号 更新机制 插件安全码是否一致 大体思路好像是： 用户进入 APP 默认下载一个某个接口的数据到本地 接口中包括模块名称、bundle 文件下载地址、文件校验安全码、版本号 当用户再一次进入 APP 中的时候会再次下载接口中的数据 然后在对比之前的数据是否发生了变化，安全码是否一致 如果不一致，就重新下载一遍，以此实现热更新 拆分 bundle 底层框架 Bundle 基础 RN JS 库 三端组件 JS 库 业务代码 Bundle 纯业务 JS 可参考 react-native-split 灾备策略当在低版本手机点击时出现崩溃备用方案 低版本的原生跳 H5 原生连续崩溃降级至 H5 如何支持 web 端 编译时转译 RN API react-native-web node-haste-webpack-plugin 版本控制 入口配置灵活 指定端和版本(可以指定版本打对应的包) 指定人群定向(作用主要用于测试) 小流量 跳转中心 低版本 H5 高版本原生 全量包 URL 拆分包 URL App 外输出 H5 页面 性能优化 数据上报 三端平台-集成方案三端组件 JS UI 组件 为抹平三端差异化的 API，基于视觉的规范 UI 层 JS 组件 UIButon、UIExplain、UISwipe… JS 业务组件 Fetch、Login… 变色龙三端开发平台文档 三端工具 本地 Nodejs 脚手架 本地模拟器-Android 本地模拟器-IOS 独立调试IOS APP 本地 IDE 客户端 链家网前端工程实践分享人：杨永林(链家) 都说了什么]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>FEDAY3</tag>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RN 中 ES6 书写规范]]></title>
    <url>%2FReactES6%2F</url>
    <content type="text"><![CDATA[前言很多时候我们学会了很多东西,但是不知道 怎么用、如何用、在哪用这时这篇文章就显得 很有用 了。参考依照：ES5 ES6写法对照表 模块引用import &#123; Image, Text&#125; from 'react-native' 导出单个类/* 导出 */export default class MyComponent extends Component&#123; ...&#125;/* 引入 */import MyComponent from './MyComponent'; 组件定义组件class Photo extends React.Component &#123; render() &#123; return ( &lt;Image source=&#123;this.props.source&#125; /&gt; ); &#125;&#125; 给组件定义方法class Photo extends React.Component &#123; componentWillMount() &#123; &#125; render() &#123; return ( &lt;Image source=&#123;this.props.source&#125; /&gt; ); &#125;&#125; 定义组件的 属性类型 和 默认属性在ES6里，可以统一使用 static 成员来实现 class Video extends React.Component &#123; static defaultProps = &#123; autoPlay: false, maxLoops: 10, &#125;; // 注意这里有分号 static propTypes = &#123; // 定义 autoPlay必须是 布尔值 autoPlay: React.PropTypes.bool.isRequired, maxLoops: React.PropTypes.number.isRequired, posterFrameSrc: React.PropTypes.string.isRequired, videoSrc: React.PropTypes.string.isRequired, &#125;; // 注意这里有分号 render() &#123; return ( &lt;View /&gt; ); &#125; // 注意这里既没有分号也没有逗号&#125; 初始化 STATE第一种写法：方便、简单 class Video extends React.Component &#123; state = &#123; loopsRemaining: this.props.maxLoops, &#125;&#125; 第二种写法：语法上易理解，可以根据需要做一些计算 class Video extends React.Component &#123; constructor(props)&#123; super(props); this.state = &#123; loopsRemaining: this.props.maxLoops, &#125;; &#125;&#125; 把方法作为 回调在ES6下，需要通过bind来绑定this引用，或者使用箭头函数来调用 class PostInfo extends React.Component&#123; handleOptionsButtonClick(e)&#123; this.setState(&#123;showOptionsModal: true&#125;); &#125; render()&#123; return ( &lt;TouchableHighlight onPress=&#123;this.handleOptionsButtonClick.bind(this)&#125; // bind绑定 onPress=&#123;e=&gt;this.handleOptionsButtonClick(e)&#125; // 箭头函数 &gt; &lt;Text&gt;&#123;this.props.label&#125;&lt;/Text&gt; &lt;/TouchableHighlight&gt; ) &#125;,&#125; 需要注意的是，不论是bind还是箭头函数，每次被执行都返回的是一个新的函数引用，因此如果你还需要函数的引用去做一些别的事情（譬如卸载监听器），那么你必须自己保存这个引用 class PauseMenu extends React.Component&#123; constructor(props)&#123; super(props); this._onAppPaused = this.onAppPaused.bind(this); &#125; componentWillMount()&#123; AppStateIOS.addEventListener('change', this._onAppPaused); &#125; componentDidUnmount()&#123; AppStateIOS.removeEventListener('change', this._onAppPaused); &#125; onAppPaused(event)&#123; &#125;&#125;]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>书写规范</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-native 笔记]]></title>
    <url>%2FReact-native%2F</url>
    <content type="text"><![CDATA[前言 对中文网的的 ReactNative 的内容进行的 提炼 对其中的内容进行了 简化 对一些我个人认为较复杂且不常用的功能或概念 采取忽略 对 ReactNative 不了解 的同学可能会有一点帮助 如笔记整理有错误还请 留言 深度阅读请访问 ReactNative中文网 ReactNative 使用安装运行 ReactNative react-native init AwesomeProject cd AwesomeProject &amp;&amp; react-native run-ios 提示: version参数 可用来指定版本,例如 react-native init MyApp --version 0.44.3。 Hello World/* 引用 React 的默认方法 与 Component 组件 */import React, &#123; Component &#125; from 'react';/* 引用 react-native 的AppRegister 与 Text 组件 */import &#123; AppRegistry, Text &#125; from 'react-native';/* 定义 Hello 组件 并扩展到 react 的 Component 中*/class Hello extends Component &#123; /* JSX 渲染语法 */ render() &#123; return ( &lt;Text&gt;Hello world!&lt;/Text&gt; ); &#125;&#125;/* AppRegistry的内置模块对 Hello组件 进行了“注册”操作,在整个应用里只会用一次 */AppRegistry.registerComponent('Hello', () =&gt; Hello); Props(属性)多数组件在创建时就可使用 props参数 来定制。 Image组件使用 propsimport React, &#123; Component &#125; from 'react';import &#123; AppRegistry, Image &#125; from 'react-native';class Bananas extends Component &#123; render() &#123; let pic = &#123; uri: 'https://upload.wikimedia.org/wikipedia/commons/d/de/Bananavarieties.jpg' &#125;; return ( &lt;Image source=&#123;pic&#125; style=&#123;&#123;width: 193, height: 110&#125;&#125; /&gt; ); &#125;&#125;AppRegistry.registerComponent('Bananas', () =&gt; Bananas); 自定义的组件使用 props State(状态) RN中可通过 props 和 state 来控制一个组件 props 数据是在父组件中指定，仅生效一次 state 数据可根据需求进行改写 constructor 可用来初始化state ,需要改写时调用 setState 方法 文字变换例子 Style(样式) 按照JS的语法要求使用了驼峰命名法 StyleSheet.create 来集中定义组件的样式 import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, StyleSheet, Text, View &#125; from 'react-native';class LotsOfStyles extends Component &#123; render() &#123; return ( &lt;View&gt; &lt;Text style=&#123;styles.red&#125;&gt;just red&lt;/Text&gt; &lt;Text style=&#123;styles.bigblue&#125;&gt;just bigblue&lt;/Text&gt; /* 常见的做法是按顺序使用属性，即后属性会覆盖前属性 */ &lt;Text style=&#123;[styles.bigblue, styles.red]&#125;&gt;bigblue, then red&lt;/Text&gt; &lt;Text style=&#123;[styles.red, styles.bigblue]&#125;&gt;red, then bigblue&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; bigblue: &#123; color: 'blue', fontWeight: 'bold', fontSize: 30, &#125;, red: &#123; color: 'red', &#125;,&#125;);AppRegistry.registerComponent('LotsOfStyles', () =&gt; LotsOfStyles); Flexbox 布局 flexDirection 的默认值是 column 而不是row，而flex也只能指定一个数字值。 Flexbox 主要三属性 flexDirection justifyContent alignItems 居中排列 import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, View &#125; from 'react-native';class AlignItemsBasics extends Component &#123; render() &#123; return ( // 尝试把`alignItems`改为`flex-start`看看 // 尝试把`justifyContent`改为`flex-end`看看 // 尝试把`flexDirection`改为`row`看看 &lt;View style=&#123;&#123; flex: 1, flexDirection: 'row', justifyContent: 'center', alignItems: 'center', &#125;&#125;&gt; &lt;View style=&#123;&#123;width: 50, height: 50, backgroundColor: 'powderblue'&#125;&#125; /&gt; &lt;View style=&#123;&#123;width: 50, height: 50, backgroundColor: 'skyblue'&#125;&#125; /&gt; &lt;View style=&#123;&#123;width: 50, height: 50, backgroundColor: 'steelblue'&#125;&#125; /&gt; &lt;/View&gt; ); &#125;&#125;;AppRegistry.registerComponent('AwesomeProject', () =&gt; AlignItemsBasics); TextInput TextInput 是一个允许用户输入文本的基础组件。 onChangeText 属性接受一个函数，而此函数会在 文本变化时 被调用。 onSubmitEditing 属性，会在 文本被提交后（用户按下软键盘上的提交键）调用。 ScrollView ScrollView 是一个通用的可滚动的容器，其中可放入多个组件和视图，不区分类型,可以 水平滚动 ScrollView 适合用来显示 数量不多 的滚动元素 import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, StyleSheet, Text, View, ScrollView, Image&#125; from 'react-native';export default class testApp extends Component &#123; render() &#123; return( &lt;ScrollView&gt; &lt;Text style=&#123;&#123;fontSize:96&#125;&#125;&gt;Scroll me plz&lt;/Text&gt; &lt;Image source=&#123;require('./src/img/aaa.png')&#125; style=&#123;&#123;height:200,width:200&#125;&#125;/&gt; &lt;Image source=&#123;require('./src/img/aaa.png')&#125; style=&#123;&#123;height:200,width:200&#125;&#125;/&gt; &lt;Image source=&#123;require('./src/img/bbb.jpeg')&#125; style=&#123;&#123;height:200,width:200&#125;&#125;/&gt; &lt;Image source=&#123;require('./src/img/aaa.png')&#125; style=&#123;&#123;height:200,width:200&#125;&#125;/&gt; &lt;Image source=&#123;require('./src/img/aaa.png')&#125; style=&#123;&#123;height:200,width:200&#125;&#125;/&gt; &lt;Text style=&#123;&#123;fontSize:96&#125;&#125;&gt;If you like&lt;/Text&gt; &lt;Image source=&#123;require('./src/img/bbb.jpeg')&#125; style=&#123;&#123;height:200,width:200&#125;&#125;/&gt; &lt;Text style=&#123;&#123;fontSize:80&#125;&#125;&gt;React Native&lt;/Text&gt; &lt;/ScrollView&gt; ); &#125;&#125;AppRegistry.registerComponent('testApp', () =&gt; testApp); ListView RN 中展示长列表数据的常用组件有俩个 FlatList SectionList FlatList 组件 特点 适用展示一组 仅数据不同的垂直滚动列表 适用 长列表数据 且元素的个数可以增删 FlatList 优先渲染屏幕上可见的元素 使用 FlatList 组件 必须 的两个属性是 data 和 renderItem 。 data 是列表的 数据源 renderItem 是从数据源中逐个 解析数据 ，然后返回一个设定好格式的组件来渲染。 import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, StyleSheet, Text, View, ScrollView, Image, FlatList&#125; from 'react-native';export default class testApp extends Component &#123; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;FlatList data=&#123;[ &#123;key: 'Devin'&#125;, &#123;key: 'Jackson'&#125;, &#123;key: 'James'&#125;, &#123;key: 'Joel'&#125;, &#123;key: 'John'&#125;, &#123;key: 'Jillian'&#125;, &#123;key: 'Jimmy'&#125;, &#123;key: 'Julie'&#125;, &#123;key: 'Julie'&#125;, &#123;key: '白晓健'&#125;, &#123;key: '白晓建'&#125;, &#123;key: '白晓见'&#125;, &#123;key: '白小剑'&#125;, ]&#125; // renderItem 一个对象, 里面有一个箭头函数其参数是一个对象,对象的值时 data 中的 每一项 renderItem=&#123;(&#123;item&#125;) =&gt; &#123; return &lt;Text style=&#123;styles.item&#125;&gt; 你好&#123;item.key&#125; ,welcome &lt;/Text&gt; &#125;&#125; /&gt; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, paddingTop: 22, &#125;, item: &#123; padding: 10, fontSize: 18, height: 44, backgroundColor:'pink' &#125;,&#125;)AppRegistry.registerComponent('testApp', () =&gt; testApp); SectionList如果想提供一组数据分成 逻辑部分 或 章节标题 ，可以使用 SectionList 。 网络请求(fetch)发起网络请求想从地址获取内容,只需将网址作为参数即可 export default class testApp extends Component &#123; state = &#123; movies:[ &#123;key: '白晓健'&#125;, &#123;key: '白晓建'&#125;, &#123;key: '白晓见'&#125;, &#123;key: '白小剑'&#125;, ], &#125;; fatchData=()=&gt;&#123; fetch('https://api.douban.com/v2/movie/in_theaters') // 转换成 Text 是为了当意外发生时,更容易锁定错误 .then((response) =&gt; response.text()) .then((responseText) =&gt; &#123; const json = JSON.parse(responseText); console.log(json) // 重新设置 state 中 movies 的 值,也就是给 movies 赋值 this.setState(&#123;movies:json.subjects&#125;); &#125;) .catch((error) =&gt; &#123; console.error(error); &#125;); &#125; componentDidMount() &#123; this.fatchData() &#125; render() &#123; return ( // const &#123; movies &#125; = this.state; &lt;View style=&#123;styles.container&#125;&gt; &lt;FlatList data=&#123;this.state.movies&#125; // 一个对象 里面有一个 renderItem=&#123;(&#123;item&#125;) =&gt; &#123; return &lt;Text style=&#123;styles.item&#125;&gt; 你好,&#123;item.title&#125; ,welcome &lt;/Text&gt; &#125;&#125; /&gt; &lt;/View&gt; ); &#125;&#125; fetch 的第二个可选参数,可用来定制HTTP请求一些参数 /* 指定header参数，指定使用POST方法，提交数据 */fetch('https://mywebsite.com/endpoint/', &#123; method: 'POST', headers: &#123; 'Accept': 'application/json', 'Content-Type': 'application/json', &#125;, body: JSON.stringify(&#123; firstParam: 'yourValue', secondParam: 'yourOtherValue', &#125;)&#125;) 处理响应数据 网络请求天生就是一种异步操作 Fetch 方法会返回一个 Promise实例 ，其用意是简化异步风格的代码 默认情况下，iOS会 阻止所有非https的请求 ,解决方案 getMoviesFromApiAsync() &#123; return fetch('https://facebook.github.io/react-native/movies.json') .then((response) =&gt; response.json()) .then((responseJson) =&gt; &#123; return responseJson.movies; &#125;) .catch((error) =&gt; &#123; console.error(error); &#125;); &#125; RN 应用中使用 ES7标准中 的async/await 语法： // 注意这个方法前面有async关键字 async getMoviesFromApi() &#123; try &#123; // 注意这里的await语句，其所在的函数必须有async关键字声明 let response = await fetch('https://facebook.github.io/react-native/movies.json'); let responseJson = await response.json(); return responseJson.movies; &#125; catch(error) &#123; /* 别忘了catch住fetch可能抛出的异常，否则出错时你可能看不到任何提示。 */ console.error(error); &#125; &#125; 使用其他的网络库 RN 中已经内置了 XMLHttpRequest 也就是 ajax 基于 XMLHttpRequest 封装的第三方库有 frisbee 或是 axios 等 没有跨域限制 WebSocketRN 支持 WebSocket，这种协议可以在单个 TCP 连接上提供 全双工 的通信信道 深度阅读 使用导航器跳转页面从0.44版本开始， Navigator 被从react native的核心组件库中 抽离 到了一个名为 react-native-deprecated-custom-components 的单独模块中。如果需要继续使用 Navigator ，则需要先 yarn add react-native-deprecated-custom-components 安装，然后从这个模块中 import，即 import { Navigator } from &#39;react-native-deprecated-custom-components&#39; . React Navigation社区今后主推的方案是一个 单独 的导航库 react-navigation ，它的使用十分简单。 详细了解 首先是在当前应用中安装此库 yarn add react-navigation 基本例子 import React from 'react';import &#123; AppRegistry, Text, View, Button&#125; from 'react-native';import &#123; StackNavigator &#125; from 'react-navigation';/* 导入组件 */import Detail from './src/components/Detail';import ChatScreen from './src/components/Chat';import TestScreen from './src/components/Test';class HomeScreen extends React.Component &#123; /* 定义本页面的导航栏设置*/ static navigationOptions = &#123; /* 定义标题,此标题也是跳入其他页面时返回键上的信息 */ title: 'Welcome', &#125;; render() &#123; /* 使标题生效 */ const &#123; navigate &#125; = this.props.navigation; return ( &lt;View&gt; &lt;Text&gt;Hello, Chat App!&lt;/Text&gt; &lt;Button /* 设置文本点击事件,进入指定组件 */ onPress=&#123;() =&gt; navigate('Chat')&#125; title="Chat with Lucy" /&gt; &lt;/View&gt; ); &#125;&#125;/* 在根文件中用 StackNavigator 声明这些组件(类似于定义路由),键就是 路由名称 */const testApp = StackNavigator(&#123; Home: &#123; screen: HomeScreen &#125;, aaa: &#123; screen: Detail &#125;, Chat: &#123; screen: ChatScreen &#125;, Test: &#123; screen: TestScreen &#125;,&#125;);AppRegistry.registerComponent('testApp', () =&gt; testApp); 图片静态图片资源引用方式// 正确&lt;Image source=&#123;require('./my-icon.png')&#125; /&gt;// 错误var icon = this.props.active ? 'my-icon-active' : 'my-icon-inactive';&lt;Image source=&#123;require('./' + icon + '.png')&#125; /&gt;// 正确var icon = this.props.active ? require('./my-icon-active.png') : require('./my-icon-inactive.png');&lt;Image source=&#123;icon&#125; /&gt; 注意:require中的图片名字必须是一个静态字符串, 不能使用变量 ！ 静态非图片资源require 语法也可以用来静态地加载你项目中的声音、视频或者文档等文件。 注意: 视频必须指定尺寸 而不能使用flex样式. 网络图片// 正确&lt;Image source=&#123;&#123;uri: 'https://facebook.github.io/react/img/logo_og.png'&#125;&#125; style=&#123;&#123;width: 400, height: 400&#125;&#125; /&gt;// 错误&lt;Image source=&#123;&#123;uri: 'https://facebook.github.io/react/img/logo_og.png'&#125;&#125; /&gt; 可携带参数 &lt;Image source=&#123;&#123; uri: 'https://facebook.github.io/react/img/logo_og.png', method: 'POST', headers: &#123; Pragma: 'no-cache' &#125;, body: 'Your Body goes here'&#125;&#125;style=&#123;&#123;width: 400, height: 400&#125;&#125; /&gt; 背景图片组件开发者们常面对的一种需求就是类似web中的背景图（background-image）。要实现这一用例，只需简单使用组件，然后把需要背景图的子组件嵌入其中即可。 return ( &lt;ImageBackground source=&#123;...&#125;&gt; &lt;Text&gt;Inside&lt;/Text&gt; &lt;/ImageBackground&gt;); 处理触摸事件点击事件class MyButton extends Component &#123; _onPressButton() &#123; console.log("You tapped the button!"); &#125; render() &#123; return ( &lt;TouchableHighlight onPress=&#123;this._onPressButton&#125;&gt; &lt;Text&gt;Button&lt;/Text&gt; &lt;/TouchableHighlight&gt; ); &#125;&#125; 具体使用哪种组件，取决于希望给用户什么样的视觉反馈： TouchableHighlight:来制作按钮或者链接。用户手指按下时 背景变暗 TouchableNativeFeedback:用户手指按下时形成类似 墨水涟漪 的视觉效果(限Android) TouchableOpacity:会在用户手指按下时 降低透明度 TouchableWithoutFeedback:点击事件的时 无效果 某些场景中你可能需要检测用户是否进行了 长按操作 。可以在上面列出的任意组件中使用 onLongPress 属性来实现。 列表滑动 ScrollView 可实现用户会在列表中或快或慢的 各种滑动 还可以配置 pagingEnabled 属性来让用户 整屏滑动 水平方向的滑动还可以使用Android上的 ViewPagerAndroid 组件。 ListView 是一种特殊的ScrollView，用于显示 较长垂直列表 动画 RN 提供了两个互补的动画系统： 用于 全局 的布局动画 LayoutAnimation 用于创建更 精细 的交互控制的动画 Animated 深度阅读 定时器RN 实现了和浏览器一致的定时器 Timer 。 定时器 setTimeout, clearTimeout setInterval, clearInterval setImmediate, clearImmediate requestAnimationFrame, cancelAnimationFrame setImmediate 和 setTimeout 有略微不同.requestAnimationFrame 和 setInterval 有略微不同. 详细阅读 注意: 卸载组件前务必清除定时器 直接操作在 RN 中， setNativeProps 就是等价于直接在底层操作DOM节点的方法。 注意: 在使用 setNativeProps 之前,先尝试用 setState 或 shouldComponentUpdate 方法来解决问题 ReactNative 问题端口占用当运行时提示 “Packager can’t listen on port 8081” ，说明 8081 端口被占用 第一种 检查占用端口的程序并关闭 第二种 启动服务时指定端口号 react-native start --port 8083 手动修改项目下的 node_modules/react-native/local-cli/server/server.js 中的 port 字段]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-redux 笔记]]></title>
    <url>%2FReact-redux%2F</url>
    <content type="text"><![CDATA[未完待续简介如果你的应用有以下场景，可以考虑使用 Redux。 某个组件的状态 需要共享 某个状态需要在 任何地方 都可以获取 一个组件想要 改变全局状态 一个组件想要 改变另一个组件状态 核心思想 web 应用是一个 状态机 ，视图与状态是 相对应 的,并且 所有的状态都保存在一个对象里。 基本概念和 APIStore Store 就是保存数据的地方，你可以把它看成一个容器。 整个应用只能有一个 Store。 import &#123; createStore &#125; from 'redux';const store = createStore(reducer);/* createStore函数接受另一个函数作为参数，返回新生成的 Store 对象。 */ State Store对象包含所有数据。 store.getState() 可获得当前 State import &#123; createStore &#125; from 'redux';const store = createStore(reducer);const state = store.getState();/* * Redux 规定， 一个 State 对应一个 View。 * 只要 State 相同，View 就相同。 * 你知道 State，就知道 View 是什么样，反之亦然。 */ Action Action 只是一个对象 Action 可改变 State, 其变化会同步到 View type属性必须 ，表示 Action 的名称,其他属性随意 const action = &#123; type: 'ADD_TODO', payload: 'Learn Redux'&#125;; Action CreatorView 要发送多少种消息，就会有多少种 Action。如果都手写，会很麻烦。可以定义一个函数来生成 Action，这个函数就叫 Action Creator。 const ADD_TODO = '添加 TODO';function addTodo(text) &#123; return &#123; type: ADD_TODO, text &#125;&#125;const action = addTodo('Learn Redux');/* addTodo函数就是一个 Action Creator。 */ store.dispatch()store.dispatch()是 View 发出 Action 的唯一方法。 import &#123; createStore &#125; from 'redux';const store = createStore(reducer);/* store.dispatch接受一个 Action 对象作为参数，将它发送出去。*/store.dispatch(&#123; type: 'ADD_TODO', payload: 'Learn Redux'&#125;);/* 结合 Action Creator，这段代码可以改写如下。 */store.dispatch(addTodo('Learn Redux')); Reducer Reducer 是一个函数 接受 当前State 和 Action 作为参数并返回新的 State const chatReducer = (state = defaultState, action = &#123;&#125;) =&gt; &#123; const &#123; type, payload &#125; = action; switch (type) &#123; case ADD_CHAT: return Object.assign(&#123;&#125;, state, &#123; chatLog: state.chatLog.concat(payload) &#125;); case CHANGE_STATUS: return Object.assign(&#123;&#125;, state, &#123; statusMessage: payload &#125;); case CHANGE_USERNAME: return Object.assign(&#123;&#125;, state, &#123; userName: payload &#125;); default: return state; &#125;&#125;; store.subscribe() store.subscribe 方法是用来设置监听函数，一旦 State 发生变化，就自动执行这个函数。 import &#123; createStore &#125; from 'redux';const store = createStore(reducer);/** * 把 View 的更新函数（对于 React 项目，就是组件的render方法或setState方法）放入listen，就会实现 View 的自动渲染。 */let unsubscribe = store.subscribe(listener);/* store.subscribe 方法返回一个函数，调用该函数就可以 解除监听 。 */unsubscribe(); 流程步骤 首先需要在 reducer 函数内,定义 type 值和默认值对应的操作 把 reducer 函数放到 storeCreate(reducer) 进行初始化 ,初始化时 返回的是 reducer 函数内的默认值 通过 store.dispatch({type:’xxx’,value:123}) 来发送 Action 数据格式,以此来触发 reducer 函数,并更新 state 当前值 在通过 store.subscribe 检测 State 的变化,以此来更新 View]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 笔记]]></title>
    <url>%2FReact%2F</url>
    <content type="text"><![CDATA[注意点 注意区分大小写 单标签后面一定要有 / 闭合符 ReactDOM.render() React 的最基本方法，用于 将模板转为 HTML 语言，并插入到指定的 DOM 节点。 JSX 语法 JSX 的基本语法规则： 遇到 HTML 标签（以 &lt; 开头），就用 HTML 规则解析； 遇到代码块（以 { 开头），就用 JavaScript 规则解析; JSX 允许直接在模板插入 JS 变量 {x}。 如果这个变量是一个数组，则会展开这个数组的所有成员 组件React 允许将代码封装成组件（component），然后像插入普通 HTML 标签一样，在网页中插入这个组件。 组建类的第一个字母必须大写,否则会报错 组件类只能包含一个顶层标签,否则也会报错 组件可以任意加属性 比如 &lt;HelloMessage name=&quot;John&quot;&gt; 组件的属性可以在组件类的 this.props对象上获取 比如 this.props.John 添加组件属性，保留字需要注意就是 class 属性需要写成 className for 属性需要写成 htmlFor this.props.children this.props 对象的属性与组件的属性一一对应. this.props.children 属性,表示组件的所有子节点 React.Children.map 是专门来遍历 this.props.children 的一个方法 PropTypes 组件的属性可以接受任意值，字符串、对象、函数等等都可以。 有时，我们需要一种机制，验证别人使用组件时，提供的参数是否符合要求。 getDefaultProps 方法可以用来设置组件属性的默认值。 获取真实的DOM节点 组件是存在于内存之中的一种数据结构，叫做虚拟(virtual) DOM,只有当它插入文档以后，才会变成真实的 DOM 。 React 中所有的 DOM 变动之前都先在虚拟 DOM 上发生，然后再将 实际发生变动 的部分，反映在真实DOM上，这种算法叫做 DOM diff ，它可以极大提高网页的性能表现。 但是，有时需要从组件获取真实 DOM 的节点，这时就要用到 ref 属性. var MyComponent = React.createClass(&#123; handleClick: function() &#123; this.refs.myTextInput.focus(); &#125;, render: function() &#123; return ( &lt;div&gt; &lt;input type="text" ref="myTextInput" /&gt; &lt;input type="button" value="Focus the text input" onClick=&#123;this.handleClick&#125; /&gt; &lt;/div&gt; ); &#125;&#125;);ReactDOM.render( &lt;MyComponent /&gt;, document.getElementById('example')); 组件 MyComponent 的子节点有一个文本输入框，用于获取用户的输入。 这时就必须获取真实的 DOM 节点，虚拟 DOM 是拿不到用户输入的。 为了做到这一点，文本输入框 必须有一个 ref 属性，然后 this.refs.[refName] 就会返回这个真实的 DOM 节点。 由于 this.refs.[refName] 属性获取的是 真实 DOM ，所以必须等到虚拟 DOM 插入文档以后，才能使用这个属性，否则会报错。 上面代码中，通过为组件指定 Click 事件的回调函数，确保了只有等到真实 DOM 发生 Click 事件之后，才会读取 this.refs.[refName] 属性。 this.stateReact 中将组件看成是一个状态机，开始有一个初始状态，然后用户互动，导致状态变化，从而触发重新渲染 UI var LikeButton = React.createClass(&#123; getInitialState: function() &#123; return &#123;liked: false&#125;; &#125;, handleClick: function(event) &#123; this.setState(&#123;liked: !this.state.liked&#125;); &#125;, render: function() &#123; var text = this.state.liked ? 'like' : 'haven\'t liked'; return ( &lt;p onClick=&#123;this.handleClick&#125;&gt; You &#123;text&#125; this. Click to toggle. &lt;/p&gt; ); &#125;&#125;);ReactDOM.render( &lt;LikeButton /&gt;, document.getElementById('example')); LikeButton 组件中的 getInitialState 方法用于定义初始状态，也就是一个对象，这个对象可以通过 this.state 属性读取。 当用户点击组件，导致状态变化，this.setState 方法就修改状态值，每次修改以后，自动调用 this.render 方法，再次渲染组件。 由于 this.props 和 this.state 都用于描述组件的特性，可能会产生混淆。 this.props 表示那些一旦定义，就不再改变的特性 this.state 是会随着用户互动而产生变化的特性 表单类似于双向数据绑定 var Input = React.createClass(&#123; getInitialState: function() &#123; return &#123;value: 'Hello!'&#125;; &#125;, handleChange: function(event) &#123; this.setState(&#123;value: event.target.value&#125;); &#125;, render: function () &#123; var value = this.state.value; return ( &lt;div&gt; &lt;input type="text" value=&#123;value&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;p&gt;&#123;value&#125;&lt;/p&gt; &lt;/div&gt; ); &#125;&#125;);ReactDOM.render(&lt;Input/&gt;, document.body); 文本输入框的值，不能用 this.props.value 读取，而要定义一个 onChange 事件的回调函数，通过 event.target.value 读取用户输入的值。 组建的生命周期 组件周期的三个状态 Mounting：已插入真实 DOM Updating：正在被重新渲染 Unmounting：已移出真实 DOM React 为每个状态都提供了两种处理函数，will 函数在进入状态之前调用，did 函数在进入状态之后调用 componentWillMount() componentDidMount() componentWillUpdate(object nextProps, object nextState) componentDidUpdate(object prevProps, object prevState) componentWillUnmount() 此外，React 还提供两种特殊状态的处理函数。 componentWillReceiveProps(object nextProps)：已加载组件收到新的参数时调用 shouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用 参考自:阮一峰入门实例教程]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 笔记]]></title>
    <url>%2FHexo%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[基本操作常用命令 命令 说明 hexo n “我的博客” hexo new “我的博客” #新建文章 hexo p hexo publish hexo g hexo generate#生成 hexo s hexo server #启动服务预览 hexo d hexo deploy#部署 hexo d #部署 #可与hexo g合并为 hexo d -g 服务器 命令 说明 hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器 hexo server -s #静态模式 hexo server -p 5000 #更改端口 hexo server -i 192.168.1.1 #自定义 IP hexo clean #清除缓存 网页正常情况下可以忽略此条命令 完成后部署 命令 说明 hexo g #生成静态网页 hexo d #开始部署 模版 命令 说明 hexo new “postName” #新建文章 hexo new page “pageName” #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server） hexo deploy #将.deploy目录部署到GitHub 写作 变量 描述 :title 标题 :year 建立的年份（4 位数） :month 建立的月份（2 位数） :i_month 建立的月份（去掉开头的零） :day 建立的日期（2 位数） :i_day 建立的日期（去掉开头的零） 示例： title: 搭建个人博客layout: postdate: 2020-01-01 12:00:00comments: truecategories: Blogtags: [Hexo]words: Hexo, Blogdescription: 搭建个人博客还是要用 Hexo 书写语法自定义图片大小标准：&#123;% img [class names] /path/image [width] [height] [title text [alt text]] %&#125;例如：&#123;% img /imgs/baiyan.jpg 100 50 %&#125; 突破容器宽度限制的图片的三种方式当使用此标签引用图片时，图片将自动扩大 26%，并突破文章容器的宽度。 此标签使用于需要突出显示的图片, 图片的扩大与容器的偏差从视觉上 提升图片的吸引力 。 &lt;img src=&quot;/image-url&quot; class=&quot;full-image&quot; /&gt;&#123;% fullimage /image-url, alt, title %&#125;&#123;% fi /image-url, alt, title %&#125; Bootstrap Callout&#123;% note class_name %&#125; Content (md partial supported) &#123;% endnote %&#125; 其中，class_name 可以是以下列表中的一个值： default 默认 primary 提示 success 成功 info 提示 warning 警告 danger 危险 从书中引用新：DevDocs现在附带语法高亮。http://devdocs.io @DevDocstwitter.com/devdocs/status/356095192085962752 文本居中的引用3中方式&lt;blockquote class=&quot;blockquote-center&quot;&gt;blah blah blah&lt;/blockquote&gt;&#123;% centerquote %&#125;blah blah blah&#123;% endcenterquote %&#125;&#123;% cq %&#125;人一切的痛苦，本质上都是对自己的无能的愤怒&#123;% endcq %&#125; 推荐]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 笔记]]></title>
    <url>%2Fes6%2F</url>
    <content type="text"><![CDATA[前言 对阮一峰的ES6的内容进行的 提炼 对其中的内容进行了 简化 对一些我个人认为较复杂且不常用的功能或概念 采取忽略 对ES6 不熟悉 的同学 可能会有一点帮助 如笔记整理有错误还请留言 指出 深度阅读请访问 http://es6.ruanyifeng.com let 与 const代码块：外层作用域无法读取内层作用域中的变量 共同点 只在块级作用域中有效 暂时性死区 不允许重复声明 不存在变量提升 不同点 const 声明时 必须赋值 并且 值不可变 关于解析赋值数组的数组的元素是按 次序排列 的，变量的取值要与位置匹配 典型例子 let [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4]let [x, y, ...z] = ['a'];x // "a"y // undefinedz // []let [a, [b], d] = [1, [2, 3], 4];a // 1b // 2d // 4 设置默认值 ：解构赋值允许指定默认值。 let [x, y = 'b'] = ['a']; // x='a', y='b'let [x, y = 'b'] = ['a', undefined]; // x='a', y='b'-------------------------------------------function f() &#123; console.log('aaa');&#125;// 函数 f 没有执行，因为 x 的值是 1 不属于 undefinedlet [x = f()] = [1]; 对象的对象的属性虽没有次序，但变量必须与属性同名 典型例子 let &#123; bar, foo &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;foo // "aaa"bar // "bbb"let &#123; baz &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;baz // undefined-------------------------------------------/* 如果变量名与属性名不一致，必须写成下面这样。*//***********注意:对于let和const来说，变量不能重新声明，所以一旦赋值的变量以前声明过，就会报错。************/let obj = &#123; first: 'hello', last: 'world' &#125;;let &#123; first: f, last: l &#125; = obj;f // 'hello'l // 'world'-------------------------------------------/***********下面代码中，let命令下面一行的圆括号是必须的，否则会报错。因为解析器会将起首的大括号，理解成一个代码块，而不是赋值语句。************/let foo;(&#123;foo&#125; = &#123;foo: 1&#125;); // 成功let baz;(&#123;bar: baz&#125; = &#123;bar: 1&#125;); // 成功 设置默认值 ：解构赋值允许指定默认值。 var &#123;x = 3&#125; = &#123;&#125;;x // 3var &#123;x, y = 5&#125; = &#123;x: 1&#125;;x // 1y // 5var &#123;x:y = 3&#125; = &#123;&#125;;y // 3var &#123;x:y = 3&#125; = &#123;x: 5&#125;;y // 5var &#123; message: msg = 'Something went wrong' &#125; = &#123;&#125;;msg // "Something went wrong" 函数的 经典范例 /* 函数move的参数是一个对象，如果通过解构，得不到变量x或y的值，那么x和y等于默认值。*/function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, 0]. 因为 x 有值 就会赋值 ，y 没有值 就是默认值move(&#123;&#125;); // [0, 0]move(); // [0, 0]-------------------------------------------/* undefined就会触发函数参数的默认值。 */[1, undefined, 3].map((x = 'yes') =&gt; x);// [ 1, 'yes', 3 ] 基本用途交换变量的值 上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。 let x = 1;let y = 2;[x, y] = [y, x]; 从函数返回多个值 函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。 // 返回一个数组function example() &#123; return [1, 2, 3];&#125;let [a, b, c] = example();// 返回一个对象function example() &#123; return &#123; foo: 1, bar: 2 &#125;;&#125;let &#123; foo, bar &#125; = example(); 函数参数的定义 解构赋值可以方便地将一组参数与变量名对应起来。 // 参数是一组有次序的值function f([x, y, z]) &#123; ... &#125;f([1, 2, 3]);// 参数是一组无次序的值function f(&#123;x, y, z&#125;) &#123; ... &#125;f(&#123;z: 3, y: 2, x: 1&#125;); 提取JSON数据 解构赋值对提取JSON对象中的数据，尤其有用。 let jsonData = &#123; id: 42, status: "OK", data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 42, "OK", [867, 5309] 函数参数的默认值 指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || ‘default foo’;这样的语句。 jQuery.ajax = function (url, &#123; async = true, beforeSend = function () &#123;&#125;, cache = true, complete = function () &#123;&#125;, crossDomain = false, global = true, // ... more config&#125;) &#123; // ... do stuff&#125;; 遍历Map结构 ap结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就非常方便。 var map = new Map();map.set('first', 'hello');map.set('second', 'world');for (let [key, value] of map) &#123; console.log(key + " is " + value);&#125;// first is hello// second is world-------------------------------------------/* 如果只想获取键名，或者只想获取键值，可以写成下面这样。 */// 获取键名for (let [key] of map) &#123; // ...&#125;// 获取键值for (let [,value] of map) &#123; // ...&#125; 输入模块的指定方法 加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。 const &#123; SourceMapConsumer, SourceNode &#125; = require("source-map"); 关于类型的扩展字符串扩展–模板字符串// 普通字符串输出： '\n' 换行，trim（） 消除字符前后空格` In JavaScript '\n' is a line-feed. `.trim()// 字符串中嵌入变量 : `$&#123;&#125;`var name = "Bob";`Hello $&#123;name&#125;,`// 大括号内部可以进行运算var x = 1，y = 2;`$&#123;x + y&#125;`// "3"// 大括号内部可以调用函数function fn() &#123; return "Hello World";&#125;`foo $&#123;fn()&#125; bar`// foo Hello World bar 正则的扩展–后行断言目前，有一个 提案 ，引入后行断言。 /* 先行断言 ,只匹配百分号之前的数字 *//\d+(?=%)/.exec('of US presidents 100% have been male') //["100"]/* 后行断言 ,只匹配百分号之后的数字 *//(?&lt;=\$)\d+/.exec('Benjamin Franklin is on the $100 bill') //["100"] 数值的扩展 方法 作用 Number.isNaN() 判断值是否为NaN，为NaN返回true Number.parseInt()/parseFloat() ES6将这俩个全局方法移植到了Number对象上 Number.isInteger() 判断值是否为整数 Math.trunc() 返回整数部分 Math.sign() 判断一个数是正数、负数、0，对应返回值 +1、-1、0 数组的扩展Array.from(对象，_对象处理函数，_this指向)可将 数组的对象 和 可遍历的对象 转换为数组结构 /* 类似数组的对象 */let arrayLike = &#123; '0': 'a', '1': 'b', '2': 'c', length: 3&#125;;let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']/******************************************************//* 可遍历的对象 */let namesSet = new Set(['a', 'b']) // nameSet &#123;'a','b'&#125;Array.from(namesSet) // ['a', 'b'] Array.of()将一组值转换为数组 Array.of(3, 11, 8) // [3,11,8]Array.of(3) // [3]Array.of(3,2).length // 2 find()、findIndex()、includes() find 方法，用于找出 第一个 符合条件的数组中的值，否则返回 undefined findIndex 返回 第一个 符合条件的位置，否则返回-1。 includes() 和 indexOf() 很像，前者返回布尔值后者返回数值 [1, 4, -5, 10].find((n) =&gt; n &lt; 0)// -5[1, 5, 10, 15].findIndex(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 2 数组的遍历entries() 、keys()、values() for (let index of ['a', 'b'].keys()) &#123; console.log(index);&#125;// 0// 1for (let elem of ['a', 'b'].values()) &#123; console.log(elem);&#125;// 'a'// 'b'for (let [index, elem] of ['a', 'b'].entries()) &#123; console.log(index, elem);&#125;// 0 "a"// 1 "b" 函数的扩展函数参数的默认值 函数内部是不可以再次声明形参 函数的执行时形参会形成作用域 函数体内&gt;形参内&gt;全局内 /* 如实例化时x、y没有传入参数，那么x、y的默认值就是 0 */function Point(x = 0, y = 0) &#123; this.x = x; this.y = y; //&#125;var p = new Point();p // &#123; x: 0, y: 0 &#125;/* 调用时不传参数会报错 */function foo(&#123;x, y = 5&#125;) &#123; console.log(x, y);&#125;foo(&#123;&#125;) // undefined, 5 , 因为只传了一个空对象，y有默认值 x等同于声明了未定义，即undefinedfoo() // 报错. 因为没有传参数， 那么形参的声明的默认值就不会正确执行，即报错/* 调用时不传参数不会报错 */function foo(&#123;x, y = 5&#125; = &#123;&#125;) &#123; console.log(x, y);&#125;foo() // undefined, 5 这样就不会报错了 rest 形参 rest 只能在形参中的最后一位 函数的length属性不包括 rest 函数 function mypush(array, ...items) &#123; items.forEach(item=&gt;&#123; array.push(item); &#125;);&#125;var a = [];mypush(a, 1, 2, 3); // a = [1,2,3]; 扩展运算符的应用小应用/* * 取得最大值 */Math.max(...[14, 3, 77])/* * 将一个数组添加到另一个数组的尾部 */var arr1 = [0, 1, 2], arr2 = [3, 4, 5];arr1.push(...arr2);/* * 生成指定时间 */new Date(...[2015, 1, 1]);/* * 合并数组 */[...arr1, ...arr2, ...arr3]/* * 与解构赋值结合 */const [first, ...rest] = [1, 2, 3, 4, 5];first //1rest //[2, 3, 4, 5]const [first, ...rest] = [];first //undefinedrest //[]const [first, ...rest] = ["foo"];first //"foo"rest //[]/* * 函数的返回值 * 从数据库取出一行数据，通过扩展运算符，直接将其传入构造函数Date。 */va r dateFields = readDateFields(database);var d = new Date(...dateFields);// 将字符串转为真正的数组[...'hello']// [ "h", "e", "l", "l", "o" ] 实现了 Iterator 接口的对象任何 Iterator 接口的对象，都可以用扩展运算符转为 真正的数组。 var nodeList = document.querySelectorAll('div');var array = [...nodeList];/* * 扩展运算符可以将伪数组nodeList 转换真正的数组， * 原因就在于 NodeList 对象实现了 Iterator 接口。 */let arrayLike = &#123; '0': 'a', '1': 'b', '2': 'c', length: 3&#125;;let arr = [...arrayLike];// 报错/** * arrayLike是一个类似数组的对象，但是没有部署Iterator接口，扩展运算符就会报错。 * 这时，可以改为使用Array.from方法将arrayLike转为真正的数组。 */ Map和Set结构，Generator函数因此只要 具有Iterator接口的对象，都可以使用扩展运算符 let map = new Map([ [1, 'one'], [2, 'two'], [3, 'three'],]);let arr = [...map.keys()]; // [1, 2, 3] Generator函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。 var go = function*()&#123; yield 1; yield 2; yield 3;&#125;;[...go()] // [1, 2, 3] 上面代码中，变量go是一个 Generator 函数，执行后返回的是一个遍历器对象，对这个遍历器对象执行扩展运算符，就会将内部遍历得到的值，转为一个数组。 箭头函数使用注意 箭头函数体内的 this 指向的是 父作用域 不可以当作构造函数 不可以使用 arguments 对象，可以用 rest 参数代替。 不可以使用 yield 命令 基本使用/* 一个形参 */var f = v =&gt; v;/* 多个形参 */var sum = (num1, num2) =&gt; num1 + num2;/* 由于大括号被解释为代码块，所以返回对象时要加上小括号 */var getTempItem = id =&gt; (&#123; id: id, name: "Temp" &#125;);/* 多条语句卸载大括号内 */var sum = (num1, num2) =&gt; &#123; return num1 + num2; &#125;/* 箭头函数与变量解构结合使用 */const full = (&#123; first, last &#125;) =&gt; first + ' ' + last;// 等同于function full(person) &#123; return person.first + ' ' + person.last;&#125; 绑定 this 绑定 this 是用来取代call、apply、bind调用 函数绑定运算符是并排的两个冒号（::） foo::bar; /* 等同于 */ bar.bind(foo);foo::bar(...arguments); /* 等同于 */ bar.apply(foo, arguments);/* 如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。 */var method = obj::obj.foo; /* 等同于 */ var method = ::obj.foo;var log = ::console.log; /* 等同于 */ var log = console.log.bind(console); 尾调用(Tail Call)ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。 尾调用是函数式编程 的一个重要概念，就是指 某个函数 最后一步 以 return 的方式调用另一个函数 /* 尾调用 */function f(x)&#123; return g(x);&#125;/* 函数m和n都属于尾调用，因为它们都是函数f的最后一步操作。*/function f(x) &#123; if (x &gt; 0) &#123; return m(x) &#125; return n(x);&#125; 对于尾调用优化的理解 每函数执行时在内存中形成调用帧（保存调用位置和内部变量等信息），调用帧的释放 取决于该函数是否执行了return ，系统默认会自执行 return， 但前提是需要等待程序执行完毕时，那在这个过程中累积的调用帧无疑加大了内存的开销。所以结尾处以 return 形式调用另一个函数 可以使 调用帧及时释放以减少无用的内存浪费 对象的扩展属性的简洁表示法/* 对象内可以使用变量名 */var foo = 'bar';var baz = &#123;foo&#125;;baz // &#123;foo: "bar"&#125;function f(x, y) &#123;/*内部默认执行了 x = 1,y = 2 ，所以形参也是变量*/ return &#123;x, y&#125;;&#125;f(1, 2) // Object &#123;x: 1, y: 2&#125;/* 对象内方法的简写 */var o = &#123; method() &#123; return "Hello!"; &#125;&#125;; 应用场景场景一 ：对象中直接放一个变量 var birth = '2000/01/01';var Person = &#123; name: '张三', birth, hello() &#123; console.log('我的名字是', this.name); &#125;&#125;;Person.birth // '2000/01/01' 场景二 ：这种写法用于函数的返回值，将会非常方便。 function getPoint() &#123; var x = 1; var y = 10; return &#123;x, y&#125;;&#125;getPoint()// &#123;x:1, y:10&#125; 场景三 ：CommonJS 模块输出变量 ，就非常合适使用简洁写法。 var ms = &#123;&#125;;function getItem (key) &#123; return key in ms ? ms[key] : null;&#125;function setItem (key, value) &#123; ms[key] = value;&#125;function clear () &#123; ms = &#123;&#125;;&#125;module.exports = &#123; getItem, setItem, clear &#125;;// 等同于module.exports = &#123; getItem: getItem, setItem: setItem, clear: clear&#125;; 属性名表达式/* 例子一 */let propKey = 'foo';let obj = &#123; [propKey]: true, ['a' + 'bc']: 123&#125;;obj.foo // trueobj.abc // 123/* 例子二 */var lastWord = 'last word';var a = &#123; 'first word': 'hello', [lastWord]: 'world'&#125;;a['first word'] // "hello"a[lastWord] // "world"a['last word'] // "world" 属性表达式定义方法名let obj = &#123; ['h' + 'ello']() &#123; return 'hi'; &#125;&#125;;obj.hello() // hi/* 属性名表达式与简洁表示法，不能同时使用 */// 报错var foo = 'aaa';var aaa = 'abc';var baz = &#123; [foo] &#125;;// 正确var foo = 'aaa';var baz = &#123; [foo]: 'abc'&#125;;baz.aaa // abc Object.is()比较俩个值是否相等,和 === 类似 . Object.js(1,2) 等同于 1 === 2 Object.assign()Object.assign方法用于合并对象，第一个参数是目标对象 ，后面的参数都是源对象。 var target = &#123; a: 1 &#125;;var source1 = &#123; b: 2 &#125;;var source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target // &#123;a:1, b:2, c:3&#125; 应用场景 为对象添加属性 class Point &#123; constructor(x, y) &#123; Object.assign(this, &#123;x, y&#125;); &#125;&#125;/* 通过Object.assign方法，将x、y属性添加到 Point 类的对象实例中 */ 为对象添加方法 /* *通过 Object.assgin 函数将 aaa、bbb函数 添加到 SomeClass.prototype 原型中。 */Object.assign(SomeClass.prototype, &#123; aaa(arg1, arg2) &#123; ··· &#125;, bbb() &#123; ··· &#125;&#125;);// 等同于下面的写法SomeClass.prototype.aaa = function (arg1, arg2) &#123; ···&#125;;SomeClass.prototype.bbb = function () &#123; ···&#125;; 合并多个对象 const merge = (...sources) =&gt; Object.assign(&#123;&#125;, ...sources); 为属性指定默认值 const DEFAULTS = &#123; logLevel: 0, outputFormat: 'html'&#125;;/* DEFAULTS对象是默认值，options对象是用户提供的参数。 */function processContent(options) &#123; options = Object.assign(&#123;&#125;, DEFAULTS, options); console.log(options); // &#123;logLevel: 0, outputFormat: "html"&#125;&#125; 属性的遍历 方法 作用 for…in 遍历自身的和继承的可枚举属性（不含 Symbol 属性）。 Object.keys(obj) 返回数组，（不含继承的）所有可枚举属性（不含 Symbol 属性）。 Object.getOwnPropertyNames(obj) 返回自身对象的一个数组，不含 Symbol 属性，但是包括不可枚举属性）。 Object.getOwnPropertySymbols(obj) 返回自身对象的一个数组，含所有 Symbol 属性。 Reflect.ownKeys(obj) 返回自身对象的一个数组，不管属性名是 Symbol 或字符串，也不管是否可枚举。 以上的5种方法遍历对象的属性，都遵守同样的属性遍历的次序规则。 首先遍历 为数值的属性，按照 数字排序 。 其次遍历 字符串的属性，按照生成时间排序。 最后遍历 Symbol 值的属性，按照生成时间排序。 Reflect.ownKeys(&#123; [Symbol()]:0, b:0, 10:0, 2:0, a:0 &#125;)// ['2', '10', 'b', 'a', Symbol()] proto 属性 Object.getprototypeOf() == 读取一个对象的原型对象 Object.setprototypeOf() == 设置一个对象的原型对象 Object.keys()/values()/entries()可将对象中所有的 键或值 单独分离进行独立出来 var obj = &#123; foo: 'bar', baz: 42 &#125;;Object.keys(obj) // ["foo", "baz"]Object.values(obj) // ["bar", 42]Object.entries(obj) // [ ["foo", "bar"], ["baz", 42] ] 对象的扩展运算符let &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;;x // 1y // 2z // &#123; a: 3, b: 4 &#125;/*******************************/let obj = &#123; a: &#123; b: 1 &#125; &#125;;let &#123; ...x &#125; = obj;obj.a.b = 2;x.a.b // 2/*******************************/let z = &#123; a: 3, b: 4 &#125;;let n = &#123; ...z &#125;;n // &#123; a: 3, b: 4 &#125;/** * 扩展运算符可以用于合并两个对象。 */let ab = &#123; ...a, ...b &#125;;// 等同于let ab = Object.assign(&#123;&#125;, a, b); 扩展运算符花样操作 let aWithOverrides = &#123; ...a, x: 1, y: 2 &#125;;// 等同于let aWithOverrides = &#123; ...a, ...&#123; x: 1, y: 2 &#125; &#125;;// 等同于let x = 1, y = 2, aWithOverrides = &#123; ...a, x, y &#125;;// 等同于let aWithOverrides = Object.assign(&#123;&#125;, a, &#123; x: 1, y: 2 &#125;); Symbol 为了从根本上解决命名冲突 ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值 目前总共7种分别是: undefined、null、Nubmber、String、Boolean、Object、 Symbol Set 和 Map 数据结构Set基本用法 类似于数组 ，但成员的值 没有重复 的 可接受 任何数组 作为参数进行初始化 Set 本身是一个构造函数，用来生成 Set 数据结构。 const set = new Set([1,1,2,3,4,4]);[...set]// [1, 2, 3, 4] Set 属性 属性 作用 构造函数 Set.prototype.constructor 成员总数 Set.prototype.size Set 方法 操作方法 作用 add(value)： 添加某个值，返回Set结构本身。 delete(value)： 删除某个值，返回一个布尔值，表示删除是否成功。 has(value)： 返回一个布尔值，表示该值是否为Set的成员。 clear()： 清除所有成员，没有返回值。 遍历方法 作用 keys() / values()： 返回键名的遍历器 entries()： 返回键和值，但键和值都一样 forEach()： 使用回调函数遍历每个成员 let set = new Set(['red', 'green', 'blue']);/* set 的默认方法就是 set.values */for (let item of set) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.entries()) &#123; console.log(item);&#125;// ["red", "red"]// ["green", "green"]// ["blue", "blue"]/* forEach对每个成员执行某种操作，没有返回值。 */let set = new Set([1, 2, 3]);set.forEach((value, key) =&gt; console.log(value * 2) )// 2// 4// 6 应用数组去重//方法一let arr = [3, 5, 2, 2, 5, 5];let unique = [...new Set(arr)];// [3, 5, 2]//方法二let arr = Array.from(new Set([1,2,2,3,4]))// [1, 2, 3, 4] 数组的 map 和 filter 方法结合Set轻松实现并、交、差集let a = new Set([1, 2, 3]);let b = new Set([4, 3, 2]);// 并集let union = new Set([...a, ...b]);// Set &#123;1, 2, 3, 4&#125;// 交集let intersect = new Set([...a].filter(x =&gt; b.has(x)));// set &#123;2, 3&#125;// 差集let difference = new Set([...a].filter(x =&gt; !b.has(x)));// Set &#123;1&#125; Map解决对象的键只能是字符串的痛点（null、undefined都可以），Map 结构提供了“值和值”的对应 基本用法/* 注意是 二维数组的方式 [ [],[],[] ]*/const map = new Map([ ['name', '张三'], ['title', 'Author']]);map.set(o, 'content')map.has('name') // truemap.get('name') // "张三"map.size // 3 注意 :Map 结构只会对 有对象引用的 , 才将其视为一个键。 const map = new Map();map.set(['a'], 555);map.get(['a'])// undefined 的原因是 set 时候的 ['a'] 和 get 时候的 ['a'] 在内存地址中不是同一个位置。/*****************************************************/const map = new Map();const k1 = ['a'];const k2 = ['a'];/* 链式写法 */map.set(k1, 111).set(k2, 222);map.get(k1) // 111map.get(k2) // 222/* 因为k1 的值是对象 ，而对象是引用类型储存在堆中， set 和 get 用的 都是一个引用地址，所以就能取到对应的值, k1 和 k2 的值虽然一样但是 存储的引用地址不一样，so 不会冲突 */ 属性和方法属性：size ，返回 Map结构成员总数。 方法： 操作的 作用 set(key,value)： 设置 key 对应的键值,可采用链式写法 get(key)： 读取 key 对应的键值，找不到返回 undefined has(value)： 返回一个布尔值，表示该值是否为 Map 的成员。 delete(value)： 删除某个值，返回一个布尔值，表示删除是否成功。 clear()： 清除所有成员，没有返回值。 遍历的 作用 keys() 返回键名的遍历器 values() 返回键值的遍历器 entries()： （默认）返回键和值的遍历器 forEach()： 遍历map的所有成员 forEach方法还可以接受第二个参数，用来绑定 this。 const reporter = &#123; report: function(key, value) &#123; console.log("Key: %s, Value: %s", key, value); &#125;&#125;;map.forEach(function(value, key, map) &#123; this.report(key, value);&#125;, reporter); 与其他数据结构的互相转换Map 转为数组 直接用扩展运算符就可以很方便的进行转化 const myMap = new Map() .set(true, 7) .set(&#123;foo: 3&#125;, ['abc']);[...myMap]// [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ 'abc' ] ] ] 数组转为 Map 直接将数组传入 Map 构造函数，就可以转化为 Map 。 new Map([ [true, 7], [&#123;foo: 3&#125;, ['abc']]])// Map &#123;// true =&gt; 7,// Object &#123;foo: 3&#125; =&gt; ['abc']// &#125; Map 转为对象 如果所有 Map 的键都是字符串，它可以转为对象。 function strMapToObj(strMap) &#123; let obj = Object.create(null); for (let [k,v] of strMap) &#123; obj[k] = v; &#125; return obj;&#125;const myMap = new Map() .set('yes', true) .set('no', false);strMapToObj(myMap)// &#123; yes: true, no: false &#125; 对象转为 Mapfunction objToStrMap(obj) &#123; let strMap = new Map(); for (let k of Object.keys(obj)) &#123; strMap.set(k, obj[k]); &#125; return strMap;&#125;objToStrMap(&#123;yes: true, no: false&#125;)// Map &#123;"yes" =&gt; true, "no" =&gt; false&#125; Map 转为 JSON Map 转为 JSON 要区分两种情况。一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。 function strMapToJson(strMap) &#123; return JSON.stringify(strMapToObj(strMap));&#125;let myMap = new Map().set('yes', true).set('no', false);strMapToJson(myMap)// '&#123;"yes":true,"no":false&#125;'/************************************************************//* 另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。 */function mapToArrayJson(map) &#123; return JSON.stringify([...map]);&#125;let myMap = new Map().set(true, 7).set(&#123;foo: 3&#125;, ['abc']);mapToArrayJson(myMap)// '[[true,7],[&#123;"foo":3&#125;,["abc"]]]' JSON 转 Map JSON 转为 Map，正常情况下，所有键名都是字符串。 function jsonToStrMap(jsonStr) &#123; return objToStrMap(JSON.parse(jsonStr));&#125;jsonToStrMap('&#123;"yes": true, "no": false&#125;')// Map &#123;'yes' =&gt; true, 'no' =&gt; false&#125; Proxy （代理）详细介绍 在目标对象之前设置了一个中间人，外界访问该对象时都必须先通过这个中间人，这种机制就可以对外界的访问进行过滤和改写 ES6 原声提供 Proxy 构造函数，用来生成 proxy 实例。 var proxy = new Proxy(target, handler); new Proxy(): 表示生成一个 Proxy实例 target : 参数表示所要 拦截的目标对象 handler: 参数也是一个对象，用来 定制拦截行为。 应用场景Proxy 对象可以拦截目标对象的任意属性，这使得它很合适用来写 Web 服务的客户端。 /* 新建了一个 Web 服务的接口，这个接口返回各种数据。*/const service = createWebService('http://example.com/data');service.employees().then(json =&gt; &#123; const employees = JSON.parse(json); // ···&#125;);/***********************************************//*Proxy 可以拦截这个对象的任意属性，所以不用为每一种数据写一个适配方法，只要写一个 Proxy 拦截就可以了。*/function createWebService(baseUrl) &#123; return new Proxy(&#123;&#125;, &#123; get(target, propKey, receiver) &#123; return () =&gt; httpGet(baseUrl+'/' + propKey); &#125; &#125;);&#125; Promise（承诺） 对象了解 Promise Promise 是异步编程的一种解决方案 Promise 是一个保存着一个未来才会结束的事件 Promise 的俩个特点 只有异步操作的 结果，才能决定当前是哪一种 状态 Pending（进行中） Resolved（已完成，又称 Fulfilled） Rejected（已失败） 一旦状态改变，就不会再变，任何时候都可以得到这个结果。 状态的改变只有两种可能：从 Pending 变为 Resolved 和 从 Pending 变为 Rejected。 如果某些事件不断地反复发生，一般来说，使用 Stream 模式是比部署Promise更好的选择。 基本操作ES6 规定，Promise对象是一个 构造函数 ，用来生成Promise实例。 Promise构造函数 接受一个函数作为参数，该函数的两个参数也是函数分别是resolve和reject。 resolve 函数： 在异步操作成功时调用，并将异步操作的结果，作为参数传递出去； reject 函数：在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 /* 生成 promise 实例 */var promise = new Promise(function(resolve, reject) &#123; // ... some code if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;);/** * Promise实例生成以后，可以用then方法 分别指定Resolved状态 和 Reject状态的回调函数。 */promise.then(function(value) &#123; // 成功时&#125;, function(error) &#123; // 失败时 （该函数可选）&#125;); 一个 Promise 对象的简单例子 一个用Promise对象实现的 Ajax 操作的例子 Promise.prototype.then() then方法是定义在原型对象Promise.prototype上的 then(Resolved状态回调函数,Rejected 状态的回调函数) then方法返回的是一个 新的 Promise实例,因此可以采用链式写法，即then方法后面再调用另一个then方法。 Promise.prototype.catch()Promise.prototype.catch 方法是 .then(null, rejection)的别名，用于 指定发生错误时的回调函数。 p.then((val) =&gt; console.log('fulfilled:', val)) .catch((err) =&gt; console.log('rejected', err));// 等同于p.then((val) =&gt; console.log('fulfilled:', val)) .then(null, (err) =&gt; console.log("rejected:", err)); 例子 var promise = new Promise(function(resolve, reject) &#123; throw new Error('test');&#125;);promise.catch(function(error) &#123; console.log(error);&#125;);/* promise抛出一个错误，就被catch方法指定的回调函数捕获。 */// Error: test 俩种捕捉错误的方法 // badpromise .then(function(data) &#123; // success &#125;, function(err) &#123; // error &#125;);// goodpromise .then(function(data) &#123; //cb // success &#125;) .catch(function(err) &#123; // error &#125;); 其他深度阅读 Promise.all()Promise.all用于将多个 Promise 实例，包装成一个新的 Promise 实例。 Promise.resolve()有时需要将现有对象转为Promise对象，Promise.resolve 方法就起到这个作用。 Promise.reject()也会返回一个新的 Promise 实例，该实例的状态为 rejected。 Iterator 和 for…of循环Iterator 概念 ES6中有四种数据集合分别是：数组、对象(没有Iterator接口)、Map、Set 用户如果想组合使用这些数据，就需要一种统一的接口机制，来处理所有不同的数据结构。 遍历器（Iterator）就是为各种不同的数据结构 提供统一的访问机制的接口 。 任何数据结构只要部署Iterator接口 ，就可以完成遍历操作。 Iterator的三个作用 为各种数据结构，提供一个统一访问接口 ； 使得数据结构的成员能够按 某种次序排列 ； Iterator接口主要 配合for...of 。 默认的 Iterator 接口 默认的Iterator接口 部署在数据结构的 Symbol.iterator属性 也就是，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”。 Symbol.iterator就是 默认生成遍历器的函数,执行它就会返回一个遍历器。 原生具备 Iterator 接口的数据结构：Array、Map、Set、String、TypedArray、函数的 arguments 对象 /* 具备原生 Iterator ：Array */let arr = ['a', 'b', 'c'];/*执行它就会返回一个遍历器,根本特征就是具有 next 方法 */let iter = arr[Symbol.iterator]();iter.next() // &#123; value: 'a', done: false &#125;iter.next() // &#123; value: 'b', done: false &#125;iter.next() // &#123; value: 'c', done: false &#125;iter.next() // &#123; value: undefined, done: true &#125; 调用 Iterator 接口的场合/** * 1.解析赋值 */let [first, ...rest] = ['a','b','c'];// first='a'; rest=['b','c'];/** * 2.扩展运算符 */let arr = ['b', 'c'];['a', ...arr, 'd']// ['a', 'b', 'c', 'd']/** * 3. yield* * yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。 */let generator = function* () &#123; yield 1; yield* [2,3,4]; yield 5;&#125;;var iterator = generator();iterator.next() // &#123; value: 1, done: false &#125;iterator.next() // &#123; value: 2, done: false &#125;iterator.next() // &#123; value: 3, done: false &#125;iterator.next() // &#123; value: 4, done: false &#125;iterator.next() // &#123; value: 5, done: false &#125;iterator.next() // &#123; value: undefined, done: true &#125; 遍历器对象的 return(),throw()遍历器对象具有next、_return、_throw方法。 return方法的使用场合是，如果for...of循环提前退出（通常是因为出错，或者有break语句或continue语句），就会调用return方法。 for…of 循环for…of循环 内部调用 的是数据结构的Symbol.iterator方法，所以只要数据结构只要部署了Symbol.iterator属性，就可以用for…of循环遍历它的成员 与其他遍历语法比较 for循环 没有 fo…of 简洁 forEach 无法中途跳出forEach循环，break命令或return命令都不能奏效 for…in 主要是为遍历对象而设计的，不适用于遍历数组 Generator 函数的语法基本概念Generator 函数是 ES6 提供的一种 异步编程解决方案 ，语法行为与传统函数 完全不同 。 Generator 函数有多种理解角度。 从语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。 同时执行 Generator 函数会 返回一个遍历器对象 返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。 Generator 函数形式上的两个特征。 function 与函数名的中间有一个星号； 函数体内部使用yield表达式，定义不同的内部状态（ yield 在英语里的意思就是“产出”）。 yield 表达式由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以 暂停执行的函数,yield表达式就是暂停标志。 遍历器对象的next方法的运行逻辑如下。 遇到yield表达式，暂停并将 紧跟在yield后面的那个 表达式的值 ，作为返回的对象的value属性值。 下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。 如果没有再遇到新的yield表达式，就一直运行到return语句为止，并以对象行使返回return语句后面的表达式的值 如果该函数没有return语句，则返回的对象的value属性值为undefined。 yield 于 return 的区别 yield 函数暂停执行，下一次再从该位置继续向后执行，具备记忆 一个函数里面，只能执行一次return语句，但是可以执行多个yield表达式。 正常函数只能返回一个值，因为只能执行一次return； 函数可以返回一系列的值，因为可以有任意多个yield。 yield表达式如果用在另一个表达式之中，必须放在圆括号里面。 function* demo() &#123; console.log('Hello' + yield); // SyntaxError console.log('Hello' + yield 123); // SyntaxError console.log('Hello' + (yield)); // OK console.log('Hello' + (yield 123)); // OK&#125; next 方法的参数next方法的参数 表示 上一个yield表达式的返回值 /* 简单例子 */ function* f() &#123; for(var i = 0; true; i++) &#123; var reset = yield i; if(reset) &#123; i = -1; &#125; &#125; &#125; var g = f(); g.next() // &#123; value: 0, done: false &#125; g.next() // &#123; value: 1, done: false &#125; /* 当next方法带一个参数true时， 变量reset就被重置为这个参数（即true）， 因此i会等于-1，下一轮循环就会从-1开始递增。 */ g.next(true) // &#123; value: 0, done: false &#125;/* 再看一个通过next方法的参数，向 Generator 函数内部输入值的例子 */ function* dataConsumer() &#123; console.log('Started'); console.log(`1. $&#123;yield&#125;`); console.log(`2. $&#123;yield&#125;`); return 'result'; &#125; let genObj = dataConsumer(); genObj.next(); // Started genObj.next('a') // 1. a genObj.next('b') // 2. b Generator.prototype.throw()Generator 函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。 Generator.prototype.return()Generator函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历Generator函数。 yield* 表达式如果在 Generator 函数内部，调用另一个 Generator 函数，默认情况下是没有效果的。 function* inner() &#123; yield 'hello!';&#125;function* outer2() &#123; yield 'open' yield* inner() yield 'close'&#125;var gen = outer2()gen.next().value // "open"gen.next().value // "hello!"gen.next().value // "close" 作为对象属性的 Generator 函数/* myGeneratorMethod属性前面有一个星号，表示这个属性是一个 Generator 函数。 */ let obj = &#123; * myGeneratorMethod() &#123; // ··· &#125; &#125;;/* 与上面的写法是等价的 */ let obj = &#123; myGeneratorMethod: function* () &#123; // ··· &#125; &#125;; 应用场景 异步操作的同步化表达 控制流管理 部署 Iterator 接口 作为数据结构 Generator 函数的异步应用异步编程对 JavaScript 语言太重要,因为 Javascript 语言的执行环境是 “单线程”的. 详细阅读 async 函数 一句话，它就是 Generator 函数的语法糖 详细阅读 Class 的基本语法ES6 的class写法只是让对象原型的 写法更加清晰 、更接近主流面向对象编程 的语法而已。 深度阅读 Class的继承 Module 的语法概述 历史上，JavaScript 一直没有模块体系，直接导致了对开发大型的、复杂的项目造成了巨大障碍。 ES6 实现了 模块功能 ，而且实现得 相当简单 ，完全可以取代其他规范。 ES6 模块的设计思想是尽量的静态化，使得 编译时 就能 确定 模块的 依赖关系 ，以及输入和输出的变量。 CommonJS 与 ES6 模块的区别 严格模式ES6 的模块自动采用严格模式，不管你有没有在模块头部加上 &quot;use strict&quot; 严格模式主要有以下限制 变量必须声明后再使用 函数的参数不能有同名属性，否则报错 不能使用 with 语句 不能对只读属性赋值，否则报错 不能使用前缀0表示八进制数，否则报错 不能删除不可删除的属性，否则报错 不能删除变量 delete prop，会报错，只能删除属性 delete global[prop] eval 不会在它的外层作用域引入变量 eval 和 arguments 不能被重新赋值 arguments不会自动反映函数参数的变化 不能使用 arguments.callee 不能使用 arguments.caller 禁止 this 指向全局对象 不能使用 fn.caller 和 fn.arguments 获取函数调用的堆栈 增加了保留字（比如 protected 、static 和 interface ） export 命令模块功能主要由两个命令构成：export 命令用于 规定 模块的 对外接口 ，import 命令用于 输入其他模块提供的功能。 输出变量 一个模块就是一个独立的文件，其内部所有变量 外部无法获取。 如果希望外部能够读取模块内部的某个变量，就必须使用 export输出该变量。 // profile.jsexport var firstName = 'Michael';export var lastName = 'Jackson';export var year = 1958;/* 上下写法等同 */// profile.jsvar firstName = 'Michael';var lastName = 'Jackson';var year = 1958;export &#123;firstName, lastName, year&#125;; 输出函数或类 export function multiply(x, y) &#123; return x * y;&#125;;// 输出 multiply 函数 使用as关键字重命名function v1() &#123; ... &#125;function v2() &#123; ... &#125;export &#123; v1 as streamV1, v2 as streamV2, v2 as streamLatestVersion&#125;;/* 使用as关键字，重命名了函数v1和v2的对外接口。重命名后，v2可以用不同的名字输出两次。*/ 特别注意export 规定是: 对外的接口 与 模块内部的变量 建立一一 对应关系 。 import 命令使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。 /** * 1.import命令，用于加载profile.js文件，并从中输入变量。 * 2.import命令接受一对大括号，里面指定要从其他模块导入的变量名。 * 3.大括号里面的变量名，必须与被导入模块（profile.js）对外接口的名称相同。 */// main.jsimport &#123;firstName, lastName, year&#125; from './profile';/* import命令要使用 as 关键字，将输入的变量重命名。*/// import &#123; lastName as surname &#125; from './profile';function setName(element) &#123; element.textContent = firstName + ' ' + lastName;&#125; 知识点 from指定模块文件的位置时可以是相对或绝对路径，.js可以省略 如果只是模块名，不带有路径，那么必须有配置文件，告诉 JS 引擎该模块的位置。 import命令具有提升效果，会提升到整个模块的头部，首先执行。 模块的整体加载整体加载：即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。 /* 模块的整体加载 */import * as circle from './circle';console.log('圆面积：' + circle.area(4));console.log('圆周长：' + circle.circumference(14));/* 上下同等 */import &#123; area, circumference &#125; from './circle';console.log('圆面积：' + area(4));console.log('圆周长：' + circumference(14)); export default 命令为模块指定默认输出// export-default.jsexport default function () &#123; console.log('foo');&#125;/** * 模块文件export-default.js，它的默认输出是一个函数, * 其他模块加载该模块时，import命令可以为该匿名函数指定任意名字，不需要大括号包裹 */// import-default.jsimport customName from './export-default';customName(); // 'foo' 比较默认输出和正常输出// 第一组export default function crc32() &#123; // 输出 // ...&#125;import crc32 from 'crc32'; // 输入/********************************************/// 第二组export function crc32() &#123; // 输出 // ...&#125;;import &#123;crc32&#125; from 'crc32'; // 输入 本质上，export default就是输出一个叫做default的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。 // modules.jsfunction add(x, y) &#123; return x * y;&#125;export &#123;add as default&#125;;// 等同于// export default add;// app.jsimport &#123; default as xxx &#125; from 'modules';// 等同于// import xxx from 'modules'; 有了export default命令，输入模块时就非常直观了，以输入 lodash 模块为例。 /* 将默认方法 赋值到 _*/import _ from 'lodash';/* 同时输入默认方法和其他接口 */import _, &#123; each, each as forEach &#125; from 'lodash';// 对应上面代码的export语句如下。export default function (obj) &#123; // ···&#125;export function each(obj, iterator, context) &#123; // ···&#125;export &#123; each as forEach &#125;; // 暴露出forEach接口，默认指向each接口，即forEach和each指向同一个方法。 export 与 import 的复合写法如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。 /****************************************/// export和import语句可以结合在一起export &#123; foo, bar &#125; from 'my_module';// 等同于import &#123; foo, bar &#125; from 'my_module';export &#123; foo, bar &#125;;/****************************************/// 接口改名export &#123; foo as myFoo &#125; from 'my_module';// 整体输出export * from 'my_module';// 默认接口的写法export &#123; default &#125; from 'foo';/****************************************/// 具名接口改为默认接口的写法export &#123; es6 as default &#125; from './someModule';// 等同于import &#123; es6 &#125; from './someModule';export default es6;/****************************************/// 默认接口也可以改名为具名接口export &#123; default as es6 &#125; from './someModule'; 模块的继承假设有一个circleplus模块，继承了circle模块。 // circleplus.js 输出文件export * from 'circle'; // 表示再输出circle模块的所有属性和方法export var e = 2.71828182846; // 又输出了自定义的e变量和默认方法。export default function(x) &#123; // 输出默认方法 return 'test';&#125;export &#123; area as circleArea &#125; from 'circle'; // 只输出circle模块的area方法，且将其改名为circleArea。//main.js 输入文件import * as math from 'circleplus'; // 加载 circleplus 上所有方法import aaa from 'circleplus'; // 将circleplus的默认方法命名为 aaaconsole.log(aaa()); // test 跨模块常量设置跨模块的常量，或者说一个值要被多个模块共享，可以采用下面的写法。 // constants.js 模块export const A = 1;export const B = 3;export const C = 4;// test1.js 模块import * as constants from './constants';console.log(constants.A); // 1console.log(constants.B); // 3// test2.js 模块import &#123;A, B&#125; from './constants';console.log(A); // 1console.log(B); // 3 如果要使用的常量非常多，可以建一个专门的constants目录，将各种常量写在不同的文件里面，保存在该目录下。 // constants/db.jsexport const db = &#123; url: 'http://my.couchdbserver.local:5984', admin_username: 'admin', admin_password: 'admin password'&#125;;// constants/user.jsexport const users = ['root', 'admin', 'staff', 'ceo'];/******************************************************/// constants/index.jsexport &#123;db&#125; from './db';export &#123;users&#125; from './users';/******************************************************/// 使用的时候，直接加载 出入该模块，会自动加载其中的 index.js 文件// script.jsimport &#123;db, users&#125; from './constants'; import() 只是有一个 提案，建议引入import()函数，完成动态加载。 import()类似于 Node 的require方法，区别主要是前者是异步加载，后者是同步加载。 适用场合 按需加载 条件加载 动态的模块路径 Module 的加载实现浏览器加载传统方法 &lt;!-- 页面内嵌的脚本 --&gt;&lt;script type=&quot;application/javascript&quot;&gt; // module code&lt;/script&gt;&lt;!-- 外部脚本 --&gt;&lt;script type=&quot;application/javascript&quot; src=&quot;path/to/myModule.js&quot;&gt;&lt;/script&gt;&lt;!-- 异步加载的俩种方式 --&gt;&lt;script src=&quot;path/to/myModule.js&quot; defer&gt;&lt;/script&gt; // 等到整个页面正常渲染结束，才会执行&lt;script src=&quot;path/to/myModule.js&quot; async&gt;&lt;/script&gt; // 一旦下载完成，立马执行 加载规则 浏览器加载 ES6 模块，也使用 &lt;script&gt; 标签，但是要加入 type=&quot;module&quot; 属性。 &lt;script type=&quot;module&quot; src=&quot;foo.js&quot;&gt;&lt;/script&gt;浏览器对于带有type=&quot;module&quot; 都是执行 defer属性的异步加载 与Node相关的ES6 编程风格块级作用域 let 完全取代var let 和 const 之间，优先使用 const 字符串静态字符串一律使用 单引号或反引号，不使用双引号 // badconst a = "foobar";const b = 'foo' + a + 'bar';// goodconst a = 'foobar';const b = `foo$&#123;a&#125;bar`;const c = 'foobar'; 解构赋值const arr = [1, 2, 3, 4];// badconst first = arr[0];const second = arr[1];// goodconst [first, second] = arr; 对象 单行定义的对象，最后一个成员 不以逗号结尾。 多行定义的对象，最后一个成员 以逗号结尾。 // badconst a = &#123; k1: v1, k2: v2, &#125;;const b = &#123; k1: v1, k2: v2&#125;;// goodconst a = &#123; k1: v1, k2: v2 &#125;;const b = &#123; k1: v1, k2: v2,&#125;; 数组使用扩展运算符 (…) 拷贝数组 // badconst len = items.length;const itemsCopy = [];let i;for (i = 0; i &lt; len; i++) &#123; itemsCopy[i] = items[i];&#125;// goodconst itemsCopy = [...items]; 使用Array.from方法，将伪数组转为真数组。 const foo = document.querySelectorAll('.foo');const nodes = Array.from(foo); 函数/** * 立即执行函数可以写成箭头函数的形式。 */(() =&gt; &#123; console.log('Welcome to the Internet.');&#125;)();/** * 需要使用函数表达式的场合，尽量用箭头函数代替 */[1, 2, 3].map((x) =&gt; &#123; return x * x;&#125;);// 或者[1, 2, 3].map(x =&gt; x * x);/** * 所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数 */function divide(a, b, &#123; option = false &#125; = &#123;&#125;) &#123;&#125;/** * 使用rest运算符（...）代替 arguments */function concatenateAll(...args) &#123; return args.join('');&#125;/** * 设置形参默认值。 */function handleThings(opts = &#123;&#125;) &#123; // ...&#125; Map 结构 注意区分 Object 和 Map。 如果只是需要key: value的数据结构，使用Map结构。 Class用Class 取代需要 prototype 的操作，因为Class的写法更简洁，更易于理解。 模块 Module 语法是 JS 模块的 标准写法 ，坚持使用这种写法。 使用 import 取代 require。 使用 export 取代 module.exports。 注意事项 如果模块只有一个输出值，才使用export default。 在模块输入中使用通配符，就无法确保有一个默认输出值 模块默认输出一个函数，函数名首字母小写。 模块默认输出一个对象，对象名首字母大写。]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flex]]></title>
    <url>%2Fflex%2F</url>
    <content type="text"><![CDATA[Flex 布局是什么 Flex 是 Flexble Box 的缩写，意为 “弹性布局”，用来为盒状提供最大的灵活性。 任何一个容器都可以指定为 Flex 布局 注意，设为 Flex 布局以后，子元素 的 loadt、cleat 和 vertical-align 将失去作用 &lt;style type="text/css"&gt; .box&#123; display: flex; &#125; .box&#123; /* 行内元素也可以使用 Flex 布局。 */ display: inline-flex; &#125;&lt;/style&gt; # flex-flow简写：这是 flex-direction 和 flex-wrap 两个属性的缩写,默认值是 row nowrap。 容器的属性主轴方向：flex-direction: 属性值 属性作用 row（默认）； 从左到右 row-reverse； 从右到左 column； 从上到下 column-reverse； 从下到上 flex-wrap：是否换行 属性值 属性作用 nowrap（默认）； 不换行 wrap； 正常换行 wrap-reverse； 返向换行 justify-content：设伸缩项目在相对 主轴 水平上的对齐方式 属性值 属性作用 flex-start（默认）： 左对齐 flex-end： 右对齐 center： 居中 space-between： 首尾对齐，项目之间的间隔相等。 space-around： 每个项目两侧的间隔相等。 align-content:设伸缩项目在相对 主轴 水垂直的对齐方式 属性值 属性作用 flex-start： 上对齐 flex-end： 下对齐 center： 居中 space-between： 首尾对齐，项目之间的间隔相等。 space-around： 每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认）： 每个项目两侧的间隔相等。 align-items：管理伸缩容器侧轴方向的额外空间 属性值 属性作用 flex-start（默认）： 左对齐 flex-end： 右对齐 center： 居中 baseline: 项目的第一行文字的基线对齐。 stretch（默认）： 如果项目未设置高度或设为 auto，将占满整个容器的高度。 # 项目的属性 属性作用 属性值说明 order 数值越小，排列越靠前，默认为 0。 flex-grow 定义一个 Flex 项目的扩大比例，默认为 0 flex-shrink 定义一个 Flex 项目的缩小比例，默认为 0 flex-basis 定义了 Flex 项目在分配 Flex 容器剩余空间之前的一个默认尺寸，类似 width align-self：管理伸缩容器侧轴方向的额外空间 属性值 属性作用 auto 自动 flex-start（默认）： 左对齐 flex-end： 右对齐 center： 居中 baseline: 项目的第一行文字的基线对齐。 stretch（默认）： 如果项目未设置高度或设为 auto，将占满整个容器的高度。 简写：flex flex 是 flex-grow，flex-shrink，flex-basis 三个属性的缩写。第二个和第三个参数是可选值。默认值是 0 1 auto。 建议使用缩写属性。如果flex取值为none，等于0 0 auto。 参考一参考二]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>flex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何才能成为很厉害的人]]></title>
    <url>%2Frexue%2F</url>
    <content type="text"><![CDATA[首先，少年，答应别人的承诺，就一定要兑现。 我以前啊，和你一样，很想成为一个很厉害很厉害很厉害的人。 喜欢看热血的东西，幻想自己是屠龙的勇士，登塔的先锋，我左手有剑，右手有光，没头没脑的燃烧自己，敌人的骑军来了，我说你们何人堪与之战，我的女人在等我。 后来我现实了一点，我觉得我要成为那种说走就走，说日就日的男人，我梳大背头，流浪在欧洲或者新几内亚的，我拍孩子，拍野兽，拍流浪的雏妓，与罗伯特德尼罗握手，说嘿，我给你写了愤怒的公牛2。 再后来，我觉得我人生的梦想，是在城市中心买上一间顶层公寓，把一整面墙都改造成钢化玻璃，在灯火通明的夜晚，我就要端着酒站在巨大的窗前，看整个城市在呼吸，然后我的朋友叩门，他带来了一打嫩模，我们就玩一些成年人的游戏现在，我发现龙并不存在，我不会骑马，不会用单反，家住2楼，我能做的，就是把眼前的事儿做好，赚到足够的钱，这样我可以给我的姑娘一个地球仪，然后用飞镖扎它，扎到哪儿，就去哪儿玩。 这样看来，虽然我的想法随着生殖器的发育，始终在变，但那个很厉害很厉害的人，一直离我很远，甚至越来越远。 我心中曾经执剑的少年，此刻也混迹在市井之间。 血似乎都凉了。 我也不是没有惶恐过，是不是我这一生，都不能左手持剑，右手握着罗伯特德尼罗，说这里的嫩模随便你玩但是你他妈别从窗户上掉下去。 这样一看，我逊得不行，我的朋友都是一些凡人，比我还逊，业余生活就是推塔、中单、跪。 我心想，我是不是这辈子都要做一个逊逼，直到我的坟墓上写好墓志铭，我甚至都想好了：我来，我见，我挂了。 最后我给了自己一个否定的答复，我不要。 我喜欢我的朋友们，喜欢我现在的生活，首先我希望你明白，没有厉害与逊逼得区分，只有血的凉与热，有的人觉得生活就这样吧，我算了，现在没什么不好。 有的人觉得生活这样挺好，但是我还要更好。 这种只要剧情稍微热血一点就会热泪盈眶的傻逼，已经不多了，一刻也不要停留。 所以现在，我和你不一样了，我仍然想成为一个很厉害很厉害很厉害的人，像我们这种剧情稍微热血一点就会热泪盈眶的傻逼，要好好珍惜自己。 很多人坐下来了，跟你说你不行，说你省点儿心吧，说你请静一静。 汹涌的人群就把你这样的少年淹没了，人群散去的时候，你也不见了，你那些承诺，谁也听不见，这个世界对于你，就再不可能有什么更有趣更漂亮的女朋友。 你就失约了，小逼崽子。 这么跟你说。 虽然随着年龄的增长，我趋于现实，不能像你那样分分钟冲动的燃烧，然而我每时每刻都有想做的事，有想达成的目标。 不排除以后的某一年，我会握着罗伯特德尼罗的手，他说这是你写得吗，愤怒的公牛2，只要他还没死。 故事里拳王拉莫塔忍着伤，他举着铁拳，挥汗如雨，要和命运斗争，他说我怎么能失约呢，我是那个要成为很厉害很厉害的拳王拉莫塔！小伙儿，成为很厉害很厉害的人，最重要的，就是要热血，永远也不要让你的血凉下去，你凉下去了，就再也不能找到一个更有趣更漂亮的女友，你就失约了，于是那天她踏梦而来，就成了一个彻头彻尾的笑话。 当有一天你成为你讨厌的那种人，浑浑噩噩，你走在街上，看见那些更有趣更漂亮的女孩，你会不会想起多年以前，你说我答应你，在一个承诺就是永远的年纪。 读书，交友，美容，都不如你这一腔狗血，滚烫，灼人，你要燃上大半辈子，才对得起你现在说的这些话。 我听闻最美的故事，是公主死去了，屠龙的少年还在燃烧。 火苗再小，你都要反复的点燃。 所谓热血的少年，青涩的爱恋，死亡与梦之约。 这么好的故事。 你可别演砸了。 最后我给你点个人建议： 1.读书，读到倦，网上有很多方法，但你从来沉不下心看。 2.学习，学到疼，网上有很多方法，但你从来沉不下心看。 3.开口说话，冷场也要说话，脸皮薄也要说话，挨打也要说话。 4.如果你现在不知道做什么，至少你还可以先从做一个牛逼的学生开始。 5.更漂亮更有趣的女孩，五年以后再找。 6.承诺是鞭子，不是兴奋剂。 7.年纪大了，也不要说什么心如死灰。 改变自己是非常，非常，非常痛苦的，我能看出来你一腔热血的优点，自然知道你孤僻懒散自以为是的缺点，方法很多，不过我不确定你吃不吃得了苦，我和你共勉吧。 在成为最厉害最厉害最厉害的道路上。 作者：朱炫链接：https://www.zhihu.com/question/22921426/answer/23330366来源：知乎]]></content>
      <categories>
        <category>热乎鸡汤</category>
      </categories>
      <tags>
        <tag>知乎</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Quotation]]></title>
    <url>%2Fquotation%2F</url>
    <content type="text"><![CDATA[苟利国家生以死,岂因祸福趋避之出自『林则徐』 只比你努力一点的人,其实已经甩你很远出自『☆』 主动往往能为你赢得更多机会出自『☆』 世界的模样在于你看它的角度出自『☆』 真正成熟的人,脾气永远不会大于他的能力出自『☆』 不要用 “作” 来找存在感出自『☆』 人不牺牲什么就什么也得不到，为了得到什么就要付出同样的代价，那就是炼金术的等价交换原则，那个时候，我们相信那是世界的真实。出自『钢之炼金术师』 思想中一旦有了依附，骨子里便失去了坚强；出自『网络』 星星之火，可以燎原。出自『张居正』 纸上得来终觉浅，绝知此事要躬行。出自『陆游』 要保持剑的锋利就得时时磨拭，要保持头脑灵光就得看书。出自『乔治·马丁』 俗话说不耻下问是一时之耻，耻而不问是一生之耻。出自『白箱』 累过方得闲，苦过方知甜。出自『网络』 不以物喜，不以己悲。出自『范仲淹』 若有恒，何必三更眠五更起；最无益，莫过一日曝十日寒；出自『毛泽东』 战略上藐视敌人，战术上重视敌人；出自『毛泽东』 人生路很长，永远不要高兴太早。出自『平常心』 人生就像一盒的巧克力，你永远不知道下一块是什么口味。出自『阿甘正传』 如果你不努力，一天比一天容易，但一年比一年难；如果你努力了，一天比一天难，但一年比一年容易。出自『网络』 只有内心强大，才能实现自我救赎；出自『9.18』 富，亦指精神；强，亦指内心；出自『9.18』 人一定要认清自己，自己能干什么，干得了什么，不要人云亦云。出自『★』 对社会不要有太多的抱怨。创业的时候不要把自己当人看。有行动不一定能成功，没有行动就一定失败。出自『俞敏洪』 那家伙永远都是挑战者出自『棒球大联盟』 做没做过的事情是要建立在老老实实的成功之后的基础之上。出自『★』]]></content>
      <categories>
        <category>零七碎八</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[photo]]></title>
    <url>%2Fphoto%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>零七碎八</category>
      </categories>
      <tags>
        <tag>picture</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-world%2F</url>
    <content type="text"><![CDATA[历程还记得在 Github 上生成的第一个 page 时的新奇还记得在 CSDN 的第一次开通博客的 Hello world 的兴奋如今在 Github 的 page 上生成了自己的博客，那可谓是即新奇 + 兴奋带来的激动可以在自己的这块领地为所欲为，光想想就有一种迎风而来的酸爽 致敬每一次的开始都仿佛打开一扇门而每扇门的背后都有着无数默默付出和无私奉献的人是他们让现在的这个圈子有了生态没有他们的付出我不会这么顺利的把这个博客搭建起来再次由衷的致敬这些人我愿成为向你们一样的人]]></content>
      <categories>
        <category>东拉西扯</category>
      </categories>
      <tags>
        <tag>Hello</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO+GitHub,搭建博客 - 域名绑定]]></title>
    <url>%2Fwwwyuming%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面也讲过了，我们把博客同时托管到 Github 和 Coding。我们就有两个域名可以访问站点，但是又出现几个问题：使用的不是自己的域名；两个地址的统计信息（文章阅读量，访问量等）相互独立，不能合并；github pages国内访问速度慢（300ms左右，毕竟国外的服务器）。 这就有点坑爹了，强迫症怎么能忍。下面给出解决方法。。 解决方案：我们知道 github 和 coding 的 pages 服务都提供 自定义域名 功能。我们可以利用这一点，绑定自己的域名。域名解析的时候实现国内访问 coding pages ，国外访问 github pages ,从而加快访问速度。 具体怎么实现，往下看： 购买域名首先我们要购买一个域名，推荐到 万网 购买。（毕竟很方便）具体步骤可以参考这篇文章：万网域名注册教程。 购买域名一定要实名认证，否则会停止解析 域名解析这一步是最重要的，我们要把域名指向 github 和 coding 的服务器空间。 登录阿里云，进入 控制台 。依次点击 域名与网站 &gt; 云解析DNS 就会出现你购买的域名信息 点击 解析，然后按照下图依次添加解析：（这张图片可以放大） 从上图可以看出，我们的解析实现了分流。国内线路访问Coding pages，国际线路访问Github Pages。 托管平台设置Coding平台进入对应项目的 pages 设置页面（项目 &gt; 代码 &gt; pages服务） 成功后会显示： Github平台进入对应项目的 pages 设置页面（setting &gt; github pages &gt; Custom domain) 成功后会显示： 到此我们的博客就可以正常运行了！！ 总结一切搞定后，在回头看一下我们的问题：@ 两个地址的统计信息（文章阅读量，访问量等）相互独立，不能合并； 从两个地址访问都会跳转到我们绑定的域名。统计信息自然也是绑定后域名的信息。 @ github pages国内访问速度慢（300ms左右） 我们测试一下 Ping：(表现不错) @ 托管平台给出的二级域名太丑。 不存在的…..]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Next+Hexo</tag>
        <tag>博客搭建</tag>
        <tag>域名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO 博客同时部署到 GitHub 和 Coding]]></title>
    <url>%2Fgithub%E5%92%8Ccoding%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很多人都把 hexo 托管到 Github 上，因为 Github 大家都用的比较久了。但是，你的博客主要访问者肯定还是国内的用户，国内的用户访问 coding 比 github 是要快不少的。还可以利用域名解析实现国内的走 coding，海外的走 github，分流网站的访问。 注册 GitHub 和 Codinggithub 官网 &nbsp;&nbsp;||&nbsp;&nbsp; Coding 官网 &nbsp;&nbsp;注册就不必多说，不会的可自行百度。需要注意的是：最好使用同一个 用户名 和 邮箱 ，以免引起不必要的麻烦。 创建项目在 GitHub 上创建项目，名称为：yourname.github.io在 Coding 上创建项目，名称为：yourname 配置 SSH配置 shh key 是让本地 git 项目与远程的 github 建立联系 获取 ssh 检查是否已经有 SSH Key，打开 Git Bash，输入 cd ~/.ssh 如果没有 .ssh 这个目录，则生成一个新的 SSH，输入 ssh-keygen -t rsa -C &quot;your e-mail&quot; 注意: 此处的邮箱地址，是你注册 GitHub 和 coding 时的邮箱地址; 此处的「-C」的是大写的「C」 。 接下来几步都直接按回车键,然后系统会要你输入密码 (防止别人往你的项目里提交内容) Enter passphrase (empty for no passphrase):&lt;输入加密串&gt;Enter same passphrase again:&lt;再次输入加密串&gt; 成功后，我们打开 C:\Users\cwyaml.ssh 打开 _idrsa.pub 文件。里面的代码就是 ssh key。 添加 SSH Key 到 GitHub 和 CodingGitHub 添加方法： 进入 Github 官网，点击头像，再按 settings 进入设置。 点击 New SSH key 创建 title 输入邮箱，key 里面粘贴刚才右击复制的内容,再点 Add SSH key 即可。（会让你输入密码） Coding 添加方法： 登录账号后点击 左侧账户 在点 SSH 公钥 设置即可 。（同样要输入密码） 测试 SSH 是否配置成功打开 Git Bash，首先测试 GitHub 是否成功？输入: ssh -T git@github.com (如配置了密码则要输入密码,输完按回车。)如果显示以下内容，则说明 Github 中的 ssh 配置成功。 Hi username! You&apos;ve successfully authenticated, but GitHub does notprovide shell access. 然后测试 Coding 是否成功？ ssh -T git@git.coding.net 如果显示以下则说明配置成功： Hello username You&apos;ve connected to Coding.net by SSH successfully! 上传博客文件修改站点配置文件： # Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: github: git@github.com:cwyaml/cwyaml.github.io.git,master coding: git@git.coding.net:cwyaml/cwyaml.git,master 然后你就可以 hexo c、hexo g、hexo d 了。 开启 pages 服务GitHub 已经默认开启，就不必多说了。Coding 进入对应项目，点击 代码&gt;pages 服务 ，把部署来源改为 master 即可。 访问博客这样我们整个部署过程就完成了。有两个地址可以访问我们的博客：GitHub pages：https://cwyaml.github.ioCoding pages：https://cwyaml.coding.me]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Next+Hexo</tag>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO+GitHub,搭建博客 - 备份]]></title>
    <url>%2Fbackup%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用Hexo写博客是一件比较享受的事情，无奈如果换电脑或者系统崩了的话，你就会一脸懵B了，备份博客就显得尤为重要。先说说我的感受，博客刚搭建好的时候就想过这个问题，那时候对 git 似懂非懂吧。在网上找了很多教程方法，大概就是说要创建一个分支来存放 blog 文件，但是翻腾来翻腾去还是没有搞定。 最后索性简单粗暴点，在 GitHub 上创建一个仓库，把 blog 文件整个打包上传。使用过程中发现这个方法还不错，至少对于小白来说很容易理解，也很难出错，就一直沿用到现在。 这种方式虽然能够备份 Hexo 博客的源文件，但是对于博主这种懒人，每次更新博文都需要输入两三行重复的Git命令真是一件麻烦的事情。 自动备份准备本方法需要提前将 Hexo 加入 Git仓库 并与 Github 远程仓库绑定之后，才能正常工作。具体做法可以参考：上传本地项目到GitHub 安装 shelljs 模块要实现这个自动备份功能，需要依赖 NodeJs 的一个 shelljs 模块,该模块重新包装了 child_process,调用系统命令更加的方便。使用以下命令，完成 shelljs 模块的安装：npm install --save shelljs 编写自动备份脚本待到模块安装完成，在Hexo根目录 的 scripts文件夹下新建一个js文件，文件名随意取。如果没有scripts目录，请新建一个。require(&apos;shelljs/global&apos;);try &#123; hexo.on(&apos;deployAfter&apos;, function() &#123;//当deploy完成后执行备份 run(); &#125;);&#125; catch (e) &#123; console.log(&quot;产生了一个错误&lt;(￣3￣)&gt; !，错误详情为：&quot; + e.toString());&#125;function run() &#123; if (!which(&apos;git&apos;)) &#123; echo(&apos;Sorry, this script requires git&apos;); exit(1); &#125; else &#123; echo(&quot;======================Auto Backup Begin===========================&quot;); cd(&apos;C:/Blog&apos;); //此处修改为Hexo根目录路径 if (exec(&apos;git add .&apos;).code !== 0) &#123; echo(&apos;Error: Git add failed&apos;); exit(1); &#125; if (exec(&apos;git commit -m &quot;Form auto backup script\&apos;s commit&quot;&apos;).code !== 0) &#123; echo(&apos;Error: Git commit failed&apos;); exit(1); &#125; if (exec(&apos;git push origin master&apos;).code !== 0) &#123; echo(&apos;Error: Git push failed&apos;); exit(1); &#125; echo(&quot;==================Auto Backup Complete============================&quot;) &#125;&#125; 注意： 其中，需要修改第17行的 D:/hexo 路径为 Hexo的根目录 路径。（脚本中的路径为博主的Hexo路径） 如果你的Git远程仓库名称不为 origin 的话，还需要修改第28行执行的push命令，修改成自己的远程仓库名和相应的分支名。 测试保存脚本并退出，然后执行 hexo d 命令，将会得到类似以下结果:INFO Deploying: gitINFO Clearing .deploy_git folder...INFO Copying files from public folder.........======================Auto Backup Begin===========================warning: LF will be replaced by CRLF in package.json.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in source/_posts/hexo1.md.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in source/_posts/update to github.md.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in source/_posts/wangyimusic.md.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in themes/next-5.0.1/layout/_partials/head.swig.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in source/_posts/backup.md.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in source/_posts/encrypt.md.The file will have its original line endings in your working directory.[master 1bb6cc5] Form auto backup script&apos;s commit Committer: unknownYour name and email address were configured automatically basedon your username and hostname. Please check that they are accurate.You can suppress this message by setting them explicitly. Run thefollowing command and follow the instructions in your editor to edityour configuration file: git config --global --editAfter doing this, you may fix the identity used for this commit with: git commit --amend --reset-author 6 files changed, 177 insertions(+), 2 deletions(-) create mode 100644 scripts/autobackup.js create mode 100644 source/_posts/backup.md create mode 100644 source/_posts/encrypt.mdTo https://github.com/cwyaml/blog-backup.git d7bc718..1bb6cc5 master -&gt; master==================Auto Backup Complete============================ 这样子，每次更新博文并 deploy 到服务器上之后，备份就自动启动并完成备份啦~是不是很方便呢？ Enjoy it！ 参考：wanghao大神 自动备份Hexo博客源文件]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Next+Hexo</tag>
        <tag>博客搭建</tag>
        <tag>backup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 使用中常见的问题及解决方法]]></title>
    <url>%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就像 Markdown 官方文档里描述的一样：可读性，无论如何，都是最重要的。 Markdown 的目标是实现 &nbsp; 『易读易写』 。&nbsp;Markdown 从发布到现在备受好评，经过这一段的使用，整体感觉挺顺手，不过还是存在很多问题，所以总结一下喽。。 编辑器其实自己喜欢的才是最好的。(像 vim 、emacs什么的不推荐，因为我也不会用) MAC平台自己没用过，不做推荐。你可以看看这个帖子：Mac 上适合码农用的 Markdown 编辑器是什么？ Windows平台印象笔记马克飞象传送门，界面不是很好看，书写的时候感觉很别扭 有道云笔记有道传送门，同样很丑，强迫症受不了 Sublime Text强大的 Sublime Text 总是能给我们很多惊喜，经过各种对比，sublime 满足了我对审美的要求。首先我们需要安装两个插件：（至于怎么安装就不说了） markdownEditing 用来书写 markdownPreview 用来预览 Atom（强烈推荐）GitHub 推出的编辑器，界面很好（就是启动有点慢），必须支持一下。默认继承了 markdown 预览，快捷键为 Ctrl+shift+M。推荐插件： markdown-preview 实时预览 markdown-scroll-sync 编辑区和预览区同步滚动 markdown-writer 方便管理图片链接等 markdown-table-formatte 表格格式化 使用方法Markdown官方文档 常见问题汇总html标签显示比如说我要写一篇博客，标题为“html中 &lt;canvas&gt; 的使用”## html中 &lt;canvas&gt; 的使用 如果这样写就会出现排版上的问题（不信你试一下），那么怎么解决呢？其实认真想一下就能明白，Markdown 的语法是基于 html 的，我们直接写 &lt;canvas&gt;，自然会被理解为一个标签，而不是要显示的文本。。所以，问题回归到 html 上。在网页中，我们要显示 &lt;canvas&gt; 时要用到 转义字符, 所以 Markdown 中也一样，我们应该这样写：## html中 &amp;lt;canvas&amp;gt; 的使用 代码语法高亮这个问题困扰了我好久，官方文档里竟然没有说明！只好自己去查找方法。Markdown 中显示代码块是这样的格式：显示为：&lt;p&gt;这是一个p标签&lt;/p&gt; 而我们这样写：就可以实现代码高亮了&lt;p&gt;这是一个p标签&lt;/p&gt; 据说这种方式一共支持四十多种语言，有兴趣的话你可以研究一下。 图片Markdown 中嵌入图片，如果使用本地图片就要用到 html 标签来引用，这种方法很稳定，但是使文档变得很大（一张图片最少几百k吧）。所以我们要用到 图床 。 贴图库推荐使用 &nbsp; 贴图库 &nbsp;快速，免费（我使用过程中没掉过链子） 注册登录，就可以上传图片，每张图片自动生成 原图、展示图和 缩略图的图片外链、html代码、Markdown外链等。只要把对应的代码粘贴到你的文档中就可以了。。 七牛云存储这个最近很火，可靠、可扩展、低成本等等有很多优点。你可以试一下。我们主要用到他的 对象存储 服务，创建一个公开仓库，把图片上传就可以生成外链了。 gifGithub 上的开源项目，ReadMe.md 是也支持 Markdown 语法的，通常会看到很多开源项目的 ReadMe 中有 动态演示效果，看到这个项目的人一目了然，非常方便，gif本身也是一种图片格式，在 Markdown 中 引用时和正常图片的引用一样，但需要专门的工具生成 gif 格式的图片才行，在这里强烈推荐 LICEcap，它是一款 windows 上的录屏软件，录制后保存的格式为 gif，体积小并且同样也可以在图床上生成链接。 插入音乐你可以把音乐文件下载到本地，然后简单粗暴的使用 html 中的 &lt;video&gt; 标签。当然，如果这样就不必写下去了，告诉你简单的方法：网易云音乐 打开网易云音乐网页版，搜索自己喜欢的音乐，比如我找到 告白气球 我们可以看到在图片的下边有一个 生成外链播放器 , 点击会出现 选择 合适的尺寸 和 播放模式 之后。把下边的代码复制到你的 Markdown 文档中就可以了。试着听一下吧！！(我选择了最小尺寸) 试着去把一个 歌单生成外链播放器 插入到你的 Markdown 中，这样你跟新歌单你的博文也会跟着变化，而不必在想跟换歌曲时头疼]]></content>
      <categories>
        <category>零七碎八</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单博文加密]]></title>
    <url>%2Fencrypt%2F</url>
    <content type="text"><![CDATA[即使是最简单的加密方式也足以阻止90%的访问者 原理由于 Hexo 最终编译出来的是静态文件，也就意味着文章的所有信息会原封不动展示在页面中，当你输入一篇文章的地址，所有的内容就已经跟随网络传输过来了。那么博客使用加密是怎么实现的呢？ 这就要讲到 js 的阻塞机制了，当调用 alert(); 函数的时候，整个页面会停止运行，直到你点击确定之后，才会继续执行下去。我们这里需要的也是这样一个假象，阻止整个页面的渲染，直到你输入了正确的密码才能让页面继续渲染实际的文章。可是 alert(); 只有提醒的功能，没有输入的功能，所以，这里要用到的是 promt() 方法。 promt()方法介绍这个 promt() 方法有什么作用呢？查看js文档可以知道： prompt()方法 : 用于显示可提示用户进行输入的对话框。如果用户单击提示框的 取消 按钮，则返回 null。如果用户单击 确认按钮，则返回 输入字段当前显示的文本（用户输入的文本）。 我们就是利用 promt() 方法可以返回用户输入的文本这个特性，获取到返回数据，与我们设置的密码进行验证，从而实现文档加密的。。 实践找到 themes\next\layout\_partials\head.swig 文件。在 &lt;meta&gt; 标签之后添加以下代码：&lt;script&gt; (function()&#123; if(&apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123; if (prompt(&apos;请输入文章密码&apos;,&apos;&apos;) !== &apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123; alert(&apos;密码错误！&apos;); history.back(); &#125; &#125; &#125;)();&lt;/script&gt; 这里有必要解释一下 page.password 是什么东西。以下我给出这篇文章的头部参考：首先 page 是一个变量，你可以理解为这篇文章。以下面的代码为参考，那么 page.title = 最简单的翻墙方法; page.comments = fasle;（很好理解吧） title: 最简单的翻墙方法date: 2017-03-01 12:01:05tags: [翻墙,hosts]categories: [外面的世界]keywords: 翻墙,hostscomments: false 所以，要想加密博文，我们要为文章加上 password 属性。description 属性用于对文章进行描述。（加密下显示内容）description: 文章访问密码：passwordpassword: password 总结这种方式只能说是一点小技巧的应用吧，在大神面前可能不管用，但足以阻挡大多数用户。更完美的博文加密方式请参考：加密博客内容，使用密码访问]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Next+Hexo</tag>
        <tag>博客搭建</tag>
        <tag>encrypt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO+GitHub搭建博客 - 优化]]></title>
    <url>%2Fhexo2%2F</url>
    <content type="text"><![CDATA[本篇文章主要介绍基于NexT主题的一些第三方功能的实现。基本功能的设置可以参考Next官网文档 首先，我们需要明白： 在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml 。其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。我们约定，将前者称为 站点配置文件 ，后者称为 主题配置文件。 背景动态背景修改 _layout.swig 模板模板位置：themes\next\layout\_layout.swig在末尾前加上下面一句:（这里提供两种样式，当然你也可以自由更改）&lt;!-- 动态背景 --&gt;#默认灰色线条&lt;script type="text/javascript" src="/js/src/particle.js"&gt;&lt;/script&gt;#浅蓝色线条&lt;script type="text/javascript" src="/js/src/particle.js" count="50" zindex="-2" opacity="1" color="0,104,183"&gt;&lt;/script&gt; 然后在 themes\source\js\src\ 下新建文件 particle.js 写上以下代码:!function()&#123;function n(n,e,t)&#123;return n.getAttribute(e)||t&#125;function e(n)&#123;return document.getElementsByTagName(n)&#125;function t()&#123;var t=e("script"),o=t.length,i=t[o-1];return&#123;l:o,z:n(i,"zIndex",-1),o:n(i,"opacity",.5),c:n(i,"color","0,0,0"),n:n(i,"count",99)&#125;&#125;function o()&#123;c=u.width=window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth,a=u.height=window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight&#125;function i()&#123;l.clearRect(0,0,c,a);var n,e,t,o,u,d,x=[w].concat(y);y.forEach(function(i)&#123;for(i.x+=i.xa,i.y+=i.ya,i.xa*=i.x&gt;c||i.x&lt;0?-1:1,i.ya*=i.y&gt;a||i.y&lt;0?-1:1,l.fillRect(i.x-.5,i.y-.5,1,1),e=0;e&lt;x.length;e++)n=x[e],i!==n&amp;&amp;null!==n.x&amp;&amp;null!==n.y&amp;&amp;(o=i.x-n.x,u=i.y-n.y,d=o*o+u*u,d&lt;n.max&amp;&amp;(n===w&amp;&amp;d&gt;=n.max/2&amp;&amp;(i.x-=.03*o,i.y-=.03*u),t=(n.max-d)/n.max,l.beginPath(),l.lineWidth=t/2,l.strokeStyle="rgba("+m.c+","+(t+.2)+")",l.moveTo(i.x,i.y),l.lineTo(n.x,n.y),l.stroke()));x.splice(x.indexOf(i),1)&#125;),r(i)&#125;var c,a,u=document.createElement("canvas"),m=t(),d="c_n"+m.l,l=u.getContext("2d"),r=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(n)&#123;window.setTimeout(n,1e3/45)&#125;,x=Math.random,w=&#123;x:null,y:null,max:2e4&#125;;u.id=d,u.style.cssText="position:fixed;top:0;left:0;z-index:"+m.z+";opacity:"+m.o,e("body")[0].appendChild(u),o(),window.onresize=o,window.onmousemove=function(n)&#123;n=n||window.event,w.x=n.clientX,w.y=n.clientY&#125;,window.onmouseout=function()&#123;w.x=null,w.y=null&#125;;for(var y=[],s=0;m.n&gt;s;s++)&#123;var f=x()*c,h=x()*a,g=2*x()-1,p=2*x()-1;y.push(&#123;x:f,y:h,xa:g,ya:p,max:6e3&#125;)&#125;setTimeout(function()&#123;i()&#125;,100)&#125;(); 鼠标点击小红心在 \themes\next\source\js\src 文件目录下添加 love.js 文件。内容为：!function(e,t,a)&#123;function n()&#123;c(".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText="left:"+d[e].x+"px;top:"+d[e].y+"px;opacity:"+d[e].alpha+";transform:scale("+d[e].scale+","+d[e].scale+") rotate(45deg);background:"+d[e].color+";z-index:99999");requestAnimationFrame(r)&#125;function o()&#123;var t="function"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement("div");a.className="heart",d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement("style");a.type="text/css";try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName("head")[0].appendChild(a)&#125;function s()&#123;return"rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")"&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 找到 \themes\next\layout\_layout.swing 文件， 在文件的后面， 标签之前 添加以下代码：&lt;!-- 小红心 --&gt;&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt; 头像圆形旋转修改文件 themes/next/source/css/_common/components/sidebar/sidebar-author.styl我的样式文件 文章结尾模板在 \themes\next\_macro 文件目录下添加 passage-end-tag.swig 文件，内容为：(当然你也可以修改为自己喜欢的样式)&#123;% if theme.passage_end_tag.enabled %&#125;&lt;blockquote class="blockquote-center"&gt; &lt;p&gt;如果您觉得本博客还不错，欢迎继续关注本博客，欢迎多提宝贵意见，非常感谢！&lt;/p&gt;&lt;/blockquote&gt;&lt;span id="inline-green" style="border-radius:3px;"&gt;作者&lt;/span&gt;：&lt;a class="link-blue" href="https://github.com/cwyaml" target="_blank"&gt;cwyaml&lt;/a&gt;有问题请 &lt;a class="link-blue" href="https://cwyaml.github.io/about/"&gt;留言&lt;/a&gt;或者私信我的 &lt;a class="link-blue" href="http://weibo.com/u/5742789641?refer_flag=1001030102_&amp;is_all=1" target="_blank"&gt;微博&lt;/a&gt;。&lt;div style="text-align:center; color:#ccc; font-size:14px; "&gt; ------本文结束 &amp;nbsp;&lt;i class="fa fa-paw"&gt;&lt;/i&gt;&amp;nbsp; 感谢阅读------&lt;/div&gt;&#123;% endif %&#125; 找到 \themes\next\_macro\post.swig 文件，使用查找功能找到 reward.swig，在这一个 &lt;div&gt; 的前面添加：&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'passage-end-tag.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 文章底部标签云锚点在 themes\next\layout\_macro\post.swig 文件中找到以下代码：&lt;footer class="post-footer"&gt;&lt;!--这是文章底部标签云锚点，不喜欢就注释掉 &#123;% if post.tags and post.tags.length and not is_index %&#125; &lt;div class="post-tags"&gt; &#123;% for tag in post.tags %&#125; &lt;a href="&#123;&#123; url_for(tag.path) &#125;&#125;" rel="tag"&gt;# &#123;&#123; tag.name &#125;&#125;&lt;/a&gt; &#123;% endfor %&#125; &lt;/div&gt; &#123;% endif %&#125;--&gt; 关于文章内文本样式Markdown 毕竟是为了方便写作，在样式上就过于单调。我们自己来给文章加一些样式。。 Next 作者提供了一个供用户自己定义样式的文件：\themes\next\source\css\_custom\custom.stl 自己按需要写在上述文件中写上自己的 class 类，然后在 Markdown 文档中使用。我的custom.styl 引用前端框架目前流行的前端框架，像 bootstrap、React、Angular 等，提供给我们很好的前端方案，我们可以把喜欢的引入到上面说的那个文件里，然后就可以使用了。 设置动态title 在 \themes\next\source\js\src 目录下新建 dytitle.js 。添加以下内容： &lt;!--崩溃欺骗--&gt;var OriginTitile = document.title; var titleTime; document.addEventListener(&apos;visibilitychange&apos;, function () &#123; if (document.hidden) &#123; $(&apos;[rel=&quot;icon&quot;]&apos;).attr(&apos;href&apos;, &quot;/img/TEP.ico&quot;); document.title = &apos; 页面崩溃啦 ~ | cwyaml！&apos;; clearTimeout(titleTime); &#125; else &#123; $(&apos;[rel=&quot;icon&quot;]&apos;).attr(&apos;href&apos;, &quot;/favicon.ico&quot;); document.title = &apos; 噫又好了~ &apos; + OriginTitile; titleTime = setTimeout(function () &#123; document.title = OriginTitile; &#125;, 2000); &#125; &#125;); 更改 \themes\next\layout\_layout.swig 。在 &lt;/body&gt; 之前添加： &lt;!--崩溃欺骗--&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/dytitle.js&quot;&gt;&lt;/script&gt; 首页动画在 主题配置文件 中，找到 Motion 字段。true 和 false 控制动画的开启与关闭。# Motionuse_motion: true 内容宽度现在一般的笔记本都在15寸以上，博客页面两侧留白太多就显得没有必要，并且不美观，所以有必要调整一下宽度。（可以慢慢试着调整到最合适的状态） 找到 \themes\next\source\css\_common\components\post\post-expand.styl，找到： @media (max-width: 767px)改为：@media (max-width: 1060px) 找到：\themes\next\source\css\ _variables\base.styl ，找到： $main-desktop = 960px$main-desktop-large = 1200px$content-desktop = 700px改为：$main-desktop = 1060px$main-desktop-large = 1200px$content-desktop = 800px 找到 \themes\next\source\css\_schemes\Pisces\_layout.styl ，将第 4 行的 width 改为 1060px ，修改后如下： .header &#123; position: relative; margin: 0 auto; width: 1060px; 统计功能文章阅读次数统计参考： LeanCloud 不蒜子统计站点访问 全局配置：编辑 主题配置文件 中的 busuanzi_count 的配置项，配置以下内容：当 enable: true 时，代表开启全局开关。若 site_uv、site_pv、page_pv 的值均为 false 时，不蒜子仅作记录而不会在页面上显示。 站点 UV/PV 配置：当 site_uv: true 时，代表在页面底部显示站点的 UV 值。当 site_pv: true 时，代表在页面底部显示站点的 PV 值site_uv_header(site_pv_header) 和 site_uv_footer(site_pv_footer) 为自定义样式配置，相关的值留空时将不显示，可以使用（带特效的）font-awesome。显示效果为 [site_uv_header]UV值/PV值[site_uv_footer]。 busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: 本站总访问量 site_uv_footer: # custom pv span for the whole site site_pv: true site_pv_header: 您是第 site_pv_footer: 位小伙伴 单页面 PV 值设置： # custom pv span for one page onlypage_pv: falsepage_pv_header: &lt;i class=&quot;fa fa-file-o&quot;&gt;&lt;/i&gt;page_pv_footer: 开启打赏功能越来越多的平台（微信公众平台，新浪微博，简书等）支持打赏功能，付费阅读时代越来越近，特此增加了打赏功能。 只需要 主题配置文件 中填入 微信 和 支付宝 收款二维码图片地址（放在博客根目录的source文件夹下即可） 即可开启该功能。reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！wechatpay: /weixin.pngalipay: /zhifubao.png 设置RSS 需要安装 hexo-generator-feed 插件。 $ npm install hexo-generator-feed --save 在 站点配置文件 中添加字段： feed: type: atom path: atom.xml limit: 20 hub: content: 听音乐 下载js文件：high.swig。放在 \themes\next\layout\_macro 目录下。 在侧边栏引用该文件：修改 \themes\next\layout\_macro\sidebar.swig ，添加以下代码： &#123;% include &apos;high.swig&apos; %&#125; 样式修改：使 听音乐 和 RSS 并排展示，修改 \themes\next\source\css\_schemes\Pisces\_sidebar.styl display: inline-block; 添加自己喜欢的音乐：修改其中的歌曲链接即可（获取歌曲外链教程） var songs = [ "http://m2.music.126.net/3uHnH7uQAeFwUfuvEB9lrg==/3265549619475054.mp3", "http://m2.music.126.net/NnHwR2HV-1OoKZ6R5LVy4Q==/18502581673300023.mp3", "http://m2.music.126.net/qv3RI4K7ABKJ0TyAdb3taw==/3250156397064860.mp3", "......" ]; 首页听音乐摇晃：需要加载css样式。在 themes\next\layout\_layout.swig 文件的 body标签结束前 添加以下代码： &lt;!-- 听音乐摇晃 --&gt;&lt;link href="http://s3.amazonaws.com/moovweb-marketing/playground/harlem-shake-style.css" rel="stylesheet" type="text/css"&gt; 注意： 有时候使用 Firefox 、Chrome时会提示非法插件并禁止使用，遇到这种情况我们把样式代码引入到 \themes\next\source\css\_custom\custom.stl 文件即可解决。 添加 Forkme on GitHub 丝带首先进入 GitHub Ribbons 选择自己喜欢的丝带样式。找到 \themes\next\layout\_layout.swig 文件，在 &lt;header&gt; 标签前面添加：（记得把链接修改成自己的GitHub主页）&lt;a href="https://github.com/you"&gt;&lt;img style="position: absolute; top: 0; left: 0; border: 0;" src="https://camo.githubusercontent.com/82b228a3648bf44fc1163ef44c62fcc60081495e/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f6c6566745f7265645f6161303030302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_left_red_aa0000.png"&gt;&lt;/a&gt; 给 Blog 添加 LICENSE修改 主题配置文件 （使用查找功能）# Creative Commons 4.0 International License.# http://creativecommons.org/# Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zerocreative_commons: by-nc-sa#creative_commons: Local Search 安装 hexo-generator-searchdb $ npm install hexo-generator-searchdb --save 编辑 站点配置文件 ，添加以下字段： search: path: search.xml field: post format: html limit: 10000 编辑 主题配置文件 ，启用本地搜索 # Local searchlocal_search: enable: true 多说多说评论使用多说前需要先在 多说 创建一个站点。具体步骤如下： 登录后在首页选择“我要安装”。 创建站点，填写站点相关信息。多说域名 这一栏填写的就是你的 duoshuo_shortname, 创建站点完成后在 站点配置文件 中新增 duoshuo_shortname 字段，值设置成上一步中的值即可。 多说评论框自定义 : 我的样式代码 多说分享在 主题配置文件 中设置：# Shareduoshuo_share: true 禁用鼠标经过时分享更多功能（有bug）:找到 \themes\next\layout\_partials\share\duoshuo_share.swig 文件，替换内容为：&lt;div class="ds-share flat" data-thread-key="&#123;&#123; page.path &#125;&#125;" data-title="&#123;&#123; page.title &#125;&#125;" data-content="" data-url="&#123;&#123; page.permalink &#125;&#125;"&gt; &lt;div class="ds-share-inline"&gt; &lt;ul class="ds-share-icons-16"&gt; &lt;li&gt;&lt;span class="ds-more"&gt;分享到：&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;a class="ds-weibo" href="javascript:void(0);" data-service="weibo"&gt;微博&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a class="ds-qzone" href="javascript:void(0);" data-service="qzone"&gt;QQ空间&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a class="ds-qqt" href="javascript:void(0);" data-service="qqt"&gt;腾讯微博&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a class="ds-wechat" href="javascript:void(0);" data-service="wechat"&gt;微信&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a class="ds-facebook" href="javascript:void(0);" data-service="facebook"&gt;Facebook&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a class="ds-google" href="javascript:void(0);" data-service="google"&gt;Google&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class="ds-share-icons-more"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 博文压缩目前知道的有两个插件可以压缩博文，hexo-all-minifier 插件和 gulp插件。hexo-all-minifier 虽然使用比较简单，而且也可以压缩图片，但是对文章缩进（输入法全拼模式下按 Tab）不支持，所以暂时使用 gulp 压缩手段。 hexo-all-minifier 使用方法安装 hexo-all-minifier，在站点的根目录下执行以下命令：$ npm install hexo-all-minifier --save hexo g 编译的时候就会自动压缩 HTML、JS、图片。详情参考插件介绍 hexo-all-minifier glup 使用方法hexo 依赖 gulp 插件安装，在站点的根目录下执行以下命令：$ npm install gulp -g$ npm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp --save 在 package.json 同级目录下，新建 gulpfile.js 并填入以下内容：var gulp = require(&apos;gulp&apos;);var minifycss = require(&apos;gulp-minify-css&apos;);var uglify = require(&apos;gulp-uglify&apos;);var htmlmin = require(&apos;gulp-htmlmin&apos;);var htmlclean = require(&apos;gulp-htmlclean&apos;);// 压缩 public 目录 cssgulp.task(&apos;minify-css&apos;, function() &#123; return gulp.src(&apos;./public/**/*.css&apos;) .pipe(minifycss()) .pipe(gulp.dest(&apos;./public&apos;));&#125;);// 压缩 public 目录 htmlgulp.task(&apos;minify-html&apos;, function() &#123; return gulp.src(&apos;./public/**/*.html&apos;) .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest(&apos;./public&apos;))&#125;);// 压缩 public/js 目录 jsgulp.task(&apos;minify-js&apos;, function() &#123; return gulp.src(&apos;./public/**/*.js&apos;) .pipe(uglify()) .pipe(gulp.dest(&apos;./public&apos;));&#125;);// 执行 gulp 命令时执行的任务gulp.task(&apos;default&apos;, [ &apos;minify-html&apos;,&apos;minify-css&apos;,&apos;minify-js&apos;]); 生成博文是执行 hexo g &amp;amp;&amp;amp; gulp 就会根据 gulpfile.js 中的配置，对 public 目录中的静态资源文件进行压缩。 博文置顶 修改 hexo-generator-index 插件。替换文件：node_modules/hexo-generator-index/lib/generator.js 为：generator.js 设置文章置顶在文章 Front-matter 中添加 top 值，数值越大文章越靠前，如：---title: cwyaml 图集categories: [图片]tags: [picture]date: 2015-04-02 14:36:04top: 10--- 博文部署 message在 \node_modules\hexo-deployer-git\lib\deployer.js 文件末尾找到这一句：（记得个性一点）Lucky Boy: &#123;&#123; now(\&apos;YYYY-MM-DD HH:mm:ss\&apos;) &#125;&#125;. 图片模式 新建博文，设置 type: &quot;picture&quot;，使用 {\% gp x-x \%} ... {\% endgp \%} 标签引用要展示的图片地址，如下所示：(其中的 x-x 为图片展示效果，可以自己尝试一下) ---title: Naruto-Picturescategories: [图片]tags: [picture]date: 2014-06-02 10:36:02type: "picture"comments: false---&#123;% gp 5-3 %&#125;![](http://oapjp6spr.bkt.clouddn.com/18210.jpg)![](http://oapjp6spr.bkt.clouddn.com/196232.jpg)![](http://oapjp6spr.bkt.clouddn.com/224147.jpg)![](http://oapjp6spr.bkt.clouddn.com/199301.jpg)![](http://oapjp6spr.bkt.clouddn.com/213318.jpg)&#123;% endgp %&#125;]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Next+Hexo</tag>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO+GitHub,搭建博客 - 配置]]></title>
    <url>%2Fhexo1%2F</url>
    <content type="text"><![CDATA[本篇文章主要介绍怎样利用 Hexo + Next 在 GitHub 上搭建个人博客。 简介&nbsp;&nbsp;Hexo 是一个快速、简洁且高效的静态站点生成框架，基于 Node.js 。 它有以下特点： 超快速度Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。 支持 MarkdownHexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。 一件部署只需一条指令即可部署到 Github Pages，或其他网站 丰富的插件Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 Markdown 本身的语法之外，还可以使用 Hexo 提供的 标签插件 来快速的插入特定形式的内容。 基于 Hexo 这个优秀的博客框架，很多优秀的开发者奉献出了它们基于 Hexo 开发的主题。NexT 因其 &nbsp; 精于心，简于形 &nbsp; 的风格，一直被广大用户所喜爱。 准备工作安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序: Node.js &gt; Git 如果您的电脑中已经安装上述必备程序，跳过这一步。如果你的电脑中尚未安装所需要的程序，请根据以下安装指示完成安装。 安装 Git Windows：下载安装 git 。 Download Now Mac：使用 Homebrew，MacPorts 或下载 安装程序 安装 Linux（Ubuntu，Debian）：sudo apt-get install git-core Linux（Fedora，Red Hat，CentOS）：sudo yum install git-core 安装 Node.js安装 Node.js 的最佳方式是使用 nvm。（nvm：Node Version Manager）windows 下使用 nvm 请看这里： nvm-windows ，首先需要下载安装 nvm 。 Download Now windows 下安装完 nvm 以后，我们可以打开命令行中执行命令 $ nvm$ nvm install latest 执行完以后，重启命令行，执行命令 node -v ，如果出现版本号，那么 Node.js 就安装成功了。 如果没有安装成功，那可能就是墙的原因。建议下载 Node.js 直接安装。 Download Now 安装 Hexo有了 Node.js ，我们可以使用 npm 安装 Hexo。（执行完以后，我们同样可以执行命令 hexo -v 查看是否安装成功就安装成功了。） $ npm install -g hexo-cli Hexo 安装完成后，我们需要为我们的 blog 项目创建一个指定文件夹（例如我在 D 盘根目录下创建了一个文件夹 blog 。D:\blog ），在该文件夹中执行以下命令， Hexo 将会在指定文件夹中新建所需要的文件。 $ hexo init$ npm install 等待安装，安装完成后，指定文件夹 的目录如下： ├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── 继续执行命令 $ hexo g //编译$ hexo s --debug //开启本地服务 这个时候，我们在浏览器中访问 http://localhost:4000/ ，就可以看到基于 Hexo 的默认主题的原型： 到目前为止我们的本地博客已经部署完成。下面我们换上 Next 主题。 使用 Next 主题下载 NexT 主题依旧是在当前目录下，使用 Git checkout 代码： $ git clone https://github.com/iissnan/hexo-theme-next themes/next 等待下载完成。 启用 NexT 主题打开 站点配置文件 (Hexo 文件夹下的_config.yml文件)，找到 theme 字段，并将其值更改为 next 。到此， NexT 主题安装完成。下一步我们依次执行以下命令验证主题是否正确启用。 $ hexo clean$ hexo g$ hexo s 我们在浏览器中访问 http://localhost:4000/ ，你将看到： 总结本地调试三部曲： $ hexo clean$ hexo g$ hexo s --debug 这种带 debug 的运行，如果出现错误，可以在命令行中看到错误提示信息。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Next+Hexo</tag>
        <tag>博客搭建</tag>
      </tags>
  </entry>
</search>